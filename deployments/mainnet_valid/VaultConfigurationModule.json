{
  "address": "0x77a903733d36A8bAF751b00F376ca75201ab0D1d",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "contract Authority",
          "name": "_authority",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "AuthorityUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomFeePercent",
          "type": "uint256"
        }
      ],
      "name": "CustomFeePercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomHarvestDelay",
          "type": "uint256"
        }
      ],
      "name": "CustomHarvestDelayUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomHarvestWindow",
          "type": "uint256"
        }
      ],
      "name": "CustomHarvestWindowUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "CustomTargetFloatPercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newDefaultFeePercent",
          "type": "uint256"
        }
      ],
      "name": "DefaultFeePercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newDefaultHarvestDelay",
          "type": "uint64"
        }
      ],
      "name": "DefaultHarvestDelayUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "newDefaultHarvestWindow",
          "type": "uint128"
        }
      ],
      "name": "DefaultHarvestWindowUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newDefaultTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "DefaultTargetFloatPercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnerUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "authority",
      "outputs": [
        {
          "internalType": "contract Authority",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultFeePercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultHarvestDelay",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultHarvestWindow",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultTargetFloatPercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomFeePercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomHarvestDelay",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomHarvestWindow",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomTargetFloatPercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "setAuthority",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newDefaultFeePercent",
          "type": "uint256"
        }
      ],
      "name": "setDefaultFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "newDefaultHarvestDelay",
          "type": "uint64"
        }
      ],
      "name": "setDefaultHarvestDelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "newDefaultHarvestWindow",
          "type": "uint128"
        }
      ],
      "name": "setDefaultHarvestWindow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newDefaultTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "setDefaultTargetFloatPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "setOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "customFeePercent",
          "type": "uint256"
        }
      ],
      "name": "setVaultCustomFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "customHarvestDelay",
          "type": "uint64"
        }
      ],
      "name": "setVaultCustomHarvestDelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint128",
          "name": "customHarvestWindow",
          "type": "uint128"
        }
      ],
      "name": "setVaultCustomHarvestWindow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "customTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "setVaultCustomTargetFloatPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncHarvestDelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncHarvestWindow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncTargetFloatPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x26d2be3d2ab78cad3dccf4d5ae9a5a303c0e1173ae4969818bb76fcaa6f21d64",
  "receipt": {
    "to": null,
    "from": "0x1594B6Fd7C346376E51C4Cf46525a9c57c5ea916",
    "contractAddress": "0x77a903733d36A8bAF751b00F376ca75201ab0D1d",
    "transactionIndex": 205,
    "gasUsed": "1017622",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000000000000004000000400080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000001000000000000000000000000000000000000000000020000000000000000000000000000000000000010000000000000000000000000000081080000000000000000000000010000020000000000040000000000000000000000000000000000",
    "blockHash": "0x94c0b3ab20bb2e9f02143984e57ce3b9395a0d0b82c1ab853ccc639983823440",
    "transactionHash": "0x26d2be3d2ab78cad3dccf4d5ae9a5a303c0e1173ae4969818bb76fcaa6f21d64",
    "logs": [
      {
        "transactionIndex": 205,
        "blockNumber": 14225827,
        "transactionHash": "0x26d2be3d2ab78cad3dccf4d5ae9a5a303c0e1173ae4969818bb76fcaa6f21d64",
        "address": "0x77a903733d36A8bAF751b00F376ca75201ab0D1d",
        "topics": [
          "0x8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916"
        ],
        "data": "0x",
        "logIndex": 392,
        "blockHash": "0x94c0b3ab20bb2e9f02143984e57ce3b9395a0d0b82c1ab853ccc639983823440"
      },
      {
        "transactionIndex": 205,
        "blockNumber": 14225827,
        "transactionHash": "0x26d2be3d2ab78cad3dccf4d5ae9a5a303c0e1173ae4969818bb76fcaa6f21d64",
        "address": "0x77a903733d36A8bAF751b00F376ca75201ab0D1d",
        "topics": [
          "0xa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b76389980198",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916",
          "0x000000000000000000000000cbb46b017e8d785c107e97c56135894b3ead599c"
        ],
        "data": "0x",
        "logIndex": 393,
        "blockHash": "0x94c0b3ab20bb2e9f02143984e57ce3b9395a0d0b82c1ab853ccc639983823440"
      }
    ],
    "blockNumber": 14225827,
    "cumulativeGasUsed": "23194348",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1594B6Fd7C346376E51C4Cf46525a9c57c5ea916",
    "0xcbb46b017e8d785C107e97c56135894b3eAD599C"
  ],
  "numDeployments": 1,
  "solcInputHash": "edd68036c391002ae2af5111886505d2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomFeePercent\",\"type\":\"uint256\"}],\"name\":\"CustomFeePercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomHarvestDelay\",\"type\":\"uint256\"}],\"name\":\"CustomHarvestDelayUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomHarvestWindow\",\"type\":\"uint256\"}],\"name\":\"CustomHarvestWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"CustomTargetFloatPercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDefaultFeePercent\",\"type\":\"uint256\"}],\"name\":\"DefaultFeePercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newDefaultHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"DefaultHarvestDelayUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newDefaultHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"DefaultHarvestWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDefaultTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"DefaultTargetFloatPercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultHarvestDelay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultHarvestWindow\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTargetFloatPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomHarvestDelay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomHarvestWindow\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomTargetFloatPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultFeePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newDefaultHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"setDefaultHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newDefaultHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"setDefaultHarvestWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultTargetFloatPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"customFeePercent\",\"type\":\"uint256\"}],\"name\":\"setVaultCustomFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"customHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"setVaultCustomHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"customHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"setVaultCustomHarvestWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"customTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"setVaultCustomTargetFloatPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncHarvestWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncTargetFloatPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Transmissions11 and JetJadeja\",\"events\":{\"CustomFeePercentUpdated(address,uint256)\":{\"params\":{\"newCustomFeePercent\":\"The new custom fee percentage for the Vault.\",\"vault\":\"The Vault that had its custom fee percentage set/updated.\"}},\"CustomHarvestDelayUpdated(address,uint256)\":{\"params\":{\"newCustomHarvestDelay\":\"The new custom harvest delay for the Vault.\",\"vault\":\"The Vault that had its custom harvest delay set/updated.\"}},\"CustomHarvestWindowUpdated(address,uint256)\":{\"params\":{\"newCustomHarvestWindow\":\"The new custom harvest window for the Vault.\",\"vault\":\"The Vault that had its custom harvest window set/updated.\"}},\"CustomTargetFloatPercentUpdated(address,uint256)\":{\"params\":{\"newCustomTargetFloatPercent\":\"The new custom target float percentage for the Vault.\",\"vault\":\"The Vault that had its custom target float percentage set/updated.\"}},\"DefaultFeePercentUpdated(uint256)\":{\"params\":{\"newDefaultFeePercent\":\"The new default fee percentage.\"}},\"DefaultHarvestDelayUpdated(uint64)\":{\"params\":{\"newDefaultHarvestDelay\":\"The new default harvest delay.\"}},\"DefaultHarvestWindowUpdated(uint128)\":{\"params\":{\"newDefaultHarvestWindow\":\"The new default harvest window.\"}},\"DefaultTargetFloatPercentUpdated(uint256)\":{\"params\":{\"newDefaultTargetFloatPercent\":\"The new default target float percentage.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_authority\":\"The Authority of the module.\",\"_owner\":\"The owner of the module.\"}},\"setDefaultFeePercent(uint256)\":{\"params\":{\"newDefaultFeePercent\":\"The new default fee percentage to set.\"}},\"setDefaultHarvestDelay(uint64)\":{\"params\":{\"newDefaultHarvestDelay\":\"The new default harvest delay to set.\"}},\"setDefaultHarvestWindow(uint128)\":{\"params\":{\"newDefaultHarvestWindow\":\"The new default harvest window to set.\"}},\"setDefaultTargetFloatPercent(uint256)\":{\"params\":{\"newDefaultTargetFloatPercent\":\"The new default target float percentage to set.\"}},\"setVaultCustomFeePercent(address,uint256)\":{\"params\":{\"customFeePercent\":\"The new custom fee percentage to set.\",\"vault\":\"The Vault to set the custom fee percentage for.\"}},\"setVaultCustomHarvestDelay(address,uint64)\":{\"params\":{\"customHarvestDelay\":\"The new custom harvest delay to set.\",\"vault\":\"The Vault to set the custom harvest delay for.\"}},\"setVaultCustomHarvestWindow(address,uint128)\":{\"params\":{\"customHarvestWindow\":\"The new custom harvest window to set.\",\"vault\":\"The Vault to set the custom harvest window for.\"}},\"setVaultCustomTargetFloatPercent(address,uint256)\":{\"params\":{\"customTargetFloatPercent\":\"The new custom target float percentage to set.\",\"vault\":\"The Vault to set the custom target float percentage for.\"}},\"syncFeePercent(address)\":{\"params\":{\"vault\":\"The Vault to sync the fee percentage for.\"}},\"syncHarvestDelay(address)\":{\"params\":{\"vault\":\"The Vault to sync the harvest delay for.\"}},\"syncHarvestWindow(address)\":{\"params\":{\"vault\":\"The Vault to sync the harvest window for.\"}},\"syncTargetFloatPercent(address)\":{\"params\":{\"vault\":\"The Vault to sync the target float percentage for.\"}}},\"stateVariables\":{\"defaultFeePercent\":{\"details\":\"See the documentation for the feePercentage variable in the Vault contract for more details.\"},\"defaultHarvestDelay\":{\"details\":\"See the documentation for the harvestDelay variable in the Vault contract for more details.\"},\"defaultHarvestWindow\":{\"details\":\"See the documentation for the harvestWindow variable in the Vault contract for more details.\"},\"defaultTargetFloatPercent\":{\"details\":\"See the documentation for the targetFloatPercent variable in the Vault contract for more details.\"},\"getVaultCustomFeePercent\":{\"details\":\"Will be 0 if there is no custom fee percentage for the Vault.See the documentation for the targetFloatPercent variable in the Vault contract for more details.\"},\"getVaultCustomHarvestDelay\":{\"details\":\"Will be 0 if there is no custom harvest delay for the Vault.See the documentation for the harvestDelay variable in the Vault contract for more details.\"},\"getVaultCustomHarvestWindow\":{\"details\":\"Will be 0 if there is no custom harvest window for the Vault.See the documentation for the harvestWindow variable in the Vault contract for more details.\"},\"getVaultCustomTargetFloatPercent\":{\"details\":\"Will be 0 if there is no custom target float percentage for the Vault.See the documentation for the targetFloatPercent variable in the Vault contract for more details.\"}},\"title\":\"Rari Vault Configuration Module\",\"version\":1},\"userdoc\":{\"events\":{\"CustomFeePercentUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom fee percentage set/updated.\"},\"CustomHarvestDelayUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom harvest delay set/updated.\"},\"CustomHarvestWindowUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom harvest window set/updated.\"},\"CustomTargetFloatPercentUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom target float percentage set/updated.\"},\"DefaultFeePercentUpdated(uint256)\":{\"notice\":\"Emitted when the default fee percentage is updated.\"},\"DefaultHarvestDelayUpdated(uint64)\":{\"notice\":\"Emitted when the default harvest delay is updated.\"},\"DefaultHarvestWindowUpdated(uint128)\":{\"notice\":\"Emitted when the default harvest window is updated.\"},\"DefaultTargetFloatPercentUpdated(uint256)\":{\"notice\":\"Emitted when the default target float percentage is updated.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Creates a Vault configuration module.\"},\"defaultFeePercent()\":{\"notice\":\"The default fee percentage for Vaults.\"},\"defaultHarvestDelay()\":{\"notice\":\"The default harvest delay for Vaults.\"},\"defaultHarvestWindow()\":{\"notice\":\"The default harvest window for Vaults.\"},\"defaultTargetFloatPercent()\":{\"notice\":\"The default target float percentage for Vaults.\"},\"getVaultCustomFeePercent(address)\":{\"notice\":\"Maps Vaults to their custom fee percentage.\"},\"getVaultCustomHarvestDelay(address)\":{\"notice\":\"Maps Vaults to their custom harvest delay.\"},\"getVaultCustomHarvestWindow(address)\":{\"notice\":\"Maps Vaults to their custom harvest window.\"},\"getVaultCustomTargetFloatPercent(address)\":{\"notice\":\"Maps Vaults to their custom target float percentage.\"},\"setDefaultFeePercent(uint256)\":{\"notice\":\"Sets the default fee percentage for Vaults.\"},\"setDefaultHarvestDelay(uint64)\":{\"notice\":\"Sets the default harvest delay for Vaults.\"},\"setDefaultHarvestWindow(uint128)\":{\"notice\":\"Sets the default harvest window for Vaults.\"},\"setDefaultTargetFloatPercent(uint256)\":{\"notice\":\"Sets the default target float percentage for Vaults.\"},\"setVaultCustomFeePercent(address,uint256)\":{\"notice\":\"Sets the custom fee percentage for the Vault.\"},\"setVaultCustomHarvestDelay(address,uint64)\":{\"notice\":\"Sets the custom harvest delay for the Vault.\"},\"setVaultCustomHarvestWindow(address,uint128)\":{\"notice\":\"Sets the custom harvest window for the Vault.\"},\"setVaultCustomTargetFloatPercent(address,uint256)\":{\"notice\":\"Sets the custom target float percentage for the Vault.\"},\"syncFeePercent(address)\":{\"notice\":\"Syncs a Vault's fee percentage with either the Vault's custom fee percentage or the default fee percentage if a custom percentage is not set.\"},\"syncHarvestDelay(address)\":{\"notice\":\"Syncs a Vault's harvest delay with either the Vault's custom harvest delay or the default harvest delay if a custom delay is not set.\"},\"syncHarvestWindow(address)\":{\"notice\":\"Syncs a Vault's harvest window with either the Vault's custom harvest window or the default harvest window if a custom window is not set.\"},\"syncTargetFloatPercent(address)\":{\"notice\":\"Syncs a Vault's target float percentage with either the Vault's custom target float percentage or the default target float percentage if a custom percentage is not set.\"}},\"notice\":\"Module for configuring Vault parameters.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"srcBuild/modules/VaultConfigurationModule.sol\":\"VaultConfigurationModule\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@rari-capital/solmate/src/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x45a3dedcffe229eb4393a1ac5233da3d332cddae4cf97fc44602614329c1f70a\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x698cdbf614109fafc2bf00057b60715fa3aba9dad447c42f4f8b749ae16ce84f\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/WETH.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\",\"keccak256\":\"0xd36c6fffd35b32b984b9130ce988fd7fc02f3b004fde160e583131212b0d655f\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x <= type(uint248).max);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x <= type(uint96).max);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x <= type(uint64).max);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max);\\n\\n        y = uint32(x);\\n    }\\n}\\n\",\"keccak256\":\"0x4d6a75e263a7366389540e0f9065923f50b7fb8f171f99163a81fe93e4cf24a9\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcc39d0f5693925ea1e8c517f7cc24211a9899c83a57e62d806180cdb056b6b75\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /* ///////////////////////////////////////////////////////////////\\n    SIMPLIFIED FIXED POINT OPERATIONS\\n    ////////////////////////////////////////////////////////////// */\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n        // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n        // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\\n                revert(0, 0)\\n            }\\n\\n        // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // First, divide z - 1 by the denominator and add 1.\\n        // Then multiply it by 0 if z is zero, or 1 otherwise.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                // 0 ** 0 = 1\\n                    z := denominator\\n                }\\n                default {\\n                // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                // If n is even, store denominator in z for now.\\n                    z := denominator\\n                }\\n                default {\\n                // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, denominator)\\n\\n                for {\\n                // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                // Revert immediately if x ** 2 would overflow.\\n                // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Set x to scaled xxRound.\\n                    x := div(xxRound, denominator)\\n\\n                // If n is even:\\n                    if mod(n, 2) {\\n                    // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                    // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                        // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                    // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                    // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                    // Return properly scaled zxRound.\\n                        z := div(zxRound, denominator)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n        // Start off with z at 1.\\n            z := 1\\n\\n        // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n        // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z)\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z)\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z)\\n            }\\n            if iszero(lt(y, 0x8)) {\\n            // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n        // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n        // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n        // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1484f097a7d98e687f22bf68cc3a58077230c075675c1d3b08439a2b402c0808\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {WETH} from \\\"@rari-capital/solmate/src/tokens/WETH.sol\\\";\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeCastLib} from \\\"@rari-capital/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./FixedPointMathLib.sol\\\"; //added fdiv and fmul TODO: looking at new rari/next code perhaps we're moving to a new library\\n\\nimport {Strategy, ERC20Strategy, ETHStrategy} from \\\"./interfaces/Strategy.sol\\\";\\n\\n/// @title Aphra Vault (avToken)\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Flexible, minimalist, and gas-optimized yield\\n/// aggregator for earning interest on any ERC20 token.\\n/// @notice changes from original are to rename Rari -> Aphra tokens and any usage of rvToken => avToken\\ncontract Vault is ERC20, Auth {\\n    using SafeCastLib for uint256;\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The maximum number of elements allowed on the withdrawal stack.\\n    /// @dev Needed to prevent denial of service attacks by queue operators.\\n    uint256 internal constant MAX_WITHDRAWAL_STACK_SIZE = 32;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                IMMUTABLES\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The underlying token the Vault accepts.\\n    ERC20 public immutable UNDERLYING;\\n\\n    /// @notice The base unit of the underlying token and hence avToken.\\n    /// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\\n    uint256 internal immutable BASE_UNIT;\\n\\n    /// @notice Creates a new Vault that accepts a specific underlying token.\\n    /// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\\n    constructor(ERC20 _UNDERLYING)\\n        ERC20(\\n            // ex: Rari Dai Stablecoin Vault\\n            string(abi.encodePacked(\\\"Aphra \\\", _UNDERLYING.name(), \\\" Vault\\\")),\\n            // ex: rvDAI\\n            string(abi.encodePacked(\\\"av\\\", _UNDERLYING.symbol())),\\n            // ex: 18\\n            _UNDERLYING.decimals()\\n        )\\n        Auth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\\n    {\\n        UNDERLYING = _UNDERLYING;\\n\\n        BASE_UNIT = 10**decimals;\\n\\n        // Prevent minting of avTokens until\\n        // the initialize function is called.\\n        totalSupply = type(uint256).max;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                           FEE CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The percentage of profit recognized each harvest to reserve as fees.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public feePercent;\\n\\n    /// @notice Emitted when the fee percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newFeePercent The new fee percentage.\\n    event FeePercentUpdated(address indexed user, uint256 newFeePercent);\\n\\n    /// @notice Sets a new fee percentage.\\n    /// @param newFeePercent The new fee percentage.\\n    function setFeePercent(uint256 newFeePercent) external requiresAuth {\\n        // A fee percentage over 100% doesn't make sense.\\n        require(newFeePercent <= 1e18, \\\"FEE_TOO_HIGH\\\");\\n\\n        // Update the fee percentage.\\n        feePercent = newFeePercent;\\n\\n        emit FeePercentUpdated(msg.sender, newFeePercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        HARVEST CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the harvest window is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestWindow The new harvest window.\\n    event HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\\n\\n    /// @notice Emitted when the harvest delay is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The new harvest delay.\\n    event HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The scheduled updated harvest delay.\\n    event HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice The period in seconds during which multiple harvests can occur\\n    /// regardless if they are taking place before the harvest delay has elapsed.\\n    /// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\\n    uint128 public harvestWindow;\\n\\n    /// @notice The period in seconds over which locked profit is unlocked.\\n    /// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\\n    uint64 public harvestDelay;\\n\\n    /// @notice The value that will replace harvestDelay next harvest.\\n    /// @dev In the case that the next delay is 0, no update will be applied.\\n    uint64 public nextHarvestDelay;\\n\\n    /// @notice Sets a new harvest window.\\n    /// @param newHarvestWindow The new harvest window.\\n    /// @dev The Vault's harvestDelay must already be set before calling.\\n    function setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\\n        // A harvest window longer than the harvest delay doesn't make sense.\\n        require(newHarvestWindow <= harvestDelay, \\\"WINDOW_TOO_LONG\\\");\\n\\n        // Update the harvest window.\\n        harvestWindow = newHarvestWindow;\\n\\n        emit HarvestWindowUpdated(msg.sender, newHarvestWindow);\\n    }\\n\\n    /// @notice Sets a new harvest delay.\\n    /// @param newHarvestDelay The new harvest delay to set.\\n    /// @dev If the current harvest delay is 0, meaning it has not\\n    /// been set before, it will be updated immediately, otherwise\\n    /// it will be scheduled to take effect after the next harvest.\\n    function setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\\n        // A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\\n        require(newHarvestDelay != 0, \\\"DELAY_CANNOT_BE_ZERO\\\");\\n\\n        // A harvest delay longer than 1 year doesn't make sense.\\n        require(newHarvestDelay <= 365 days, \\\"DELAY_TOO_LONG\\\");\\n\\n        // If the harvest delay is 0, meaning it has not been set before:\\n        if (harvestDelay == 0) {\\n            // We'll apply the update immediately.\\n            harvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        } else {\\n            // We'll apply the update next harvest.\\n            nextHarvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       TARGET FLOAT CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The desired percentage of the Vault's holdings to keep as float.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public targetFloatPercent;\\n\\n    /// @notice Emitted when the target float percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    event TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\\n\\n    /// @notice Set a new target float percentage.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    function setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\\n        // A target float percentage over 100% doesn't make sense.\\n        require(newTargetFloatPercent <= 1e18, \\\"TARGET_TOO_HIGH\\\");\\n\\n        // Update the target float percentage.\\n        targetFloatPercent = newTargetFloatPercent;\\n\\n        emit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                   UNDERLYING IS WETH CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Whether the Vault should treat the underlying token as WETH compatible.\\n    /// @dev If enabled the Vault will allow trusting strategies that accept Ether.\\n    bool public underlyingIsWETH;\\n\\n    /// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\\n    event UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\\n\\n    /// @notice Sets whether the Vault treats the underlying as WETH.\\n    /// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\\n    /// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\\n    function setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\\n        // Ensure the underlying token's decimals match ETH if is WETH being set to true.\\n        require(!newUnderlyingIsWETH || UNDERLYING.decimals() == 18, \\\"WRONG_DECIMALS\\\");\\n\\n        // Update whether the Vault treats the underlying as WETH.\\n        underlyingIsWETH = newUnderlyingIsWETH;\\n\\n        emit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          STRATEGY STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\\n    /// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\\n    uint256 public totalStrategyHoldings;\\n\\n    /// @dev Packed struct of strategy data.\\n    /// @param trusted Whether the strategy is trusted.\\n    /// @param balance The amount of underlying tokens held in the strategy.\\n    struct StrategyData {\\n        // Used to determine if the Vault will operate on a strategy.\\n        bool trusted;\\n        // Used to determine profit and loss during harvests of the strategy.\\n        uint248 balance;\\n    }\\n\\n    /// @notice Maps strategies to data the Vault holds on them.\\n    mapping(Strategy => StrategyData) public getStrategyData;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\\n    /// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\\n    uint64 public lastHarvestWindowStart;\\n\\n    /// @notice A timestamp representing when the most recent harvest occurred.\\n    uint64 public lastHarvest;\\n\\n    /// @notice The amount of locked profit at the end of the last harvest.\\n    uint128 public maxLockedProfit;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        WITHDRAWAL STACK STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice An ordered array of strategies representing the withdrawal stack.\\n    /// @dev The stack is processed in descending order, meaning the last index will be withdrawn from first.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\\n    /// withdrawal time, not validated upfront, meaning the stack may not reflect the \\\"true\\\" set used for withdrawals.\\n    Strategy[] public withdrawalStack;\\n\\n    /// @notice Gets the full withdrawal stack.\\n    /// @return An ordered array of strategies representing the withdrawal stack.\\n    /// @dev This is provided because Solidity converts public arrays into index getters,\\n    /// but we need a way to allow external contracts and users to access the whole array.\\n    function getWithdrawalStack() external view returns (Strategy[] memory) {\\n        return withdrawalStack;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful deposit.\\n    /// @param user The address that deposited into the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event Deposit(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after a successful withdrawal.\\n    /// @param user The address that withdrew from the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event Withdraw(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of the underlying token to deposit.\\n    function deposit(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and mint them.\\n        _mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Deposit(msg.sender, underlyingAmount);\\n\\n        // Transfer in underlying tokens from the user.\\n        // This will revert if the user does not have the amount specified.\\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of underlying tokens to withdraw.\\n    function withdraw(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and burn them.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @notice Redeem a specific amount of avTokens for underlying tokens.\\n    /// @param avTokenAmount The amount of avTokens to redeem for underlying tokens.\\n    function redeem(uint256 avTokenAmount) external {\\n        // Determine the equivalent amount of underlying tokens.\\n        uint256 underlyingAmount = avTokenAmount.fmul(exchangeRate(), BASE_UNIT);\\n\\n        // Burn the provided amount of avTokens.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, avTokenAmount);\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\\n    /// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\\n    /// @param recipient The user to transfer the underlying tokens to.\\n    /// @param underlyingAmount The amount of underlying tokens to transfer.\\n    function transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\\n        // Get the Vault's floating balance.\\n        uint256 float = totalFloat();\\n\\n        // If the amount is greater than the float, withdraw from strategies.\\n        if (underlyingAmount > float) {\\n            // Compute the amount needed to reach our target float percentage.\\n            uint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(targetFloatPercent, 1e18);\\n\\n            // Compute the bare minimum amount we need for this withdrawal.\\n            uint256 floatMissingForWithdrawal = underlyingAmount - float;\\n\\n            // Pull enough to cover the withdrawal and reach our target float percentage.\\n            pullFromWithdrawalStack(floatMissingForWithdrawal + floatMissingForTarget);\\n        }\\n\\n        // Transfer the provided amount of underlying tokens.\\n        UNDERLYING.safeTransfer(recipient, underlyingAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        VAULT ACCOUNTING LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Returns a user's Vault balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Vault balance in underlying tokens.\\n    function balanceOfUnderlying(address user) external view returns (uint256) {\\n        return balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens an avToken can be redeemed for.\\n    /// @return The amount of underlying tokens an avToken can be redeemed for.\\n    function exchangeRate() public view returns (uint256) {\\n        // Get the total supply of avTokens.\\n        uint256 avTokenSupply = totalSupply;\\n\\n        // If there are no avTokens in circulation, return an exchange rate of 1:1.\\n        if (avTokenSupply == 0) return BASE_UNIT;\\n\\n        // Calculate the exchange rate by dividing the total holdings by the avToken supply.\\n        return totalHoldings().fdiv(avTokenSupply, BASE_UNIT);\\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds.\\n    /// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\\n    function totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\\n        unchecked {\\n            // Cannot underflow as locked profit can't exceed total strategy holdings.\\n            totalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\\n        }\\n\\n        // Include our floating balance in the total.\\n        totalUnderlyingHeld += totalFloat();\\n    }\\n\\n    /// @notice Calculates the current amount of locked profit.\\n    /// @return The current amount of locked profit.\\n    function lockedProfit() public view returns (uint256) {\\n        // Get the last harvest and harvest delay.\\n        uint256 previousHarvest = lastHarvest;\\n        uint256 harvestInterval = harvestDelay;\\n\\n        unchecked {\\n            // If the harvest delay has passed, there is no locked profit.\\n            // Cannot overflow on human timescales since harvestInterval is capped.\\n            if (block.timestamp >= previousHarvest + harvestInterval) return 0;\\n\\n            // Get the maximum amount we could return.\\n            uint256 maximumLockedProfit = maxLockedProfit;\\n\\n            // Compute how much profit remains locked based on the last harvest and harvest delay.\\n            // It's impossible for the previous harvest to be in the future, so this will never underflow.\\n            return maximumLockedProfit - (maximumLockedProfit * (block.timestamp - previousHarvest)) / harvestInterval;\\n        }\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens that idly sit in the Vault.\\n    /// @return The amount of underlying tokens that sit idly in the Vault.\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful harvest.\\n    /// @param user The authorized user who triggered the harvest.\\n    /// @param strategies The trusted strategies that were harvested.\\n    event Harvest(address indexed user, Strategy[] strategies);\\n\\n    /// @notice Harvest a set of trusted strategies.\\n    /// @param strategies The trusted strategies to harvest.\\n    /// @dev Will always revert if called outside of an active\\n    /// harvest window or before the harvest delay has passed.\\n    function harvest(Strategy[] calldata strategies) external requiresAuth {\\n        // If this is the first harvest after the last window:\\n        if (block.timestamp >= lastHarvest + harvestDelay) {\\n            // Set the harvest window's start timestamp.\\n            // Cannot overflow 64 bits on human timescales.\\n            lastHarvestWindowStart = uint64(block.timestamp);\\n        } else {\\n            // We know this harvest is not the first in the window so we need to ensure it's within it.\\n            require(block.timestamp <= lastHarvestWindowStart + harvestWindow, \\\"BAD_HARVEST_TIME\\\");\\n        }\\n\\n        // Get the Vault's current total strategy holdings.\\n        uint256 oldTotalStrategyHoldings = totalStrategyHoldings;\\n\\n        // Used to store the total profit accrued by the strategies.\\n        uint256 totalProfitAccrued;\\n\\n        // Used to store the new total strategy holdings after harvesting.\\n        uint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\\n\\n        // Will revert if any of the specified strategies are untrusted.\\n        for (uint256 i = 0; i < strategies.length; i++) {\\n            // Get the strategy at the current index.\\n            Strategy strategy = strategies[i];\\n\\n            // If an untrusted strategy could be harvested a malicious user could use\\n            // a fake strategy that over-reports holdings to manipulate the exchange rate.\\n            require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n            // Get the strategy's previous and current balance.\\n            uint256 balanceLastHarvest = getStrategyData[strategy].balance;\\n            uint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\\n\\n            // Update the strategy's stored balance. Cast overflow is unrealistic.\\n            getStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\\n\\n            // Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\\n            // We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\\n            newTotalStrategyHoldings = newTotalStrategyHoldings + balanceThisHarvest - balanceLastHarvest;\\n\\n            unchecked {\\n                // Update the total profit accrued while counting losses as zero profit.\\n                // Cannot overflow as we already increased total holdings without reverting.\\n                totalProfitAccrued += balanceThisHarvest > balanceLastHarvest\\n                    ? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\\n                    : 0; // If the strategy registered a net loss we don't have any new profit.\\n            }\\n        }\\n\\n        // Compute fees as the fee percent multiplied by the profit.\\n        uint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\\n\\n        // If we accrued any fees, mint an equivalent amount of avTokens.\\n        // Authorized users can claim the newly minted avTokens via claimFees.\\n        _mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        // Update max unlocked profit based on any remaining locked profit plus new profit.\\n        maxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\\n\\n        // Set strategy holdings to our new total.\\n        totalStrategyHoldings = newTotalStrategyHoldings;\\n\\n        // Update the last harvest timestamp.\\n        // Cannot overflow on human timescales.\\n        lastHarvest = uint64(block.timestamp);\\n\\n        emit Harvest(msg.sender, strategies);\\n\\n        // Get the next harvest delay.\\n        uint64 newHarvestDelay = nextHarvestDelay;\\n\\n        // If the next harvest delay is not 0:\\n        if (newHarvestDelay != 0) {\\n            // Update the harvest delay.\\n            harvestDelay = newHarvestDelay;\\n\\n            // Reset the next harvest delay.\\n            nextHarvestDelay = 0;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    STRATEGY DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after the Vault deposits into a strategy contract.\\n    /// @param user The authorized user who triggered the deposit.\\n    /// @param strategy The strategy that was deposited into.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event StrategyDeposit(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after the Vault withdraws funds from a strategy contract.\\n    /// @param user The authorized user who triggered the withdrawal.\\n    /// @param strategy The strategy that was withdrawn from.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event StrategyWithdrawal(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of float into a trusted strategy.\\n    /// @param strategy The trusted strategy to deposit into.\\n    /// @param underlyingAmount The amount of underlying tokens in float to deposit.\\n    function depositIntoStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be deposited into.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Increase totalStrategyHoldings to account for the deposit.\\n        totalStrategyHoldings += underlyingAmount;\\n\\n        unchecked {\\n            // Without this the next harvest would count the deposit as profit.\\n            // Cannot overflow as the balance of one strategy can't exceed the sum of all.\\n            getStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\\n        }\\n\\n        emit StrategyDeposit(msg.sender, strategy, underlyingAmount);\\n\\n        // We need to deposit differently if the strategy takes ETH.\\n        if (strategy.isCEther()) {\\n            // Unwrap the right amount of WETH.\\n            WETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\\n\\n            // Deposit into the strategy and assume it will revert on error.\\n            ETHStrategy(address(strategy)).mint{value: underlyingAmount}();\\n        } else {\\n            // Approve underlyingAmount to the strategy so we can deposit.\\n            UNDERLYING.safeApprove(address(strategy), underlyingAmount);\\n\\n            // Deposit into the strategy and revert if it returns an error code.\\n            require(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \\\"MINT_FAILED\\\");\\n        }\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a strategy.\\n    /// @param strategy The strategy to withdraw from.\\n    /// @param underlyingAmount  The amount of underlying tokens to withdraw.\\n    /// @dev Withdrawing from a strategy will not remove it from the withdrawal stack.\\n    function withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be withdrawn from.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Without this the next harvest would count the withdrawal as a loss.\\n        getStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the withdrawal.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        emit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\\n\\n        // Withdraw from the strategy and revert if it returns an error code.\\n        require(strategy.redeemUnderlying(underlyingAmount) == 0, \\\"REDEEM_FAILED\\\");\\n\\n        // Wrap the withdrawn Ether into WETH if necessary.\\n        if (strategy.isCEther()) WETH(payable(address(UNDERLYING))).deposit{value: underlyingAmount}();\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                      STRATEGY TRUST/DISTRUST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is set to trusted.\\n    /// @param user The authorized user who trusted the strategy.\\n    /// @param strategy The strategy that became trusted.\\n    event StrategyTrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Emitted when a strategy is set to untrusted.\\n    /// @param user The authorized user who untrusted the strategy.\\n    /// @param strategy The strategy that became untrusted.\\n    event StrategyDistrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Stores a strategy as trusted, enabling it to be harvested.\\n    /// @param strategy The strategy to make trusted.\\n    function trustStrategy(Strategy strategy) external requiresAuth {\\n        // Ensure the strategy accepts the correct underlying token.\\n        // If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\\n        require(\\n            strategy.isCEther() ? underlyingIsWETH : ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\\n            \\\"WRONG_UNDERLYING\\\"\\n        );\\n\\n        // Store the strategy as trusted.\\n        getStrategyData[strategy].trusted = true;\\n\\n        emit StrategyTrusted(msg.sender, strategy);\\n    }\\n\\n    /// @notice Stores a strategy as untrusted, disabling it from being harvested.\\n    /// @param strategy The strategy to make untrusted.\\n    function distrustStrategy(Strategy strategy) external requiresAuth {\\n        // Store the strategy as untrusted.\\n        getStrategyData[strategy].trusted = false;\\n\\n        emit StrategyDistrusted(msg.sender, strategy);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         WITHDRAWAL STACK LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is pushed to the withdrawal stack.\\n    /// @param user The authorized user who triggered the push.\\n    /// @param pushedStrategy The strategy pushed to the withdrawal stack.\\n    event WithdrawalStackPushed(address indexed user, Strategy indexed pushedStrategy);\\n\\n    /// @notice Emitted when a strategy is popped from the withdrawal stack.\\n    /// @param user The authorized user who triggered the pop.\\n    /// @param poppedStrategy The strategy popped from the withdrawal stack.\\n    event WithdrawalStackPopped(address indexed user, Strategy indexed poppedStrategy);\\n\\n    /// @notice Emitted when the withdrawal stack is updated.\\n    /// @param user The authorized user who triggered the set.\\n    /// @param replacedWithdrawalStack The new withdrawal stack.\\n    event WithdrawalStackSet(address indexed user, Strategy[] replacedWithdrawalStack);\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack that was replaced.\\n    /// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\\n    event WithdrawalStackIndexReplaced(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed replacementStrategy\\n    );\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced with the tip.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack replaced by the tip.\\n    /// @param previousTipStrategy The previous tip of the stack that replaced the strategy.\\n    event WithdrawalStackIndexReplacedWithTip(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed previousTipStrategy\\n    );\\n\\n    /// @notice Emitted when the strategies at two indexes are swapped.\\n    /// @param user The authorized user who triggered the swap.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    /// @param newStrategy1 The strategy (previously at index2) that replaced index1.\\n    /// @param newStrategy2 The strategy (previously at index1) that replaced index2.\\n    event WithdrawalStackIndexesSwapped(\\n        address indexed user,\\n        uint256 index1,\\n        uint256 index2,\\n        Strategy indexed newStrategy1,\\n        Strategy indexed newStrategy2\\n    );\\n\\n    /// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal stack.\\n    /// @param underlyingAmount The amount of underlying tokens to pull into float.\\n    /// @dev Automatically removes depleted strategies from the withdrawal stack.\\n    function pullFromWithdrawalStack(uint256 underlyingAmount) internal {\\n        // We will update this variable as we pull from strategies.\\n        uint256 amountLeftToPull = underlyingAmount;\\n\\n        // We'll start at the tip of the stack and traverse backwards.\\n        uint256 currentIndex = withdrawalStack.length - 1;\\n\\n        // Iterate in reverse so we pull from the stack in a \\\"last in, first out\\\" manner.\\n        // Will revert due to underflow if we empty the stack before pulling the desired amount.\\n        for (; ; currentIndex--) {\\n            // Get the strategy at the current stack index.\\n            Strategy strategy = withdrawalStack[currentIndex];\\n\\n            // Get the balance of the strategy before we withdraw from it.\\n            uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n            // If the strategy is currently untrusted or was already depleted:\\n            if (!getStrategyData[strategy].trusted || strategyBalance == 0) {\\n                // Remove it from the stack.\\n                withdrawalStack.pop();\\n\\n                emit WithdrawalStackPopped(msg.sender, strategy);\\n\\n                // Move onto the next strategy.\\n                continue;\\n            }\\n\\n            // We want to pull as much as we can from the strategy, but no more than we need.\\n            uint256 amountToPull = strategyBalance > amountLeftToPull ? amountLeftToPull : strategyBalance;\\n\\n            unchecked {\\n                // Compute the balance of the strategy that will remain after we withdraw.\\n                // Cannot underflow as we cap the amount to pull at the strategy's balance.\\n                uint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\\n\\n                // Without this the next harvest would count the withdrawal as a loss.\\n                getStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\\n\\n                // Adjust our goal based on how much we can pull from the strategy.\\n                // Cannot underflow as we cap the amount to pull at the amount left to pull.\\n                amountLeftToPull -= amountToPull;\\n\\n                emit StrategyWithdrawal(msg.sender, strategy, amountToPull);\\n\\n                // Withdraw from the strategy and revert if returns an error code.\\n                require(strategy.redeemUnderlying(amountToPull) == 0, \\\"REDEEM_FAILED\\\");\\n\\n                // If we fully depleted the strategy:\\n                if (strategyBalanceAfterWithdrawal == 0) {\\n                    // Remove it from the stack.\\n                    withdrawalStack.pop();\\n\\n                    emit WithdrawalStackPopped(msg.sender, strategy);\\n                }\\n            }\\n\\n            // If we've pulled all we need, exit the loop.\\n            if (amountLeftToPull == 0) break;\\n        }\\n\\n        unchecked {\\n            // Account for the withdrawals done in the loop above.\\n            // Cannot underflow as the balances of some strategies cannot exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        // Cache the Vault's balance of ETH.\\n        uint256 ethBalance = address(this).balance;\\n\\n        // If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\\n        if (ethBalance != 0 && underlyingIsWETH) WETH(payable(address(UNDERLYING))).deposit{value: ethBalance}();\\n    }\\n\\n    /// @notice Pushes a single strategy to front of the withdrawal stack.\\n    /// @param strategy The strategy to be inserted at the front of the withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function pushToWithdrawalStack(Strategy strategy) external requiresAuth {\\n        // Ensure pushing the strategy will not cause the stack exceed its limit.\\n        require(withdrawalStack.length < MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_FULL\\\");\\n\\n        // Push the strategy to the front of the stack.\\n        withdrawalStack.push(strategy);\\n\\n        emit WithdrawalStackPushed(msg.sender, strategy);\\n    }\\n\\n    /// @notice Removes the strategy at the tip of the withdrawal stack.\\n    /// @dev Be careful, another authorized user could push a different strategy\\n    /// than expected to the stack while a popFromWithdrawalStack transaction is pending.\\n    function popFromWithdrawalStack() external requiresAuth {\\n        // Get the (soon to be) popped strategy.\\n        Strategy poppedStrategy = withdrawalStack[withdrawalStack.length - 1];\\n\\n        // Pop the first strategy in the stack.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackPopped(msg.sender, poppedStrategy);\\n    }\\n\\n    /// @notice Sets a new withdrawal stack.\\n    /// @param newStack The new withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function setWithdrawalStack(Strategy[] calldata newStack) external requiresAuth {\\n        // Ensure the new stack is not larger than the maximum stack size.\\n        require(newStack.length <= MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_TOO_BIG\\\");\\n\\n        // Replace the withdrawal stack.\\n        withdrawalStack = newStack;\\n\\n        emit WithdrawalStackSet(msg.sender, newStack);\\n    }\\n\\n    /// @notice Replaces an index in the withdrawal stack with another strategy.\\n    /// @param index The index in the stack to replace.\\n    /// @param replacementStrategy The strategy to override the index with.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function replaceWithdrawalStackIndex(uint256 index, Strategy replacementStrategy) external requiresAuth {\\n        // Get the (soon to be) replaced strategy.\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Update the index with the replacement strategy.\\n        withdrawalStack[index] = replacementStrategy;\\n\\n        emit WithdrawalStackIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\\n    }\\n\\n    /// @notice Moves the strategy at the tip of the stack to the specified index and pop the tip off the stack.\\n    /// @param index The index of the strategy in the withdrawal stack to replace with the tip.\\n    function replaceWithdrawalStackIndexWithTip(uint256 index) external requiresAuth {\\n        // Get the (soon to be) previous tip and strategy we will replace at the index.\\n        Strategy previousTipStrategy = withdrawalStack[withdrawalStack.length - 1];\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Replace the index specified with the tip of the stack.\\n        withdrawalStack[index] = previousTipStrategy;\\n\\n        // Remove the now duplicated tip from the array.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackIndexReplacedWithTip(msg.sender, index, replacedStrategy, previousTipStrategy);\\n    }\\n\\n    /// @notice Swaps two indexes in the withdrawal stack.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    function swapWithdrawalStackIndexes(uint256 index1, uint256 index2) external requiresAuth {\\n        // Get the (soon to be) new strategies at each index.\\n        Strategy newStrategy2 = withdrawalStack[index1];\\n        Strategy newStrategy1 = withdrawalStack[index2];\\n\\n        // Swap the strategies at both indexes.\\n        withdrawalStack[index1] = newStrategy1;\\n        withdrawalStack[index2] = newStrategy2;\\n\\n        emit WithdrawalStackIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         SEIZE STRATEGY LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a strategy is seized.\\n    /// @param user The authorized user who triggered the seize.\\n    /// @param strategy The strategy that was seized.\\n    event StrategySeized(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Seizes a strategy.\\n    /// @param strategy The strategy to seize.\\n    /// @dev Intended for use in emergencies or other extraneous situations where the\\n    /// strategy requires interaction outside of the Vault's standard operating procedures.\\n    function seizeStrategy(Strategy strategy) external requiresAuth {\\n        // Get the strategy's last reported balance of underlying tokens.\\n        uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n        // If the strategy's balance exceeds the Vault's current\\n        // holdings, instantly unlock any remaining locked profit.\\n        if (strategyBalance > totalHoldings()) maxLockedProfit = 0;\\n\\n        // Set the strategy's balance to 0.\\n        getStrategyData[strategy].balance = 0;\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the seize.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= strategyBalance;\\n        }\\n\\n        emit StrategySeized(msg.sender, strategy);\\n\\n        // Transfer all of the strategy's tokens to the caller.\\n        ERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             FEE CLAIM LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after fees are claimed.\\n    /// @param user The authorized user who claimed the fees.\\n    /// @param avTokenAmount The amount of avTokens that were claimed.\\n    event FeesClaimed(address indexed user, uint256 avTokenAmount);\\n\\n    /// @notice Claims fees accrued from harvests.\\n    /// @param avTokenAmount The amount of avTokens to claim.\\n    /// @dev Accrued fees are measured as avTokens held by the Vault.\\n    function claimFees(uint256 avTokenAmount) external requiresAuth {\\n        emit FeesClaimed(msg.sender, avTokenAmount);\\n\\n        // Transfer the provided amount of avTokens to the caller.\\n        ERC20(this).safeTransfer(msg.sender, avTokenAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    INITIALIZATION AND DESTRUCTION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the Vault is initialized.\\n    /// @param user The authorized user who triggered the initialization.\\n    event Initialized(address indexed user);\\n\\n    /// @notice Whether the Vault has been initialized yet.\\n    /// @dev Can go from false to true, never from true to false.\\n    bool public isInitialized;\\n\\n    /// @notice Initializes the Vault, enabling it to receive deposits.\\n    /// @dev All critical parameters must already be set before calling.\\n    function initialize() external requiresAuth {\\n        // Ensure the Vault has not already been initialized.\\n        require(!isInitialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n        // Mark the Vault as initialized.\\n        isInitialized = true;\\n\\n        // Open for deposits.\\n        totalSupply = 0;\\n\\n        emit Initialized(msg.sender);\\n    }\\n\\n    /// @notice Self destructs a Vault, enabling it to be redeployed.\\n    /// @dev Caller will receive any ETH held as float in the Vault.\\n    function destroy() external requiresAuth {\\n        selfdestruct(payable(msg.sender));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          RECIEVE ETHER LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Required for the Vault to receive unwrapped ETH.\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xbbd3589ad8bcb0b094113b4952cc967e68d6843ce35b380c51d6b4a208db9823\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/interfaces/Strategy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\n/// @dev Designed for out of the box compatibility with Fuse cTokens.\\n/// @dev Like cTokens, strategies must be transferrable ERC20s.\\nabstract contract Strategy is ERC20 {\\n    /// @notice Returns whether the strategy accepts ETH or an ERC20.\\n    /// @return True if the strategy accepts ETH, false otherwise.\\n    /// @dev Only present in Fuse cTokens, not Compound cTokens.\\n    function isCEther() external view virtual returns (bool);\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the strategy.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external virtual returns (uint256);\\n\\n    /// @notice Returns a user's strategy balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's strategy balance in underlying tokens.\\n    /// @dev May mutate the state of the strategy by accruing interest.\\n    function balanceOfUnderlying(address user) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\\n/// @dev Designed for out of the box compatibility with Fuse cERC20s.\\nabstract contract ERC20Strategy is Strategy {\\n    /// @notice Returns the underlying ERC20 token the strategy accepts.\\n    /// @return The underlying ERC20 token the strategy accepts.\\n    function underlying() external view virtual returns (ERC20);\\n\\n    /// @notice Deposit a specific amount of underlying tokens into the strategy.\\n    /// @param amount The amount of underlying tokens to deposit.\\n    /// @return An error code, or 0 if the deposit was successful.\\n    function mint(uint256 amount) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ETH.\\n/// @dev Designed for out of the box compatibility with Fuse cEther.\\nabstract contract ETHStrategy is Strategy {\\n    /// @notice Deposit a specific amount of ETH into the strategy.\\n    /// @dev The amount of ETH is specified via msg.value. Reverts on error.\\n    function mint() external payable virtual;\\n}\\n\",\"keccak256\":\"0x74641e7bf81f3a8ebbe797d58fd5e7db325ba9999a4e905a2e61f68614dfb50d\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/modules/VaultConfigurationModule.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nimport {Vault} from \\\"../Vault.sol\\\";\\n\\n/// @title Rari Vault Configuration Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for configuring Vault parameters.\\ncontract VaultConfigurationModule is Auth {\\n    /* //////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Creates a Vault configuration module.\\n    /// @param _owner The owner of the module.\\n    /// @param _authority The Authority of the module.\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  DEFAULT VAULT PARAMETER CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the default fee percentage is updated.\\n    /// @param newDefaultFeePercent The new default fee percentage.\\n    event DefaultFeePercentUpdated(uint256 newDefaultFeePercent);\\n\\n    /// @notice Emitted when the default harvest delay is updated.\\n    /// @param newDefaultHarvestDelay The new default harvest delay.\\n    event DefaultHarvestDelayUpdated(uint64 newDefaultHarvestDelay);\\n\\n    /// @notice Emitted when the default harvest window is updated.\\n    /// @param newDefaultHarvestWindow The new default harvest window.\\n    event DefaultHarvestWindowUpdated(uint128 newDefaultHarvestWindow);\\n\\n    /// @notice Emitted when the default target float percentage is updated.\\n    /// @param newDefaultTargetFloatPercent The new default target float percentage.\\n    event DefaultTargetFloatPercentUpdated(uint256 newDefaultTargetFloatPercent);\\n\\n    /// @notice The default fee percentage for Vaults.\\n    /// @dev See the documentation for the feePercentage\\n    /// variable in the Vault contract for more details.\\n    uint256 public defaultFeePercent;\\n\\n    /// @notice The default harvest delay for Vaults.\\n    /// @dev See the documentation for the harvestDelay\\n    /// variable in the Vault contract for more details.\\n    uint64 public defaultHarvestDelay;\\n\\n    /// @notice The default harvest window for Vaults.\\n    /// @dev See the documentation for the harvestWindow\\n    /// variable in the Vault contract for more details.\\n    uint128 public defaultHarvestWindow;\\n\\n    /// @notice The default target float percentage for Vaults.\\n    /// @dev See the documentation for the targetFloatPercent\\n    /// variable in the Vault contract for more details.\\n    uint256 public defaultTargetFloatPercent;\\n\\n    /// @notice Sets the default fee percentage for Vaults.\\n    /// @param newDefaultFeePercent The new default fee percentage to set.\\n    function setDefaultFeePercent(uint256 newDefaultFeePercent) external requiresAuth {\\n        // Update the default fee percentage.\\n        defaultFeePercent = newDefaultFeePercent;\\n\\n        emit DefaultFeePercentUpdated(newDefaultFeePercent);\\n    }\\n\\n    /// @notice Sets the default harvest delay for Vaults.\\n    /// @param newDefaultHarvestDelay The new default harvest delay to set.\\n    function setDefaultHarvestDelay(uint64 newDefaultHarvestDelay) external requiresAuth {\\n        // Update the default harvest delay.\\n        defaultHarvestDelay = newDefaultHarvestDelay;\\n\\n        emit DefaultHarvestDelayUpdated(newDefaultHarvestDelay);\\n    }\\n\\n    /// @notice Sets the default harvest window for Vaults.\\n    /// @param newDefaultHarvestWindow The new default harvest window to set.\\n    function setDefaultHarvestWindow(uint128 newDefaultHarvestWindow) external requiresAuth {\\n        // Update the default harvest window.\\n        defaultHarvestWindow = newDefaultHarvestWindow;\\n\\n        emit DefaultHarvestWindowUpdated(newDefaultHarvestWindow);\\n    }\\n\\n    /// @notice Sets the default target float percentage for Vaults.\\n    /// @param newDefaultTargetFloatPercent The new default target float percentage to set.\\n    function setDefaultTargetFloatPercent(uint256 newDefaultTargetFloatPercent) external requiresAuth {\\n        // Update the default target float percentage.\\n        defaultTargetFloatPercent = newDefaultTargetFloatPercent;\\n\\n        emit DefaultTargetFloatPercentUpdated(newDefaultTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  CUSTOM VAULT PARAMETER CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a Vault has its custom fee percentage set/updated.\\n    /// @param vault The Vault that had its custom fee percentage set/updated.\\n    /// @param newCustomFeePercent The new custom fee percentage for the Vault.\\n    event CustomFeePercentUpdated(Vault indexed vault, uint256 newCustomFeePercent);\\n\\n    /// @notice Emitted when a Vault has its custom harvest delay set/updated.\\n    /// @param vault The Vault that had its custom harvest delay set/updated.\\n    /// @param newCustomHarvestDelay The new custom harvest delay for the Vault.\\n    event CustomHarvestDelayUpdated(Vault indexed vault, uint256 newCustomHarvestDelay);\\n\\n    /// @notice Emitted when a Vault has its custom harvest window set/updated.\\n    /// @param vault The Vault that had its custom harvest window set/updated.\\n    /// @param newCustomHarvestWindow The new custom harvest window for the Vault.\\n    event CustomHarvestWindowUpdated(Vault indexed vault, uint256 newCustomHarvestWindow);\\n\\n    /// @notice Emitted when a Vault has its custom target float percentage set/updated.\\n    /// @param vault The Vault that had its custom target float percentage set/updated.\\n    /// @param newCustomTargetFloatPercent The new custom target float percentage for the Vault.\\n    event CustomTargetFloatPercentUpdated(Vault indexed vault, uint256 newCustomTargetFloatPercent);\\n\\n    /// @notice Maps Vaults to their custom fee percentage.\\n    /// @dev Will be 0 if there is no custom fee percentage for the Vault.\\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\\n    mapping(Vault => uint256) public getVaultCustomFeePercent;\\n\\n    /// @notice Maps Vaults to their custom harvest delay.\\n    /// @dev Will be 0 if there is no custom harvest delay for the Vault.\\n    /// @dev See the documentation for the harvestDelay variable in the Vault contract for more details.\\n    mapping(Vault => uint64) public getVaultCustomHarvestDelay;\\n\\n    /// @notice Maps Vaults to their custom harvest window.\\n    /// @dev Will be 0 if there is no custom harvest window for the Vault.\\n    /// @dev See the documentation for the harvestWindow variable in the Vault contract for more details.\\n    mapping(Vault => uint128) public getVaultCustomHarvestWindow;\\n\\n    /// @notice Maps Vaults to their custom target float percentage.\\n    /// @dev Will be 0 if there is no custom target float percentage for the Vault.\\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\\n    mapping(Vault => uint256) public getVaultCustomTargetFloatPercent;\\n\\n    /// @notice Sets the custom fee percentage for the Vault.\\n    /// @param vault The Vault to set the custom fee percentage for.\\n    /// @param customFeePercent The new custom fee percentage to set.\\n    function setVaultCustomFeePercent(Vault vault, uint256 customFeePercent) external requiresAuth {\\n        // Update the Vault's custom fee percentage.\\n        getVaultCustomFeePercent[vault] = customFeePercent;\\n\\n        emit CustomFeePercentUpdated(vault, customFeePercent);\\n    }\\n\\n    /// @notice Sets the custom harvest delay for the Vault.\\n    /// @param vault The Vault to set the custom harvest delay for.\\n    /// @param customHarvestDelay The new custom harvest delay to set.\\n    function setVaultCustomHarvestDelay(Vault vault, uint64 customHarvestDelay) external requiresAuth {\\n        // Update the Vault's custom harvest delay.\\n        getVaultCustomHarvestDelay[vault] = customHarvestDelay;\\n\\n        emit CustomHarvestDelayUpdated(vault, customHarvestDelay);\\n    }\\n\\n    /// @notice Sets the custom harvest window for the Vault.\\n    /// @param vault The Vault to set the custom harvest window for.\\n    /// @param customHarvestWindow The new custom harvest window to set.\\n    function setVaultCustomHarvestWindow(Vault vault, uint128 customHarvestWindow) external requiresAuth {\\n        // Update the Vault's custom harvest window.\\n        getVaultCustomHarvestWindow[vault] = customHarvestWindow;\\n\\n        emit CustomHarvestWindowUpdated(vault, customHarvestWindow);\\n    }\\n\\n    /// @notice Sets the custom target float percentage for the Vault.\\n    /// @param vault The Vault to set the custom target float percentage for.\\n    /// @param customTargetFloatPercent The new custom target float percentage to set.\\n    function setVaultCustomTargetFloatPercent(Vault vault, uint256 customTargetFloatPercent) external requiresAuth {\\n        // Update the Vault's custom target float percentage.\\n        getVaultCustomTargetFloatPercent[vault] = customTargetFloatPercent;\\n\\n        emit CustomTargetFloatPercentUpdated(vault, customTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       VAULT PARAMETER SYNC LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Syncs a Vault's fee percentage with either the Vault's custom fee\\n    /// percentage or the default fee percentage if a custom percentage is not set.\\n    /// @param vault The Vault to sync the fee percentage for.\\n    function syncFeePercent(Vault vault) external {\\n        // Get the Vault's custom fee percentage.\\n        uint256 customFeePercent = getVaultCustomFeePercent[vault];\\n\\n        // Determine what the new fee percentage should be for the Vault after the sync.\\n        uint256 newFeePercent = customFeePercent == 0 ? defaultFeePercent : customFeePercent;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.feePercent() != newFeePercent, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's fee percentage to the custom fee percentage\\n        // or the default fee percentage if a custom percentage isn't set.\\n        vault.setFeePercent(newFeePercent);\\n    }\\n\\n    /// @notice Syncs a Vault's harvest delay with either the Vault's custom\\n    /// harvest delay or the default harvest delay if a custom delay is not set.\\n    /// @param vault The Vault to sync the harvest delay for.\\n    function syncHarvestDelay(Vault vault) external {\\n        // Get the Vault's custom harvest delay.\\n        uint64 customHarvestDelay = getVaultCustomHarvestDelay[vault];\\n\\n        // Determine what the new harvest delay should be for the Vault after the sync.\\n        uint64 newHarvestDelay = customHarvestDelay == 0 ? defaultHarvestDelay : customHarvestDelay;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.harvestDelay() != newHarvestDelay, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's harvest delay to the custom harvest delay\\n        // or the default harvest delay if a custom delay isn't set.\\n        vault.setHarvestDelay(newHarvestDelay);\\n    }\\n\\n    /// @notice Syncs a Vault's harvest window with either the Vault's custom\\n    /// harvest window or the default harvest window if a custom window is not set.\\n    /// @param vault The Vault to sync the harvest window for.\\n    function syncHarvestWindow(Vault vault) external {\\n        // Get the Vault's custom harvest window.\\n        uint128 customHarvestWindow = getVaultCustomHarvestWindow[vault];\\n\\n        // Determine what the new harvest window should be for the Vault after the sync.\\n        uint128 newHarvestWindow = customHarvestWindow == 0 ? defaultHarvestWindow : customHarvestWindow;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.harvestWindow() != newHarvestWindow, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's harvest window to the custom harvest window\\n        // or the default harvest window if a custom window isn't set.\\n        vault.setHarvestWindow(newHarvestWindow);\\n    }\\n\\n    /// @notice Syncs a Vault's target float percentage with either the Vault's custom target\\n    /// float percentage or the default target float percentage if a custom percentage is not set.\\n    /// @param vault The Vault to sync the target float percentage for.\\n    function syncTargetFloatPercent(Vault vault) external {\\n        // Get the Vault's custom target float percentage.\\n        uint256 customTargetFloatPercent = getVaultCustomTargetFloatPercent[vault];\\n\\n        // Determine what the new target float percentage should be for the Vault after the sync.\\n        uint256 newTargetFloatPercent = customTargetFloatPercent == 0\\n            ? defaultTargetFloatPercent\\n            : customTargetFloatPercent;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.targetFloatPercent() != newTargetFloatPercent, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's target float percentage to the custom target float percentage\\n        // or the default target float percentage if a custom percentage isn't set.\\n        vault.setTargetFloatPercent(newTargetFloatPercent);\\n    }\\n}\\n\",\"keccak256\":\"0xf4c566c5314432bd38f1932cfbfccd576e61ec6b26195b495368e33ea016cfc8\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506040516111a83803806111a883398101604081905261002f916100e1565b600080546001600160a01b03199081166001600160a01b0385811691821784556001805490931690851617909155604051849284929133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d7691a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a35050505061011b565b6001600160a01b03811681146100de57600080fd5b50565b600080604083850312156100f457600080fd5b82516100ff816100c9565b6020840151909250610110816100c9565b809150509250929050565b61107e8061012a6000396000f3fe608060405234801561001057600080fd5b50600436106101585760003560e01c80637a9e5e4b116100c3578063bc3e38fa1161007c578063bc3e38fa14610355578063bf7e214f14610368578063c9b639d21461037b578063dd55002d1461038f578063e7926d5c146103a2578063e7d9934b146103ab57600080fd5b80637a9e5e4b146102c45780638da5cb5b146102d7578063ac345d0314610302578063af54da9114610315578063b5ef8b1e14610328578063b7c392c81461034257600080fd5b80634022d941116101155780634022d941146102085780634ce908f41461021b5780635607702f1461022e5780635fad65b0146102415780636eae9513146102615780636f8409321461028157600080fd5b806305d7282c1461015d57806313af4035146101725780632487bbff14610185578063261d26b6146101cb5780632b4b2753146101e25780633295ce96146101f5575b600080fd5b61017061016b366004610e23565b6103be565b005b610170610180366004610e4f565b610452565b6101ae610193366004610e4f565b6007602052600090815260409020546001600160801b031681565b6040516001600160801b0390911681526020015b60405180910390f35b6101d460045481565b6040519081526020016101c2565b6101706101f0366004610e73565b6104cf565b610170610203366004610ea1565b61053d565b610170610216366004610ed4565b6105d7565b610170610229366004610ef1565b610659565b61017061023c366004610e4f565b6106f9565b6101d461024f366004610e4f565b60086020526000908152604090205481565b6101d461026f366004610e4f565b60056020526000908152604090205481565b6102ab61028f366004610e4f565b60066020526000908152604090205467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020016101c2565b6101706102d2366004610e4f565b610837565b6000546102ea906001600160a01b031681565b6040516001600160a01b0390911681526020016101c2565b610170610310366004610e4f565b610921565b610170610323366004610f2a565b6109fb565b6003546101ae90600160401b90046001600160801b031681565b610170610350366004610e4f565b610a94565b610170610363366004610e23565b610b6e565b6001546102ea906001600160a01b031681565b6003546102ab9067ffffffffffffffff1681565b61017061039d366004610e73565b610bed565b6101d460025481565b6101706103b9366004610e4f565b610c54565b6103d4336000356001600160e01b031916610d61565b6103f95760405162461bcd60e51b81526004016103f090610f58565b60405180910390fd5b6001600160a01b03821660008181526008602052604090819020839055517fd710c46434b3517342d3119bd7db2b06b533042ad40997249339dc52a84ef87c906104469084815260200190565b60405180910390a25050565b610468336000356001600160e01b031916610d61565b6104845760405162461bcd60e51b81526004016103f090610f58565b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6104e5336000356001600160e01b031916610d61565b6105015760405162461bcd60e51b81526004016103f090610f58565b60048190556040518181527ff6ac39ac7a3a4a8e0820f1f0db868216520c8194410993c9a4256df18f2c1648906020015b60405180910390a150565b610553336000356001600160e01b031916610d61565b61056f5760405162461bcd60e51b81526004016103f090610f58565b6003805477ffffffffffffffffffffffffffffffff00000000000000001916600160401b6001600160801b038416908102919091179091556040519081527f54707f3cc4f1f275c1ca6cc5ea22b131da3e4e3187055769a011b8bfa3fe7e2c90602001610532565b6105ed336000356001600160e01b031916610d61565b6106095760405162461bcd60e51b81526004016103f090610f58565b6003805467ffffffffffffffff191667ffffffffffffffff83169081179091556040519081527fd49755c36f0046593fc57349146d19a3d849086b9f6f07f5262bbe51338dd02090602001610532565b61066f336000356001600160e01b031916610d61565b61068b5760405162461bcd60e51b81526004016103f090610f58565b6001600160a01b03821660008181526007602090815260409182902080546fffffffffffffffffffffffffffffffff19166001600160801b03861690811790915591519182527f020f4b532e50c21e70f84cf5b279d8b67380fe88a156bc883d11cbd3c90646089101610446565b6001600160a01b03811660009081526006602052604081205467ffffffffffffffff169081156107295781610737565b60035467ffffffffffffffff165b90508067ffffffffffffffff16836001600160a01b031663448f56b96040518163ffffffff1660e01b8152600401602060405180830381865afa158015610782573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a69190610f7e565b67ffffffffffffffff1614156107ce5760405162461bcd60e51b81526004016103f090610f9b565b604051637b72aeb960e01b815267ffffffffffffffff821660048201526001600160a01b03841690637b72aeb9906024015b600060405180830381600087803b15801561081a57600080fd5b505af115801561082e573d6000803e3d6000fd5b50505050505050565b6000546001600160a01b03163314806108cc575060015460405163b700961360e01b81526001600160a01b039091169063b70096139061088b90339030906001600160e01b03196000351690600401610fc3565b602060405180830381865afa1580156108a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108cc9190610ff0565b6108d557600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6001600160a01b038116600090815260086020526040812054908115610947578161094b565b6004545b905080836001600160a01b0316631c6934786040518163ffffffff1660e01b8152600401602060405180830381865afa15801561098c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b09190611012565b14156109ce5760405162461bcd60e51b81526004016103f090610f9b565b6040516317acc5f160e31b8152600481018290526001600160a01b0384169063bd662f8890602401610800565b610a11336000356001600160e01b031916610d61565b610a2d5760405162461bcd60e51b81526004016103f090610f58565b6001600160a01b038216600081815260066020908152604091829020805467ffffffffffffffff191667ffffffffffffffff861690811790915591519182527f0d239ace1084ebc7a2681e317ee23b0ddccdfb63175585667a8cf7d6771aa36e9101610446565b6001600160a01b038116600090815260056020526040812054908115610aba5781610abe565b6002545b905080836001600160a01b0316637fd6f15c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610aff573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b239190611012565b1415610b415760405162461bcd60e51b81526004016103f090610f9b565b604051637ce3489b60e01b8152600481018290526001600160a01b03841690637ce3489b90602401610800565b610b84336000356001600160e01b031916610d61565b610ba05760405162461bcd60e51b81526004016103f090610f58565b6001600160a01b03821660008181526005602052604090819020839055517f1d66532ea81d485f8eedbb61c45181fc69b2cbf6f5b05f741b0d3d54d80f9ea9906104469084815260200190565b610c03336000356001600160e01b031916610d61565b610c1f5760405162461bcd60e51b81526004016103f090610f58565b60028190556040518181527f1ba0c7196822b2db3b609b1fbf446c9e0857b6864a4143877b6eb5fa9e9d2bb790602001610532565b6001600160a01b0381166000908152600760205260408120546001600160801b0316908115610c835781610c97565b600354600160401b90046001600160801b03165b9050806001600160801b0316836001600160a01b031663f97d2ed76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ce1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d05919061102b565b6001600160801b03161415610d2c5760405162461bcd60e51b81526004016103f090610f9b565b6040516307b35d1d60e01b81526001600160801b03821660048201526001600160a01b038416906307b35d1d90602401610800565b6001546000906001600160a01b03168015801590610deb575060405163b700961360e01b81526001600160a01b0382169063b700961390610daa90879030908890600401610fc3565b602060405180830381865afa158015610dc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610deb9190610ff0565b80610e0357506000546001600160a01b038581169116145b949350505050565b6001600160a01b0381168114610e2057600080fd5b50565b60008060408385031215610e3657600080fd5b8235610e4181610e0b565b946020939093013593505050565b600060208284031215610e6157600080fd5b8135610e6c81610e0b565b9392505050565b600060208284031215610e8557600080fd5b5035919050565b6001600160801b0381168114610e2057600080fd5b600060208284031215610eb357600080fd5b8135610e6c81610e8c565b67ffffffffffffffff81168114610e2057600080fd5b600060208284031215610ee657600080fd5b8135610e6c81610ebe565b60008060408385031215610f0457600080fd5b8235610f0f81610e0b565b91506020830135610f1f81610e8c565b809150509250929050565b60008060408385031215610f3d57600080fd5b8235610f4881610e0b565b91506020830135610f1f81610ebe565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b600060208284031215610f9057600080fd5b8151610e6c81610ebe565b6020808252600e908201526d1053149150511657d4d65390d15160921b604082015260600190565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561100257600080fd5b81518015158114610e6c57600080fd5b60006020828403121561102457600080fd5b5051919050565b60006020828403121561103d57600080fd5b8151610e6c81610e8c56fea2646970667358221220dabd9749dca04c003188c7b8c6643c8ca55cc0cd41720b3b50def07f235cc61764736f6c634300080b0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101585760003560e01c80637a9e5e4b116100c3578063bc3e38fa1161007c578063bc3e38fa14610355578063bf7e214f14610368578063c9b639d21461037b578063dd55002d1461038f578063e7926d5c146103a2578063e7d9934b146103ab57600080fd5b80637a9e5e4b146102c45780638da5cb5b146102d7578063ac345d0314610302578063af54da9114610315578063b5ef8b1e14610328578063b7c392c81461034257600080fd5b80634022d941116101155780634022d941146102085780634ce908f41461021b5780635607702f1461022e5780635fad65b0146102415780636eae9513146102615780636f8409321461028157600080fd5b806305d7282c1461015d57806313af4035146101725780632487bbff14610185578063261d26b6146101cb5780632b4b2753146101e25780633295ce96146101f5575b600080fd5b61017061016b366004610e23565b6103be565b005b610170610180366004610e4f565b610452565b6101ae610193366004610e4f565b6007602052600090815260409020546001600160801b031681565b6040516001600160801b0390911681526020015b60405180910390f35b6101d460045481565b6040519081526020016101c2565b6101706101f0366004610e73565b6104cf565b610170610203366004610ea1565b61053d565b610170610216366004610ed4565b6105d7565b610170610229366004610ef1565b610659565b61017061023c366004610e4f565b6106f9565b6101d461024f366004610e4f565b60086020526000908152604090205481565b6101d461026f366004610e4f565b60056020526000908152604090205481565b6102ab61028f366004610e4f565b60066020526000908152604090205467ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020016101c2565b6101706102d2366004610e4f565b610837565b6000546102ea906001600160a01b031681565b6040516001600160a01b0390911681526020016101c2565b610170610310366004610e4f565b610921565b610170610323366004610f2a565b6109fb565b6003546101ae90600160401b90046001600160801b031681565b610170610350366004610e4f565b610a94565b610170610363366004610e23565b610b6e565b6001546102ea906001600160a01b031681565b6003546102ab9067ffffffffffffffff1681565b61017061039d366004610e73565b610bed565b6101d460025481565b6101706103b9366004610e4f565b610c54565b6103d4336000356001600160e01b031916610d61565b6103f95760405162461bcd60e51b81526004016103f090610f58565b60405180910390fd5b6001600160a01b03821660008181526008602052604090819020839055517fd710c46434b3517342d3119bd7db2b06b533042ad40997249339dc52a84ef87c906104469084815260200190565b60405180910390a25050565b610468336000356001600160e01b031916610d61565b6104845760405162461bcd60e51b81526004016103f090610f58565b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6104e5336000356001600160e01b031916610d61565b6105015760405162461bcd60e51b81526004016103f090610f58565b60048190556040518181527ff6ac39ac7a3a4a8e0820f1f0db868216520c8194410993c9a4256df18f2c1648906020015b60405180910390a150565b610553336000356001600160e01b031916610d61565b61056f5760405162461bcd60e51b81526004016103f090610f58565b6003805477ffffffffffffffffffffffffffffffff00000000000000001916600160401b6001600160801b038416908102919091179091556040519081527f54707f3cc4f1f275c1ca6cc5ea22b131da3e4e3187055769a011b8bfa3fe7e2c90602001610532565b6105ed336000356001600160e01b031916610d61565b6106095760405162461bcd60e51b81526004016103f090610f58565b6003805467ffffffffffffffff191667ffffffffffffffff83169081179091556040519081527fd49755c36f0046593fc57349146d19a3d849086b9f6f07f5262bbe51338dd02090602001610532565b61066f336000356001600160e01b031916610d61565b61068b5760405162461bcd60e51b81526004016103f090610f58565b6001600160a01b03821660008181526007602090815260409182902080546fffffffffffffffffffffffffffffffff19166001600160801b03861690811790915591519182527f020f4b532e50c21e70f84cf5b279d8b67380fe88a156bc883d11cbd3c90646089101610446565b6001600160a01b03811660009081526006602052604081205467ffffffffffffffff169081156107295781610737565b60035467ffffffffffffffff165b90508067ffffffffffffffff16836001600160a01b031663448f56b96040518163ffffffff1660e01b8152600401602060405180830381865afa158015610782573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a69190610f7e565b67ffffffffffffffff1614156107ce5760405162461bcd60e51b81526004016103f090610f9b565b604051637b72aeb960e01b815267ffffffffffffffff821660048201526001600160a01b03841690637b72aeb9906024015b600060405180830381600087803b15801561081a57600080fd5b505af115801561082e573d6000803e3d6000fd5b50505050505050565b6000546001600160a01b03163314806108cc575060015460405163b700961360e01b81526001600160a01b039091169063b70096139061088b90339030906001600160e01b03196000351690600401610fc3565b602060405180830381865afa1580156108a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108cc9190610ff0565b6108d557600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6001600160a01b038116600090815260086020526040812054908115610947578161094b565b6004545b905080836001600160a01b0316631c6934786040518163ffffffff1660e01b8152600401602060405180830381865afa15801561098c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b09190611012565b14156109ce5760405162461bcd60e51b81526004016103f090610f9b565b6040516317acc5f160e31b8152600481018290526001600160a01b0384169063bd662f8890602401610800565b610a11336000356001600160e01b031916610d61565b610a2d5760405162461bcd60e51b81526004016103f090610f58565b6001600160a01b038216600081815260066020908152604091829020805467ffffffffffffffff191667ffffffffffffffff861690811790915591519182527f0d239ace1084ebc7a2681e317ee23b0ddccdfb63175585667a8cf7d6771aa36e9101610446565b6001600160a01b038116600090815260056020526040812054908115610aba5781610abe565b6002545b905080836001600160a01b0316637fd6f15c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610aff573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b239190611012565b1415610b415760405162461bcd60e51b81526004016103f090610f9b565b604051637ce3489b60e01b8152600481018290526001600160a01b03841690637ce3489b90602401610800565b610b84336000356001600160e01b031916610d61565b610ba05760405162461bcd60e51b81526004016103f090610f58565b6001600160a01b03821660008181526005602052604090819020839055517f1d66532ea81d485f8eedbb61c45181fc69b2cbf6f5b05f741b0d3d54d80f9ea9906104469084815260200190565b610c03336000356001600160e01b031916610d61565b610c1f5760405162461bcd60e51b81526004016103f090610f58565b60028190556040518181527f1ba0c7196822b2db3b609b1fbf446c9e0857b6864a4143877b6eb5fa9e9d2bb790602001610532565b6001600160a01b0381166000908152600760205260408120546001600160801b0316908115610c835781610c97565b600354600160401b90046001600160801b03165b9050806001600160801b0316836001600160a01b031663f97d2ed76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ce1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d05919061102b565b6001600160801b03161415610d2c5760405162461bcd60e51b81526004016103f090610f9b565b6040516307b35d1d60e01b81526001600160801b03821660048201526001600160a01b038416906307b35d1d90602401610800565b6001546000906001600160a01b03168015801590610deb575060405163b700961360e01b81526001600160a01b0382169063b700961390610daa90879030908890600401610fc3565b602060405180830381865afa158015610dc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610deb9190610ff0565b80610e0357506000546001600160a01b038581169116145b949350505050565b6001600160a01b0381168114610e2057600080fd5b50565b60008060408385031215610e3657600080fd5b8235610e4181610e0b565b946020939093013593505050565b600060208284031215610e6157600080fd5b8135610e6c81610e0b565b9392505050565b600060208284031215610e8557600080fd5b5035919050565b6001600160801b0381168114610e2057600080fd5b600060208284031215610eb357600080fd5b8135610e6c81610e8c565b67ffffffffffffffff81168114610e2057600080fd5b600060208284031215610ee657600080fd5b8135610e6c81610ebe565b60008060408385031215610f0457600080fd5b8235610f0f81610e0b565b91506020830135610f1f81610e8c565b809150509250929050565b60008060408385031215610f3d57600080fd5b8235610f4881610e0b565b91506020830135610f1f81610ebe565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b600060208284031215610f9057600080fd5b8151610e6c81610ebe565b6020808252600e908201526d1053149150511657d4d65390d15160921b604082015260600190565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561100257600080fd5b81518015158114610e6c57600080fd5b60006020828403121561102457600080fd5b5051919050565b60006020828403121561103d57600080fd5b8151610e6c81610e8c56fea2646970667358221220dabd9749dca04c003188c7b8c6643c8ca55cc0cd41720b3b50def07f235cc61764736f6c634300080b0033",
  "devdoc": {
    "author": "Transmissions11 and JetJadeja",
    "events": {
      "CustomFeePercentUpdated(address,uint256)": {
        "params": {
          "newCustomFeePercent": "The new custom fee percentage for the Vault.",
          "vault": "The Vault that had its custom fee percentage set/updated."
        }
      },
      "CustomHarvestDelayUpdated(address,uint256)": {
        "params": {
          "newCustomHarvestDelay": "The new custom harvest delay for the Vault.",
          "vault": "The Vault that had its custom harvest delay set/updated."
        }
      },
      "CustomHarvestWindowUpdated(address,uint256)": {
        "params": {
          "newCustomHarvestWindow": "The new custom harvest window for the Vault.",
          "vault": "The Vault that had its custom harvest window set/updated."
        }
      },
      "CustomTargetFloatPercentUpdated(address,uint256)": {
        "params": {
          "newCustomTargetFloatPercent": "The new custom target float percentage for the Vault.",
          "vault": "The Vault that had its custom target float percentage set/updated."
        }
      },
      "DefaultFeePercentUpdated(uint256)": {
        "params": {
          "newDefaultFeePercent": "The new default fee percentage."
        }
      },
      "DefaultHarvestDelayUpdated(uint64)": {
        "params": {
          "newDefaultHarvestDelay": "The new default harvest delay."
        }
      },
      "DefaultHarvestWindowUpdated(uint128)": {
        "params": {
          "newDefaultHarvestWindow": "The new default harvest window."
        }
      },
      "DefaultTargetFloatPercentUpdated(uint256)": {
        "params": {
          "newDefaultTargetFloatPercent": "The new default target float percentage."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_authority": "The Authority of the module.",
          "_owner": "The owner of the module."
        }
      },
      "setDefaultFeePercent(uint256)": {
        "params": {
          "newDefaultFeePercent": "The new default fee percentage to set."
        }
      },
      "setDefaultHarvestDelay(uint64)": {
        "params": {
          "newDefaultHarvestDelay": "The new default harvest delay to set."
        }
      },
      "setDefaultHarvestWindow(uint128)": {
        "params": {
          "newDefaultHarvestWindow": "The new default harvest window to set."
        }
      },
      "setDefaultTargetFloatPercent(uint256)": {
        "params": {
          "newDefaultTargetFloatPercent": "The new default target float percentage to set."
        }
      },
      "setVaultCustomFeePercent(address,uint256)": {
        "params": {
          "customFeePercent": "The new custom fee percentage to set.",
          "vault": "The Vault to set the custom fee percentage for."
        }
      },
      "setVaultCustomHarvestDelay(address,uint64)": {
        "params": {
          "customHarvestDelay": "The new custom harvest delay to set.",
          "vault": "The Vault to set the custom harvest delay for."
        }
      },
      "setVaultCustomHarvestWindow(address,uint128)": {
        "params": {
          "customHarvestWindow": "The new custom harvest window to set.",
          "vault": "The Vault to set the custom harvest window for."
        }
      },
      "setVaultCustomTargetFloatPercent(address,uint256)": {
        "params": {
          "customTargetFloatPercent": "The new custom target float percentage to set.",
          "vault": "The Vault to set the custom target float percentage for."
        }
      },
      "syncFeePercent(address)": {
        "params": {
          "vault": "The Vault to sync the fee percentage for."
        }
      },
      "syncHarvestDelay(address)": {
        "params": {
          "vault": "The Vault to sync the harvest delay for."
        }
      },
      "syncHarvestWindow(address)": {
        "params": {
          "vault": "The Vault to sync the harvest window for."
        }
      },
      "syncTargetFloatPercent(address)": {
        "params": {
          "vault": "The Vault to sync the target float percentage for."
        }
      }
    },
    "stateVariables": {
      "defaultFeePercent": {
        "details": "See the documentation for the feePercentage variable in the Vault contract for more details."
      },
      "defaultHarvestDelay": {
        "details": "See the documentation for the harvestDelay variable in the Vault contract for more details."
      },
      "defaultHarvestWindow": {
        "details": "See the documentation for the harvestWindow variable in the Vault contract for more details."
      },
      "defaultTargetFloatPercent": {
        "details": "See the documentation for the targetFloatPercent variable in the Vault contract for more details."
      },
      "getVaultCustomFeePercent": {
        "details": "Will be 0 if there is no custom fee percentage for the Vault.See the documentation for the targetFloatPercent variable in the Vault contract for more details."
      },
      "getVaultCustomHarvestDelay": {
        "details": "Will be 0 if there is no custom harvest delay for the Vault.See the documentation for the harvestDelay variable in the Vault contract for more details."
      },
      "getVaultCustomHarvestWindow": {
        "details": "Will be 0 if there is no custom harvest window for the Vault.See the documentation for the harvestWindow variable in the Vault contract for more details."
      },
      "getVaultCustomTargetFloatPercent": {
        "details": "Will be 0 if there is no custom target float percentage for the Vault.See the documentation for the targetFloatPercent variable in the Vault contract for more details."
      }
    },
    "title": "Rari Vault Configuration Module",
    "version": 1
  },
  "userdoc": {
    "events": {
      "CustomFeePercentUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom fee percentage set/updated."
      },
      "CustomHarvestDelayUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom harvest delay set/updated."
      },
      "CustomHarvestWindowUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom harvest window set/updated."
      },
      "CustomTargetFloatPercentUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom target float percentage set/updated."
      },
      "DefaultFeePercentUpdated(uint256)": {
        "notice": "Emitted when the default fee percentage is updated."
      },
      "DefaultHarvestDelayUpdated(uint64)": {
        "notice": "Emitted when the default harvest delay is updated."
      },
      "DefaultHarvestWindowUpdated(uint128)": {
        "notice": "Emitted when the default harvest window is updated."
      },
      "DefaultTargetFloatPercentUpdated(uint256)": {
        "notice": "Emitted when the default target float percentage is updated."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Creates a Vault configuration module."
      },
      "defaultFeePercent()": {
        "notice": "The default fee percentage for Vaults."
      },
      "defaultHarvestDelay()": {
        "notice": "The default harvest delay for Vaults."
      },
      "defaultHarvestWindow()": {
        "notice": "The default harvest window for Vaults."
      },
      "defaultTargetFloatPercent()": {
        "notice": "The default target float percentage for Vaults."
      },
      "getVaultCustomFeePercent(address)": {
        "notice": "Maps Vaults to their custom fee percentage."
      },
      "getVaultCustomHarvestDelay(address)": {
        "notice": "Maps Vaults to their custom harvest delay."
      },
      "getVaultCustomHarvestWindow(address)": {
        "notice": "Maps Vaults to their custom harvest window."
      },
      "getVaultCustomTargetFloatPercent(address)": {
        "notice": "Maps Vaults to their custom target float percentage."
      },
      "setDefaultFeePercent(uint256)": {
        "notice": "Sets the default fee percentage for Vaults."
      },
      "setDefaultHarvestDelay(uint64)": {
        "notice": "Sets the default harvest delay for Vaults."
      },
      "setDefaultHarvestWindow(uint128)": {
        "notice": "Sets the default harvest window for Vaults."
      },
      "setDefaultTargetFloatPercent(uint256)": {
        "notice": "Sets the default target float percentage for Vaults."
      },
      "setVaultCustomFeePercent(address,uint256)": {
        "notice": "Sets the custom fee percentage for the Vault."
      },
      "setVaultCustomHarvestDelay(address,uint64)": {
        "notice": "Sets the custom harvest delay for the Vault."
      },
      "setVaultCustomHarvestWindow(address,uint128)": {
        "notice": "Sets the custom harvest window for the Vault."
      },
      "setVaultCustomTargetFloatPercent(address,uint256)": {
        "notice": "Sets the custom target float percentage for the Vault."
      },
      "syncFeePercent(address)": {
        "notice": "Syncs a Vault's fee percentage with either the Vault's custom fee percentage or the default fee percentage if a custom percentage is not set."
      },
      "syncHarvestDelay(address)": {
        "notice": "Syncs a Vault's harvest delay with either the Vault's custom harvest delay or the default harvest delay if a custom delay is not set."
      },
      "syncHarvestWindow(address)": {
        "notice": "Syncs a Vault's harvest window with either the Vault's custom harvest window or the default harvest window if a custom window is not set."
      },
      "syncTargetFloatPercent(address)": {
        "notice": "Syncs a Vault's target float percentage with either the Vault's custom target float percentage or the default target float percentage if a custom percentage is not set."
      }
    },
    "notice": "Module for configuring Vault parameters.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 17,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 20,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "authority",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Authority)171"
      },
      {
        "astId": 7849,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultFeePercent",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 7852,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultHarvestDelay",
        "offset": 0,
        "slot": "3",
        "type": "t_uint64"
      },
      {
        "astId": 7855,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultHarvestWindow",
        "offset": 8,
        "slot": "3",
        "type": "t_uint128"
      },
      {
        "astId": 7858,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultTargetFloatPercent",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 7964,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomFeePercent",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_contract(Vault)5033,t_uint256)"
      },
      {
        "astId": 7970,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomHarvestDelay",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_contract(Vault)5033,t_uint64)"
      },
      {
        "astId": 7976,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomHarvestWindow",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_contract(Vault)5033,t_uint128)"
      },
      {
        "astId": 7982,
        "contract": "srcBuild/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomTargetFloatPercent",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_contract(Vault)5033,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(Authority)171": {
        "encoding": "inplace",
        "label": "contract Authority",
        "numberOfBytes": "20"
      },
      "t_contract(Vault)5033": {
        "encoding": "inplace",
        "label": "contract Vault",
        "numberOfBytes": "20"
      },
      "t_mapping(t_contract(Vault)5033,t_uint128)": {
        "encoding": "mapping",
        "key": "t_contract(Vault)5033",
        "label": "mapping(contract Vault => uint128)",
        "numberOfBytes": "32",
        "value": "t_uint128"
      },
      "t_mapping(t_contract(Vault)5033,t_uint256)": {
        "encoding": "mapping",
        "key": "t_contract(Vault)5033",
        "label": "mapping(contract Vault => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_contract(Vault)5033,t_uint64)": {
        "encoding": "mapping",
        "key": "t_contract(Vault)5033",
        "label": "mapping(contract Vault => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}