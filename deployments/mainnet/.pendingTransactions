{
  "0x1df1e2a903b3b413780af894c1bcc966255ee74f6fe5a322169b1a8b3df1ed64": {
    "name": "AirdropClaim",
    "deployment": {
      "_format": "hh-sol-artifact-1",
      "contractName": "AirdropClaim",
      "sourceName": "srcBuild/AirdropClaim.sol",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "GOVERNANCE_",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "MERKLE_ROOT_",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "veAPHRA_ADDR_",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "name": "AlreadyClaimed",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "NotInMerkle",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "contract Authority",
              "name": "newAuthority",
              "type": "address"
            }
          ],
          "name": "AuthorityUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "Claim",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "user",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "OwnerUpdated",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "_ve",
          "outputs": [
            {
              "internalType": "contract veAPHRA",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "aphra",
          "outputs": [
            {
              "internalType": "contract ERC20",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "authority",
          "outputs": [
            {
              "internalType": "contract Authority",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "proof",
              "type": "bytes32[]"
            }
          ],
          "name": "claim",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "name": "hasClaimed",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "merkleRoot",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "owner",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract Authority",
              "name": "newAuthority",
              "type": "address"
            }
          ],
          "name": "setAuthority",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "veAPHRA_ADDR_",
              "type": "address"
            }
          ],
          "name": "setNewVe",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "setOwner",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "bytecode": "0x60c060405234801561001057600080fd5b50604051610bb3380380610bb383398101604081905261002f916101de565b600080546001600160a01b0385166001600160a01b031991821681178355600180549092169091556040518592919033907f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76908490a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350506080829052600280546001600160a01b0319166001600160a01b03831690811790915560408051637e062a3560e11b8152905163fc0c546a916004808201926020929091908290030181865afa15801561011b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013f919061021a565b6001600160a01b0390811660a081905260405163095ea7b360e01b8152918316600483015260001960248301529063095ea7b3906044016020604051808303816000875af1158015610195573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b9919061023c565b5050505061025e565b80516001600160a01b03811681146101d957600080fd5b919050565b6000806000606084860312156101f357600080fd5b6101fc846101c2565b925060208401519150610211604085016101c2565b90509250925092565b60006020828403121561022c57600080fd5b610235826101c2565b9392505050565b60006020828403121561024e57600080fd5b8151801515811461023557600080fd5b60805160a0516109236102906000396000818161010a01526105d701526000818160bd015261032901526109236000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80637a9e5e4b116100665780637a9e5e4b146101775780638da5cb5b1461018a5780638dd598fb1461019d578063bf7e214f146101b0578063d4fc9e9b146101c357600080fd5b806313af4035146100a35780632eb4a7ab146100b85780633d13f874146100f25780634732977c1461010557806373b2e80e14610144575b600080fd5b6100b66100b1366004610796565b6101d6565b005b6100df7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100b66101003660046107ba565b610277565b61012c7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e9565b610167610152366004610796565b60036020526000908152604090205460ff1681565b60405190151581526020016100e9565b6100b6610185366004610796565b61045e565b60005461012c906001600160a01b031681565b60025461012c906001600160a01b031681565b60015461012c906001600160a01b031681565b6100b66101d1366004610796565b610548565b6101ec336000356001600160e01b03191661064a565b61022c5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b60448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6001600160a01b03841660009081526003602052604090205460ff16156102b157604051630c8d9eab60e31b815260040160405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006103548484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f000000000000000000000000000000000000000000000000000000000000000092508691506106f49050565b9050806103745760405163452c2df160e11b815260040160405180910390fd5b6001600160a01b0386811660008181526003602052604090819020805460ff19166001179055600254905163d4e54c3b60e01b8152600481018990526303c26700602482015260448101929092529091169063d4e54c3b906064016020604051808303816000875af11580156103ee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104129190610846565b50856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161044e91815260200190565b60405180910390a2505050505050565b6000546001600160a01b03163314806104f3575060015460405163b700961360e01b81526001600160a01b039091169063b7009613906104b290339030906001600160e01b0319600035169060040161085f565b602060405180830381865afa1580156104cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f3919061088c565b6104fc57600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b61055e336000356001600160e01b03191661064a565b6105995760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610223565b600280546001600160a01b0319166001600160a01b0383811691821790925560405163095ea7b360e01b8152600481019190915260001960248201527f00000000000000000000000000000000000000000000000000000000000000009091169063095ea7b3906044016020604051808303816000875af1158015610622573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610646919061088c565b5050565b6001546000906001600160a01b031680158015906106d4575060405163b700961360e01b81526001600160a01b0382169063b7009613906106939087903090889060040161085f565b602060405180830381865afa1580156106b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d4919061088c565b806106ec57506000546001600160a01b038581169116145b949350505050565b600082610701858461070a565b14949350505050565b600081815b845181101561077657600085828151811061072c5761072c6108ae565b602002602001015190508083116107525760008381526020829052604090209250610763565b600081815260208490526040902092505b508061076e816108c4565b91505061070f565b509392505050565b6001600160a01b038116811461079357600080fd5b50565b6000602082840312156107a857600080fd5b81356107b38161077e565b9392505050565b600080600080606085870312156107d057600080fd5b84356107db8161077e565b935060208501359250604085013567ffffffffffffffff808211156107ff57600080fd5b818701915087601f83011261081357600080fd5b81358181111561082257600080fd5b8860208260051b850101111561083757600080fd5b95989497505060200194505050565b60006020828403121561085857600080fd5b5051919050565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561089e57600080fd5b815180151581146107b357600080fd5b634e487b7160e01b600052603260045260246000fd5b60006000198214156108e657634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220a2441b2b59bbf334515989f62a464e9cd66f423ffbb277380b7e3fb1c1e8cdb764736f6c634300080b0033",
      "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c80637a9e5e4b116100665780637a9e5e4b146101775780638da5cb5b1461018a5780638dd598fb1461019d578063bf7e214f146101b0578063d4fc9e9b146101c357600080fd5b806313af4035146100a35780632eb4a7ab146100b85780633d13f874146100f25780634732977c1461010557806373b2e80e14610144575b600080fd5b6100b66100b1366004610796565b6101d6565b005b6100df7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100b66101003660046107ba565b610277565b61012c7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e9565b610167610152366004610796565b60036020526000908152604090205460ff1681565b60405190151581526020016100e9565b6100b6610185366004610796565b61045e565b60005461012c906001600160a01b031681565b60025461012c906001600160a01b031681565b60015461012c906001600160a01b031681565b6100b66101d1366004610796565b610548565b6101ec336000356001600160e01b03191661064a565b61022c5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b60448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6001600160a01b03841660009081526003602052604090205460ff16156102b157604051630c8d9eab60e31b815260040160405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006103548484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f000000000000000000000000000000000000000000000000000000000000000092508691506106f49050565b9050806103745760405163452c2df160e11b815260040160405180910390fd5b6001600160a01b0386811660008181526003602052604090819020805460ff19166001179055600254905163d4e54c3b60e01b8152600481018990526303c26700602482015260448101929092529091169063d4e54c3b906064016020604051808303816000875af11580156103ee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104129190610846565b50856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161044e91815260200190565b60405180910390a2505050505050565b6000546001600160a01b03163314806104f3575060015460405163b700961360e01b81526001600160a01b039091169063b7009613906104b290339030906001600160e01b0319600035169060040161085f565b602060405180830381865afa1580156104cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f3919061088c565b6104fc57600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b61055e336000356001600160e01b03191661064a565b6105995760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610223565b600280546001600160a01b0319166001600160a01b0383811691821790925560405163095ea7b360e01b8152600481019190915260001960248201527f00000000000000000000000000000000000000000000000000000000000000009091169063095ea7b3906044016020604051808303816000875af1158015610622573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610646919061088c565b5050565b6001546000906001600160a01b031680158015906106d4575060405163b700961360e01b81526001600160a01b0382169063b7009613906106939087903090889060040161085f565b602060405180830381865afa1580156106b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d4919061088c565b806106ec57506000546001600160a01b038581169116145b949350505050565b600082610701858461070a565b14949350505050565b600081815b845181101561077657600085828151811061072c5761072c6108ae565b602002602001015190508083116107525760008381526020829052604090209250610763565b600081815260208490526040902092505b508061076e816108c4565b91505061070f565b509392505050565b6001600160a01b038116811461079357600080fd5b50565b6000602082840312156107a857600080fd5b81356107b38161077e565b9392505050565b600080600080606085870312156107d057600080fd5b84356107db8161077e565b935060208501359250604085013567ffffffffffffffff808211156107ff57600080fd5b818701915087601f83011261081357600080fd5b81358181111561082257600080fd5b8860208260051b850101111561083757600080fd5b95989497505060200194505050565b60006020828403121561085857600080fd5b5051919050565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561089e57600080fd5b815180151581146107b357600080fd5b634e487b7160e01b600052603260045260246000fd5b60006000198214156108e657634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220a2441b2b59bbf334515989f62a464e9cd66f423ffbb277380b7e3fb1c1e8cdb764736f6c634300080b0033",
      "linkReferences": {},
      "deployedLinkReferences": {},
      "devdoc": {
        "kind": "dev",
        "methods": {},
        "version": 1
      },
      "evm": {
        "bytecode": {
          "functionDebugData": {
            "@_1095": {
              "entryPoint": null,
              "id": 1095,
              "parameterSlots": 3,
              "returnSlots": 0
            },
            "@_49": {
              "entryPoint": null,
              "id": 49,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "abi_decode_address_fromMemory": {
              "entryPoint": 450,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_address_fromMemory": {
              "entryPoint": 538,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_addresst_bytes32t_address_fromMemory": {
              "entryPoint": 478,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 3
            },
            "abi_decode_tuple_t_bool_fromMemory": {
              "entryPoint": 572,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_address_t_uint256__to_t_address_t_uint256__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 3,
              "returnSlots": 1
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nodeType": "YulBlock",
                "src": "0:1326:33",
                "statements": [
                  {
                    "nodeType": "YulBlock",
                    "src": "6:3:33",
                    "statements": []
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "74:117:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "84:22:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "99:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "93:5:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "93:13:33"
                          },
                          "variableNames": [
                            {
                              "name": "value",
                              "nodeType": "YulIdentifier",
                              "src": "84:5:33"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "169:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "178:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "181:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "171:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "171:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "171:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "128:5:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "139:5:33"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "154:3:33",
                                                "type": "",
                                                "value": "160"
                                              },
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "159:1:33",
                                                "type": "",
                                                "value": "1"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "shl",
                                              "nodeType": "YulIdentifier",
                                              "src": "150:3:33"
                                            },
                                            "nodeType": "YulFunctionCall",
                                            "src": "150:11:33"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "163:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "sub",
                                          "nodeType": "YulIdentifier",
                                          "src": "146:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "146:19:33"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "135:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "135:31:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "125:2:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "125:42:33"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "118:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "118:50:33"
                          },
                          "nodeType": "YulIf",
                          "src": "115:70:33"
                        }
                      ]
                    },
                    "name": "abi_decode_address_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "53:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "64:5:33",
                        "type": ""
                      }
                    ],
                    "src": "14:177:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "311:239:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "357:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "366:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "369:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "359:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "359:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "359:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "332:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "341:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "328:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "328:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "353:2:33",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "324:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "324:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "321:52:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "382:50:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "422:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address_fromMemory",
                              "nodeType": "YulIdentifier",
                              "src": "392:29:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "392:40:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "382:6:33"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "441:35:33",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "461:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "472:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "457:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "457:18:33"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "451:5:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "451:25:33"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "441:6:33"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "485:59:33",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "529:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "540:2:33",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "525:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "525:18:33"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address_fromMemory",
                              "nodeType": "YulIdentifier",
                              "src": "495:29:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "495:49:33"
                          },
                          "variableNames": [
                            {
                              "name": "value2",
                              "nodeType": "YulIdentifier",
                              "src": "485:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_addresst_bytes32t_address_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "261:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "272:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "284:6:33",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "292:6:33",
                        "type": ""
                      },
                      {
                        "name": "value2",
                        "nodeType": "YulTypedName",
                        "src": "300:6:33",
                        "type": ""
                      }
                    ],
                    "src": "196:354:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "636:127:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "682:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "691:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "694:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "684:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "684:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "684:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "657:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "666:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "653:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "653:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "678:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "649:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "649:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "646:52:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "707:50:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "747:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address_fromMemory",
                              "nodeType": "YulIdentifier",
                              "src": "717:29:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "717:40:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "707:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "602:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "613:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "625:6:33",
                        "type": ""
                      }
                    ],
                    "src": "555:208:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "897:145:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "907:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "919:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "930:2:33",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "915:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "915:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "907:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "949:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "964:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "980:3:33",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "985:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "976:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "976:11:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "989:1:33",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "972:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "972:19:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "960:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "960:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "942:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "942:51:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "942:51:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1013:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "1024:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1009:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1009:18:33"
                              },
                              {
                                "name": "value1",
                                "nodeType": "YulIdentifier",
                                "src": "1029:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1002:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1002:34:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1002:34:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address_t_uint256__to_t_address_t_uint256__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "858:9:33",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "869:6:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "877:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "888:4:33",
                        "type": ""
                      }
                    ],
                    "src": "768:274:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1125:199:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1171:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1180:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1183:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1173:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1173:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1173:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1146:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1155:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "1142:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1142:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1167:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "1138:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1138:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "1135:52:33"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1196:29:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1215:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "1209:5:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1209:16:33"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "1200:5:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1278:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1287:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1290:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1280:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1280:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1280:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "1247:5:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "name": "value",
                                            "nodeType": "YulIdentifier",
                                            "src": "1268:5:33"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "iszero",
                                          "nodeType": "YulIdentifier",
                                          "src": "1261:6:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "1261:13:33"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "iszero",
                                      "nodeType": "YulIdentifier",
                                      "src": "1254:6:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1254:21:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "1244:2:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1244:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "1237:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1237:40:33"
                          },
                          "nodeType": "YulIf",
                          "src": "1234:60:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1303:15:33",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "1313:5:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "1303:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_bool_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1091:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "1102:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1114:6:33",
                        "type": ""
                      }
                    ],
                    "src": "1047:277:33"
                  }
                ]
              },
              "contents": "{\n    { }\n    function abi_decode_address_fromMemory(offset) -> value\n    {\n        value := mload(offset)\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_addresst_bytes32t_address_fromMemory(headStart, dataEnd) -> value0, value1, value2\n    {\n        if slt(sub(dataEnd, headStart), 96) { revert(0, 0) }\n        value0 := abi_decode_address_fromMemory(headStart)\n        value1 := mload(add(headStart, 32))\n        value2 := abi_decode_address_fromMemory(add(headStart, 64))\n    }\n    function abi_decode_tuple_t_address_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        value0 := abi_decode_address_fromMemory(headStart)\n    }\n    function abi_encode_tuple_t_address_t_uint256__to_t_address_t_uint256__fromStack_reversed(headStart, value1, value0) -> tail\n    {\n        tail := add(headStart, 64)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n        mstore(add(headStart, 32), value1)\n    }\n    function abi_decode_tuple_t_bool_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := mload(headStart)\n        if iszero(eq(value, iszero(iszero(value)))) { revert(0, 0) }\n        value0 := value\n    }\n}",
              "id": 33,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "linkReferences": {},
          "object": "60c060405234801561001057600080fd5b50604051610bb3380380610bb383398101604081905261002f916101de565b600080546001600160a01b0385166001600160a01b031991821681178355600180549092169091556040518592919033907f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76908490a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350506080829052600280546001600160a01b0319166001600160a01b03831690811790915560408051637e062a3560e11b8152905163fc0c546a916004808201926020929091908290030181865afa15801561011b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013f919061021a565b6001600160a01b0390811660a081905260405163095ea7b360e01b8152918316600483015260001960248301529063095ea7b3906044016020604051808303816000875af1158015610195573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b9919061023c565b5050505061025e565b80516001600160a01b03811681146101d957600080fd5b919050565b6000806000606084860312156101f357600080fd5b6101fc846101c2565b925060208401519150610211604085016101c2565b90509250925092565b60006020828403121561022c57600080fd5b610235826101c2565b9392505050565b60006020828403121561024e57600080fd5b8151801515811461023557600080fd5b60805160a0516109236102906000396000818161010a01526105d701526000818160bd015261032901526109236000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80637a9e5e4b116100665780637a9e5e4b146101775780638da5cb5b1461018a5780638dd598fb1461019d578063bf7e214f146101b0578063d4fc9e9b146101c357600080fd5b806313af4035146100a35780632eb4a7ab146100b85780633d13f874146100f25780634732977c1461010557806373b2e80e14610144575b600080fd5b6100b66100b1366004610796565b6101d6565b005b6100df7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100b66101003660046107ba565b610277565b61012c7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e9565b610167610152366004610796565b60036020526000908152604090205460ff1681565b60405190151581526020016100e9565b6100b6610185366004610796565b61045e565b60005461012c906001600160a01b031681565b60025461012c906001600160a01b031681565b60015461012c906001600160a01b031681565b6100b66101d1366004610796565b610548565b6101ec336000356001600160e01b03191661064a565b61022c5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b60448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6001600160a01b03841660009081526003602052604090205460ff16156102b157604051630c8d9eab60e31b815260040160405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006103548484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f000000000000000000000000000000000000000000000000000000000000000092508691506106f49050565b9050806103745760405163452c2df160e11b815260040160405180910390fd5b6001600160a01b0386811660008181526003602052604090819020805460ff19166001179055600254905163d4e54c3b60e01b8152600481018990526303c26700602482015260448101929092529091169063d4e54c3b906064016020604051808303816000875af11580156103ee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104129190610846565b50856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161044e91815260200190565b60405180910390a2505050505050565b6000546001600160a01b03163314806104f3575060015460405163b700961360e01b81526001600160a01b039091169063b7009613906104b290339030906001600160e01b0319600035169060040161085f565b602060405180830381865afa1580156104cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f3919061088c565b6104fc57600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b61055e336000356001600160e01b03191661064a565b6105995760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610223565b600280546001600160a01b0319166001600160a01b0383811691821790925560405163095ea7b360e01b8152600481019190915260001960248201527f00000000000000000000000000000000000000000000000000000000000000009091169063095ea7b3906044016020604051808303816000875af1158015610622573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610646919061088c565b5050565b6001546000906001600160a01b031680158015906106d4575060405163b700961360e01b81526001600160a01b0382169063b7009613906106939087903090889060040161085f565b602060405180830381865afa1580156106b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d4919061088c565b806106ec57506000546001600160a01b038581169116145b949350505050565b600082610701858461070a565b14949350505050565b600081815b845181101561077657600085828151811061072c5761072c6108ae565b602002602001015190508083116107525760008381526020829052604090209250610763565b600081815260208490526040902092505b508061076e816108c4565b91505061070f565b509392505050565b6001600160a01b038116811461079357600080fd5b50565b6000602082840312156107a857600080fd5b81356107b38161077e565b9392505050565b600080600080606085870312156107d057600080fd5b84356107db8161077e565b935060208501359250604085013567ffffffffffffffff808211156107ff57600080fd5b818701915087601f83011261081357600080fd5b81358181111561082257600080fd5b8860208260051b850101111561083757600080fd5b95989497505060200194505050565b60006020828403121561085857600080fd5b5051919050565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561089e57600080fd5b815180151581146107b357600080fd5b634e487b7160e01b600052603260045260246000fd5b60006000198214156108e657634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220a2441b2b59bbf334515989f62a464e9cd66f423ffbb277380b7e3fb1c1e8cdb764736f6c634300080b0033",
          "opcodes": "PUSH1 0xC0 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH2 0xBB3 CODESIZE SUB DUP1 PUSH2 0xBB3 DUP4 CODECOPY DUP2 ADD PUSH1 0x40 DUP2 SWAP1 MSTORE PUSH2 0x2F SWAP2 PUSH2 0x1DE JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP6 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP2 DUP3 AND DUP2 OR DUP4 SSTORE PUSH1 0x1 DUP1 SLOAD SWAP1 SWAP3 AND SWAP1 SWAP2 SSTORE PUSH1 0x40 MLOAD DUP6 SWAP3 SWAP2 SWAP1 CALLER SWAP1 PUSH32 0x8292FCE18FA69EDF4DB7B94EA2E58241DF0AE57F97E0A6C9B29067028BF92D76 SWAP1 DUP5 SWAP1 LOG3 PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND SWAP1 CALLER SWAP1 PUSH32 0xA3396FD7F6E0A21B50E5089D2DA70D5AC0A3BBBD1F617A93F134B76389980198 SWAP1 PUSH1 0x0 SWAP1 LOG3 POP POP PUSH1 0x80 DUP3 SWAP1 MSTORE PUSH1 0x2 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR SWAP1 SWAP2 SSTORE PUSH1 0x40 DUP1 MLOAD PUSH4 0x7E062A35 PUSH1 0xE1 SHL DUP2 MSTORE SWAP1 MLOAD PUSH4 0xFC0C546A SWAP2 PUSH1 0x4 DUP1 DUP3 ADD SWAP3 PUSH1 0x20 SWAP3 SWAP1 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x11B JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x13F SWAP2 SWAP1 PUSH2 0x21A JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 DUP2 AND PUSH1 0xA0 DUP2 SWAP1 MSTORE PUSH1 0x40 MLOAD PUSH4 0x95EA7B3 PUSH1 0xE0 SHL DUP2 MSTORE SWAP2 DUP4 AND PUSH1 0x4 DUP4 ADD MSTORE PUSH1 0x0 NOT PUSH1 0x24 DUP4 ADD MSTORE SWAP1 PUSH4 0x95EA7B3 SWAP1 PUSH1 0x44 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH2 0x195 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x1B9 SWAP2 SWAP1 PUSH2 0x23C JUMP JUMPDEST POP POP POP POP PUSH2 0x25E JUMP JUMPDEST DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x1D9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x1F3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x1FC DUP5 PUSH2 0x1C2 JUMP JUMPDEST SWAP3 POP PUSH1 0x20 DUP5 ADD MLOAD SWAP2 POP PUSH2 0x211 PUSH1 0x40 DUP6 ADD PUSH2 0x1C2 JUMP JUMPDEST SWAP1 POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x22C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x235 DUP3 PUSH2 0x1C2 JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x24E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD DUP1 ISZERO ISZERO DUP2 EQ PUSH2 0x235 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x80 MLOAD PUSH1 0xA0 MLOAD PUSH2 0x923 PUSH2 0x290 PUSH1 0x0 CODECOPY PUSH1 0x0 DUP2 DUP2 PUSH2 0x10A ADD MSTORE PUSH2 0x5D7 ADD MSTORE PUSH1 0x0 DUP2 DUP2 PUSH1 0xBD ADD MSTORE PUSH2 0x329 ADD MSTORE PUSH2 0x923 PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x9E JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x7A9E5E4B GT PUSH2 0x66 JUMPI DUP1 PUSH4 0x7A9E5E4B EQ PUSH2 0x177 JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x18A JUMPI DUP1 PUSH4 0x8DD598FB EQ PUSH2 0x19D JUMPI DUP1 PUSH4 0xBF7E214F EQ PUSH2 0x1B0 JUMPI DUP1 PUSH4 0xD4FC9E9B EQ PUSH2 0x1C3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x13AF4035 EQ PUSH2 0xA3 JUMPI DUP1 PUSH4 0x2EB4A7AB EQ PUSH2 0xB8 JUMPI DUP1 PUSH4 0x3D13F874 EQ PUSH2 0xF2 JUMPI DUP1 PUSH4 0x4732977C EQ PUSH2 0x105 JUMPI DUP1 PUSH4 0x73B2E80E EQ PUSH2 0x144 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xB6 PUSH2 0xB1 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH2 0x1D6 JUMP JUMPDEST STOP JUMPDEST PUSH2 0xDF PUSH32 0x0 DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xB6 PUSH2 0x100 CALLDATASIZE PUSH1 0x4 PUSH2 0x7BA JUMP JUMPDEST PUSH2 0x277 JUMP JUMPDEST PUSH2 0x12C PUSH32 0x0 DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xE9 JUMP JUMPDEST PUSH2 0x167 PUSH2 0x152 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH1 0x3 PUSH1 0x20 MSTORE PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD PUSH1 0xFF AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 ISZERO ISZERO DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xE9 JUMP JUMPDEST PUSH2 0xB6 PUSH2 0x185 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH2 0x45E JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH2 0x12C SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x2 SLOAD PUSH2 0x12C SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH2 0x12C SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH2 0xB6 PUSH2 0x1D1 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH2 0x548 JUMP JUMPDEST PUSH2 0x1EC CALLER PUSH1 0x0 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT AND PUSH2 0x64A JUMP JUMPDEST PUSH2 0x22C JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xC PUSH1 0x24 DUP3 ADD MSTORE PUSH12 0x15539055551213D492569151 PUSH1 0xA2 SHL PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR DUP3 SSTORE PUSH1 0x40 MLOAD SWAP1 SWAP2 CALLER SWAP2 PUSH32 0x8292FCE18FA69EDF4DB7B94EA2E58241DF0AE57F97E0A6C9B29067028BF92D76 SWAP2 SWAP1 LOG3 POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x3 PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD PUSH1 0xFF AND ISZERO PUSH2 0x2B1 JUMPI PUSH1 0x40 MLOAD PUSH4 0xC8D9EAB PUSH1 0xE3 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x40 MLOAD PUSH12 0xFFFFFFFFFFFFFFFFFFFFFFFF NOT PUSH1 0x60 DUP7 SWAP1 SHL AND PUSH1 0x20 DUP3 ADD MSTORE PUSH1 0x34 DUP2 ADD DUP5 SWAP1 MSTORE PUSH1 0x0 SWAP1 PUSH1 0x54 ADD PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE DUP1 MLOAD SWAP1 PUSH1 0x20 ADD KECCAK256 SWAP1 POP PUSH1 0x0 PUSH2 0x354 DUP5 DUP5 DUP1 DUP1 PUSH1 0x20 MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY PUSH1 0x0 SWAP3 ADD SWAP2 SWAP1 SWAP2 MSTORE POP PUSH32 0x0 SWAP3 POP DUP7 SWAP2 POP PUSH2 0x6F4 SWAP1 POP JUMP JUMPDEST SWAP1 POP DUP1 PUSH2 0x374 JUMPI PUSH1 0x40 MLOAD PUSH4 0x452C2DF1 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP7 DUP2 AND PUSH1 0x0 DUP2 DUP2 MSTORE PUSH1 0x3 PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 DUP2 SWAP1 KECCAK256 DUP1 SLOAD PUSH1 0xFF NOT AND PUSH1 0x1 OR SWAP1 SSTORE PUSH1 0x2 SLOAD SWAP1 MLOAD PUSH4 0xD4E54C3B PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP10 SWAP1 MSTORE PUSH4 0x3C26700 PUSH1 0x24 DUP3 ADD MSTORE PUSH1 0x44 DUP2 ADD SWAP3 SWAP1 SWAP3 MSTORE SWAP1 SWAP2 AND SWAP1 PUSH4 0xD4E54C3B SWAP1 PUSH1 0x64 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH2 0x3EE JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x412 SWAP2 SWAP1 PUSH2 0x846 JUMP JUMPDEST POP DUP6 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH32 0x47CEE97CB7ACD717B3C0AA1435D004CD5B3C8C57D70DBCEB4E4458BBD60E39D4 DUP7 PUSH1 0x40 MLOAD PUSH2 0x44E SWAP2 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG2 POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ DUP1 PUSH2 0x4F3 JUMPI POP PUSH1 0x1 SLOAD PUSH1 0x40 MLOAD PUSH4 0xB7009613 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND SWAP1 PUSH4 0xB7009613 SWAP1 PUSH2 0x4B2 SWAP1 CALLER SWAP1 ADDRESS SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT PUSH1 0x0 CALLDATALOAD AND SWAP1 PUSH1 0x4 ADD PUSH2 0x85F JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x4CF JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x4F3 SWAP2 SWAP1 PUSH2 0x88C JUMP JUMPDEST PUSH2 0x4FC JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR SWAP1 SWAP2 SSTORE PUSH1 0x40 MLOAD CALLER SWAP1 PUSH32 0xA3396FD7F6E0A21B50E5089D2DA70D5AC0A3BBBD1F617A93F134B76389980198 SWAP1 PUSH1 0x0 SWAP1 LOG3 POP JUMP JUMPDEST PUSH2 0x55E CALLER PUSH1 0x0 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT AND PUSH2 0x64A JUMP JUMPDEST PUSH2 0x599 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xC PUSH1 0x24 DUP3 ADD MSTORE PUSH12 0x15539055551213D492569151 PUSH1 0xA2 SHL PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x223 JUMP JUMPDEST PUSH1 0x2 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND SWAP2 DUP3 OR SWAP1 SWAP3 SSTORE PUSH1 0x40 MLOAD PUSH4 0x95EA7B3 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH1 0x0 NOT PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x0 SWAP1 SWAP2 AND SWAP1 PUSH4 0x95EA7B3 SWAP1 PUSH1 0x44 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH2 0x622 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x646 SWAP2 SWAP1 PUSH2 0x88C JUMP JUMPDEST POP POP JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP1 ISZERO DUP1 ISZERO SWAP1 PUSH2 0x6D4 JUMPI POP PUSH1 0x40 MLOAD PUSH4 0xB7009613 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND SWAP1 PUSH4 0xB7009613 SWAP1 PUSH2 0x693 SWAP1 DUP8 SWAP1 ADDRESS SWAP1 DUP9 SWAP1 PUSH1 0x4 ADD PUSH2 0x85F JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x6B0 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x6D4 SWAP2 SWAP1 PUSH2 0x88C JUMP JUMPDEST DUP1 PUSH2 0x6EC JUMPI POP PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP6 DUP2 AND SWAP2 AND EQ JUMPDEST SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH2 0x701 DUP6 DUP5 PUSH2 0x70A JUMP JUMPDEST EQ SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 DUP2 JUMPDEST DUP5 MLOAD DUP2 LT ISZERO PUSH2 0x776 JUMPI PUSH1 0x0 DUP6 DUP3 DUP2 MLOAD DUP2 LT PUSH2 0x72C JUMPI PUSH2 0x72C PUSH2 0x8AE JUMP JUMPDEST PUSH1 0x20 MUL PUSH1 0x20 ADD ADD MLOAD SWAP1 POP DUP1 DUP4 GT PUSH2 0x752 JUMPI PUSH1 0x0 DUP4 DUP2 MSTORE PUSH1 0x20 DUP3 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SWAP3 POP PUSH2 0x763 JUMP JUMPDEST PUSH1 0x0 DUP2 DUP2 MSTORE PUSH1 0x20 DUP5 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SWAP3 POP JUMPDEST POP DUP1 PUSH2 0x76E DUP2 PUSH2 0x8C4 JUMP JUMPDEST SWAP2 POP POP PUSH2 0x70F JUMP JUMPDEST POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x793 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x7A8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH2 0x7B3 DUP2 PUSH2 0x77E JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0x60 DUP6 DUP8 SUB SLT ISZERO PUSH2 0x7D0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP5 CALLDATALOAD PUSH2 0x7DB DUP2 PUSH2 0x77E JUMP JUMPDEST SWAP4 POP PUSH1 0x20 DUP6 ADD CALLDATALOAD SWAP3 POP PUSH1 0x40 DUP6 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x7FF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP8 ADD SWAP2 POP DUP8 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x813 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0x822 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP9 PUSH1 0x20 DUP3 PUSH1 0x5 SHL DUP6 ADD ADD GT ISZERO PUSH2 0x837 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP6 SWAP9 SWAP5 SWAP8 POP POP PUSH1 0x20 ADD SWAP5 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x858 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP4 DUP5 AND DUP2 MSTORE SWAP2 SWAP1 SWAP3 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT SWAP1 SWAP2 AND PUSH1 0x40 DUP3 ADD MSTORE PUSH1 0x60 ADD SWAP1 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x89E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD DUP1 ISZERO ISZERO DUP2 EQ PUSH2 0x7B3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x32 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x0 NOT DUP3 EQ ISZERO PUSH2 0x8E6 JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST POP PUSH1 0x1 ADD SWAP1 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 LOG2 DIFFICULTY SHL 0x2B MSIZE 0xBB RETURN CALLVALUE MLOAD MSIZE DUP10 0xF6 0x2A CHAINID 0x4E SWAP13 0xD6 PUSH16 0x423FFBB277380B7E3FB1C1E8CDB76473 PUSH16 0x6C634300080B00330000000000000000 ",
          "sourceMap": "272:1795:8:-:0;;;730:319;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;874:1;671:14:0;;-1:-1:-1;;;;;671:14:0;;-1:-1:-1;;;;;;671:14:0;;;;;;;;695:22;;;;;;;;733:32;;843:11:8;;874:1;671:14:0;746:10;;733:32;;874:1:8;;733:32:0;780:40;;-1:-1:-1;;;;;780:40:0;;;797:10;;780:40;;;;;-1:-1:-1;;889:25:8::1;::::0;;;924:3:::1;:28:::0;;-1:-1:-1;;;;;;924:28:8::1;-1:-1:-1::0;;;;;924:28:8;::::1;::::0;;::::1;::::0;;;976:11:::1;::::0;;-1:-1:-1;;;976:11:8;;;;:9:::1;::::0;:11:::1;::::0;;::::1;::::0;::::1;::::0;;;;;;;;;924:28;976:11:::1;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1::0;;;;;962:26:8;;::::1;;::::0;;;998:44:::1;::::0;-1:-1:-1;;;998:44:8;;960:32:33;;;998:44:8::1;::::0;::::1;942:51:33::0;-1:-1:-1;;1009:18:33;;;1002:34;962:26:8;998:13:::1;::::0;915:18:33;;998:44:8::1;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;730:319:::0;;;272:1795;;14:177:33;93:13;;-1:-1:-1;;;;;135:31:33;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:354::-;284:6;292;300;353:2;341:9;332:7;328:23;324:32;321:52;;;369:1;366;359:12;321:52;392:40;422:9;392:40;:::i;:::-;382:50;;472:2;461:9;457:18;451:25;441:35;;495:49;540:2;529:9;525:18;495:49;:::i;:::-;485:59;;196:354;;;;;:::o;555:208::-;625:6;678:2;666:9;657:7;653:23;649:32;646:52;;;694:1;691;684:12;646:52;717:40;747:9;717:40;:::i;:::-;707:50;555:208;-1:-1:-1;;;555:208:33:o;1047:277::-;1114:6;1167:2;1155:9;1146:7;1142:23;1138:32;1135:52;;;1183:1;1180;1173:12;1135:52;1215:9;1209:16;1268:5;1261:13;1254:21;1247:5;1244:32;1234:60;;1290:1;1287;1280:12;1047:277;272:1795:8;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
        },
        "deployedBytecode": {
          "functionDebugData": {
            "@_efficientHash_1503": {
              "entryPoint": null,
              "id": 1503,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@_ve_1022": {
              "entryPoint": null,
              "id": 1022,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@aphra_1025": {
              "entryPoint": null,
              "id": 1025,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@authority_20": {
              "entryPoint": null,
              "id": 20,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@claim_1182": {
              "entryPoint": 631,
              "id": 1182,
              "parameterSlots": 4,
              "returnSlots": 0
            },
            "@hasClaimed_1030": {
              "entryPoint": null,
              "id": 1030,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@isAuthorized_103": {
              "entryPoint": 1610,
              "id": 103,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@merkleRoot_1019": {
              "entryPoint": null,
              "id": 1019,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@owner_17": {
              "entryPoint": null,
              "id": 17,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@processProof_1492": {
              "entryPoint": 1802,
              "id": 1492,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@setAuthority_139": {
              "entryPoint": 1118,
              "id": 139,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@setNewVe_1120": {
              "entryPoint": 1352,
              "id": 1120,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@setOwner_157": {
              "entryPoint": 470,
              "id": 157,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@verify_1435": {
              "entryPoint": 1780,
              "id": 1435,
              "parameterSlots": 3,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_address": {
              "entryPoint": 1942,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_addresst_uint256t_array$_t_bytes32_$dyn_calldata_ptr": {
              "entryPoint": 1978,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 4
            },
            "abi_decode_tuple_t_bool_fromMemory": {
              "entryPoint": 2188,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_contract$_Authority_$171": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_uint256_fromMemory": {
              "entryPoint": 2118,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_packed_t_address_t_uint256__to_t_address_t_uint256__nonPadded_inplace_fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 3,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_address__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_address_t_address_t_bytes4__to_t_address_t_address_t_bytes4__fromStack_reversed": {
              "entryPoint": 2143,
              "id": null,
              "parameterSlots": 4,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_address_t_uint256__to_t_address_t_uint256__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 3,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_contract$_Authority_$171__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_contract$_ERC20_$566__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_contract$_veAPHRA_$15196__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_stringliteral_269df367cd41cace5897a935d0e0858fe4543b5619d45e09af6b124c1bb3d528__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_uint256_t_uint256_t_address__to_t_uint256_t_uint256_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 4,
              "returnSlots": 1
            },
            "increment_t_uint256": {
              "entryPoint": 2244,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "panic_error_0x32": {
              "entryPoint": 2222,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "validator_revert_address": {
              "entryPoint": 1918,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nodeType": "YulBlock",
                "src": "0:5440:33",
                "statements": [
                  {
                    "nodeType": "YulBlock",
                    "src": "6:3:33",
                    "statements": []
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "59:86:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "123:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "132:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "135:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "125:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "125:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "125:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "82:5:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "93:5:33"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "108:3:33",
                                                "type": "",
                                                "value": "160"
                                              },
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "113:1:33",
                                                "type": "",
                                                "value": "1"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "shl",
                                              "nodeType": "YulIdentifier",
                                              "src": "104:3:33"
                                            },
                                            "nodeType": "YulFunctionCall",
                                            "src": "104:11:33"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "117:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "sub",
                                          "nodeType": "YulIdentifier",
                                          "src": "100:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "100:19:33"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "89:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "89:31:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "79:2:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "79:42:33"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "72:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "72:50:33"
                          },
                          "nodeType": "YulIf",
                          "src": "69:70:33"
                        }
                      ]
                    },
                    "name": "validator_revert_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "48:5:33",
                        "type": ""
                      }
                    ],
                    "src": "14:131:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "220:177:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "266:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "275:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "278:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "268:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "268:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "268:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "241:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "250:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "237:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "237:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "262:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "233:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "233:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "230:52:33"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "291:36:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "317:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "304:12:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "304:23:33"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "295:5:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "361:5:33"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_address",
                              "nodeType": "YulIdentifier",
                              "src": "336:24:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "336:31:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "336:31:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "376:15:33",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "386:5:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "376:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "186:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "197:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "209:6:33",
                        "type": ""
                      }
                    ],
                    "src": "150:247:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "503:76:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "513:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "525:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "536:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "521:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "521:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "513:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "555:9:33"
                              },
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "566:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "548:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "548:25:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "548:25:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "472:9:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "483:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "494:4:33",
                        "type": ""
                      }
                    ],
                    "src": "402:177:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "723:679:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "769:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "778:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "781:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "771:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "771:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "771:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "744:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "753:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "740:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "740:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "765:2:33",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "736:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "736:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "733:52:33"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "794:36:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "820:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "807:12:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "807:23:33"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "798:5:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "864:5:33"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_address",
                              "nodeType": "YulIdentifier",
                              "src": "839:24:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "839:31:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "839:31:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "879:15:33",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "889:5:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "879:6:33"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "903:42:33",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "930:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "941:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "926:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "926:18:33"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "913:12:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "913:32:33"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "903:6:33"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "954:46:33",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "985:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "996:2:33",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "981:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "981:18:33"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "968:12:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "968:32:33"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "958:6:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1009:28:33",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "1019:18:33",
                            "type": "",
                            "value": "0xffffffffffffffff"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "1013:2:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1064:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1073:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1076:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1066:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1066:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1066:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "1052:6:33"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "1060:2:33"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "1049:2:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1049:14:33"
                          },
                          "nodeType": "YulIf",
                          "src": "1046:34:33"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1089:32:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1103:9:33"
                              },
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "1114:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1099:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1099:22:33"
                          },
                          "variables": [
                            {
                              "name": "_2",
                              "nodeType": "YulTypedName",
                              "src": "1093:2:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1169:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1178:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1181:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1171:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1171:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1171:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "_2",
                                        "nodeType": "YulIdentifier",
                                        "src": "1148:2:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "1152:4:33",
                                        "type": "",
                                        "value": "0x1f"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "1144:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1144:13:33"
                                  },
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1159:7:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "slt",
                                  "nodeType": "YulIdentifier",
                                  "src": "1140:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1140:27:33"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "1133:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1133:35:33"
                          },
                          "nodeType": "YulIf",
                          "src": "1130:55:33"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1194:30:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "_2",
                                "nodeType": "YulIdentifier",
                                "src": "1221:2:33"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "1208:12:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1208:16:33"
                          },
                          "variables": [
                            {
                              "name": "length",
                              "nodeType": "YulTypedName",
                              "src": "1198:6:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1251:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1260:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1263:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1253:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1253:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1253:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "1239:6:33"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "1247:2:33"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "1236:2:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1236:14:33"
                          },
                          "nodeType": "YulIf",
                          "src": "1233:34:33"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1325:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1334:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1337:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1327:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1327:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1327:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "_2",
                                        "nodeType": "YulIdentifier",
                                        "src": "1290:2:33"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "1298:1:33",
                                            "type": "",
                                            "value": "5"
                                          },
                                          {
                                            "name": "length",
                                            "nodeType": "YulIdentifier",
                                            "src": "1301:6:33"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "1294:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "1294:14:33"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "1286:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1286:23:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "1311:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1282:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1282:32:33"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "1316:7:33"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "1279:2:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1279:45:33"
                          },
                          "nodeType": "YulIf",
                          "src": "1276:65:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1350:21:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "_2",
                                "nodeType": "YulIdentifier",
                                "src": "1364:2:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1368:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1360:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1360:11:33"
                          },
                          "variableNames": [
                            {
                              "name": "value2",
                              "nodeType": "YulIdentifier",
                              "src": "1350:6:33"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1380:16:33",
                          "value": {
                            "name": "length",
                            "nodeType": "YulIdentifier",
                            "src": "1390:6:33"
                          },
                          "variableNames": [
                            {
                              "name": "value3",
                              "nodeType": "YulIdentifier",
                              "src": "1380:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_addresst_uint256t_array$_t_bytes32_$dyn_calldata_ptr",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "665:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "676:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "688:6:33",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "696:6:33",
                        "type": ""
                      },
                      {
                        "name": "value2",
                        "nodeType": "YulTypedName",
                        "src": "704:6:33",
                        "type": ""
                      },
                      {
                        "name": "value3",
                        "nodeType": "YulTypedName",
                        "src": "712:6:33",
                        "type": ""
                      }
                    ],
                    "src": "584:818:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1521:102:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1531:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1543:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1554:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1539:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1539:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "1531:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1573:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "1588:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "1604:3:33",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "1609:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "1600:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "1600:11:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "1613:1:33",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "1596:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1596:19:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "1584:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1584:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1566:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1566:51:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1566:51:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_contract$_ERC20_$566__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1490:9:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1501:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "1512:4:33",
                        "type": ""
                      }
                    ],
                    "src": "1407:216:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1723:92:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1733:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1745:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1756:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1741:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1741:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "1733:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1775:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "value0",
                                        "nodeType": "YulIdentifier",
                                        "src": "1800:6:33"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "iszero",
                                      "nodeType": "YulIdentifier",
                                      "src": "1793:6:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1793:14:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "iszero",
                                  "nodeType": "YulIdentifier",
                                  "src": "1786:6:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1786:22:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1768:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1768:41:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1768:41:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1692:9:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1703:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "1714:4:33",
                        "type": ""
                      }
                    ],
                    "src": "1628:187:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1907:177:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1953:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1962:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1965:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1955:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1955:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1955:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1928:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1937:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "1924:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1924:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1949:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "1920:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1920:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "1917:52:33"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1978:36:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2004:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "1991:12:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1991:23:33"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "1982:5:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "2048:5:33"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_address",
                              "nodeType": "YulIdentifier",
                              "src": "2023:24:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2023:31:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2023:31:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2063:15:33",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "2073:5:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "2063:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_contract$_Authority_$171",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1873:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "1884:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1896:6:33",
                        "type": ""
                      }
                    ],
                    "src": "1820:264:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2190:102:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "2200:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2212:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2223:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2208:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2208:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "2200:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2242:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "2257:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2273:3:33",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2278:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "2269:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "2269:11:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "2282:1:33",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "2265:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2265:19:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "2253:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2253:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2235:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2235:51:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2235:51:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2159:9:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2170:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "2181:4:33",
                        "type": ""
                      }
                    ],
                    "src": "2089:203:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2415:102:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "2425:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2437:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2448:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2433:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2433:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "2425:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2467:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "2482:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2498:3:33",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2503:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "2494:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "2494:11:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "2507:1:33",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "2490:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2490:19:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "2478:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2478:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2460:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2460:51:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2460:51:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_contract$_veAPHRA_$15196__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2384:9:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2395:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "2406:4:33",
                        "type": ""
                      }
                    ],
                    "src": "2297:220:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2640:102:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "2650:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2662:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2673:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2658:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2658:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "2650:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2692:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "2707:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2723:3:33",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2728:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "2719:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "2719:11:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "2732:1:33",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "2715:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2715:19:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "2703:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2703:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2685:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2685:51:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2685:51:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_contract$_Authority_$171__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2609:9:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2620:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "2631:4:33",
                        "type": ""
                      }
                    ],
                    "src": "2522:220:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2921:162:33",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2938:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2949:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2931:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2931:21:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2931:21:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2972:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2983:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2968:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2968:18:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2988:2:33",
                                "type": "",
                                "value": "12"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2961:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2961:30:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2961:30:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3011:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3022:2:33",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3007:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3007:18:33"
                              },
                              {
                                "hexValue": "554e415554484f52495a4544",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "3027:14:33",
                                "type": "",
                                "value": "UNAUTHORIZED"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3000:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3000:42:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3000:42:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3051:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3063:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3074:2:33",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "3059:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3059:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "3051:4:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_stringliteral_269df367cd41cace5897a935d0e0858fe4543b5619d45e09af6b124c1bb3d528__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2898:9:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "2912:4:33",
                        "type": ""
                      }
                    ],
                    "src": "2747:336:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3235:147:33",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "3252:3:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "3265:2:33",
                                        "type": "",
                                        "value": "96"
                                      },
                                      {
                                        "name": "value0",
                                        "nodeType": "YulIdentifier",
                                        "src": "3269:6:33"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "shl",
                                      "nodeType": "YulIdentifier",
                                      "src": "3261:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "3261:15:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "3282:26:33",
                                        "type": "",
                                        "value": "0xffffffffffffffffffffffff"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "not",
                                      "nodeType": "YulIdentifier",
                                      "src": "3278:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "3278:31:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "3257:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3257:53:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3245:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3245:66:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3245:66:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "pos",
                                    "nodeType": "YulIdentifier",
                                    "src": "3331:3:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3336:2:33",
                                    "type": "",
                                    "value": "20"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3327:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3327:12:33"
                              },
                              {
                                "name": "value1",
                                "nodeType": "YulIdentifier",
                                "src": "3341:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3320:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3320:28:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3320:28:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3357:19:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "3368:3:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3373:2:33",
                                "type": "",
                                "value": "52"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "3364:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3364:12:33"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "3357:3:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_packed_t_address_t_uint256__to_t_address_t_uint256__nonPadded_inplace_fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "3203:3:33",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "3208:6:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "3216:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "3227:3:33",
                        "type": ""
                      }
                    ],
                    "src": "3088:294:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3544:188:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "3554:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3566:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3577:2:33",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "3562:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3562:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "3554:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3596:9:33"
                              },
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "3607:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3589:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3589:25:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3589:25:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3634:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3645:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3630:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3630:18:33"
                              },
                              {
                                "name": "value1",
                                "nodeType": "YulIdentifier",
                                "src": "3650:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3623:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3623:34:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3623:34:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3677:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3688:2:33",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3673:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3673:18:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value2",
                                    "nodeType": "YulIdentifier",
                                    "src": "3697:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "3713:3:33",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "3718:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "3709:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "3709:11:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "3722:1:33",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "3705:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "3705:19:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "3693:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3693:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3666:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3666:60:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3666:60:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_uint256_t_uint256_t_address__to_t_uint256_t_uint256_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "3497:9:33",
                        "type": ""
                      },
                      {
                        "name": "value2",
                        "nodeType": "YulTypedName",
                        "src": "3508:6:33",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "3516:6:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "3524:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "3535:4:33",
                        "type": ""
                      }
                    ],
                    "src": "3387:345:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3818:103:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3864:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3873:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3876:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "3866:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3866:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3866:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "3839:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3848:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "3835:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3835:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3860:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "3831:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3831:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "3828:52:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3889:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3905:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "3899:5:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3899:16:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "3889:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_uint256_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "3784:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "3795:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "3807:6:33",
                        "type": ""
                      }
                    ],
                    "src": "3737:184:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4027:76:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4037:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4049:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4060:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "4045:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4045:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "4037:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4079:9:33"
                              },
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "4090:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4072:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4072:25:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4072:25:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "3996:9:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "4007:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "4018:4:33",
                        "type": ""
                      }
                    ],
                    "src": "3926:177:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4263:245:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4273:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4285:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4296:2:33",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "4281:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4281:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "4273:4:33"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "4308:29:33",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4326:3:33",
                                    "type": "",
                                    "value": "160"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4331:1:33",
                                    "type": "",
                                    "value": "1"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "4322:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4322:11:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4335:1:33",
                                "type": "",
                                "value": "1"
                              }
                            ],
                            "functionName": {
                              "name": "sub",
                              "nodeType": "YulIdentifier",
                              "src": "4318:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4318:19:33"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "4312:2:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4353:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "4368:6:33"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "4376:2:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "4364:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4364:15:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4346:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4346:34:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4346:34:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4400:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4411:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4396:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4396:18:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value1",
                                    "nodeType": "YulIdentifier",
                                    "src": "4420:6:33"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "4428:2:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "4416:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4416:15:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4389:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4389:43:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4389:43:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4452:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4463:2:33",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4448:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4448:18:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value2",
                                    "nodeType": "YulIdentifier",
                                    "src": "4472:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "4484:3:33",
                                        "type": "",
                                        "value": "224"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "4489:10:33",
                                        "type": "",
                                        "value": "0xffffffff"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "shl",
                                      "nodeType": "YulIdentifier",
                                      "src": "4480:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "4480:20:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "4468:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4468:33:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4441:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4441:61:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4441:61:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address_t_address_t_bytes4__to_t_address_t_address_t_bytes4__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4216:9:33",
                        "type": ""
                      },
                      {
                        "name": "value2",
                        "nodeType": "YulTypedName",
                        "src": "4227:6:33",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "4235:6:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "4243:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "4254:4:33",
                        "type": ""
                      }
                    ],
                    "src": "4108:400:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4591:199:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4637:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4646:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4649:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "4639:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4639:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4639:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "4612:7:33"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4621:9:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "4608:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4608:23:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4633:2:33",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "4604:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4604:32:33"
                          },
                          "nodeType": "YulIf",
                          "src": "4601:52:33"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "4662:29:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4681:9:33"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "4675:5:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4675:16:33"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "4666:5:33",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4744:16:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4753:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4756:1:33",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "4746:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4746:12:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4746:12:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "4713:5:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "name": "value",
                                            "nodeType": "YulIdentifier",
                                            "src": "4734:5:33"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "iszero",
                                          "nodeType": "YulIdentifier",
                                          "src": "4727:6:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "4727:13:33"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "iszero",
                                      "nodeType": "YulIdentifier",
                                      "src": "4720:6:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "4720:21:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "4710:2:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4710:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "4703:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4703:40:33"
                          },
                          "nodeType": "YulIf",
                          "src": "4700:60:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "4769:15:33",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "4779:5:33"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "4769:6:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_bool_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4557:9:33",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "4568:7:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "4580:6:33",
                        "type": ""
                      }
                    ],
                    "src": "4513:277:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4924:145:33",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4934:26:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4946:9:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4957:2:33",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "4942:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4942:18:33"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "4934:4:33"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4976:9:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "4991:6:33"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "5007:3:33",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "5012:1:33",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "5003:3:33"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "5003:11:33"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "5016:1:33",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "4999:3:33"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "4999:19:33"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "4987:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4987:32:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4969:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4969:51:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4969:51:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "5040:9:33"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5051:2:33",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "5036:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5036:18:33"
                              },
                              {
                                "name": "value1",
                                "nodeType": "YulIdentifier",
                                "src": "5056:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5029:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5029:34:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5029:34:33"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address_t_uint256__to_t_address_t_uint256__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4885:9:33",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "4896:6:33",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "4904:6:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "4915:4:33",
                        "type": ""
                      }
                    ],
                    "src": "4795:274:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5106:95:33",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5123:1:33",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5130:3:33",
                                    "type": "",
                                    "value": "224"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5135:10:33",
                                    "type": "",
                                    "value": "0x4e487b71"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "5126:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5126:20:33"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5116:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5116:31:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5116:31:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5163:1:33",
                                "type": "",
                                "value": "4"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5166:4:33",
                                "type": "",
                                "value": "0x32"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5156:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5156:15:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5156:15:33"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5187:1:33",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5190:4:33",
                                "type": "",
                                "value": "0x24"
                              }
                            ],
                            "functionName": {
                              "name": "revert",
                              "nodeType": "YulIdentifier",
                              "src": "5180:6:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5180:15:33"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5180:15:33"
                        }
                      ]
                    },
                    "name": "panic_error_0x32",
                    "nodeType": "YulFunctionDefinition",
                    "src": "5074:127:33"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5253:185:33",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5292:111:33",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5313:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "5320:3:33",
                                          "type": "",
                                          "value": "224"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "5325:10:33",
                                          "type": "",
                                          "value": "0x4e487b71"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "shl",
                                        "nodeType": "YulIdentifier",
                                        "src": "5316:3:33"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "5316:20:33"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "5306:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5306:31:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "5306:31:33"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5357:1:33",
                                      "type": "",
                                      "value": "4"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5360:4:33",
                                      "type": "",
                                      "value": "0x11"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "5350:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5350:15:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "5350:15:33"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5385:1:33",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5388:4:33",
                                      "type": "",
                                      "value": "0x24"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "5378:6:33"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5378:15:33"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "5378:15:33"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "5269:5:33"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5280:1:33",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "not",
                                  "nodeType": "YulIdentifier",
                                  "src": "5276:3:33"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5276:6:33"
                              }
                            ],
                            "functionName": {
                              "name": "eq",
                              "nodeType": "YulIdentifier",
                              "src": "5266:2:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5266:17:33"
                          },
                          "nodeType": "YulIf",
                          "src": "5263:140:33"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5412:20:33",
                          "value": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "5423:5:33"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5430:1:33",
                                "type": "",
                                "value": "1"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "5419:3:33"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5419:13:33"
                          },
                          "variableNames": [
                            {
                              "name": "ret",
                              "nodeType": "YulIdentifier",
                              "src": "5412:3:33"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "increment_t_uint256",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "5235:5:33",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "ret",
                        "nodeType": "YulTypedName",
                        "src": "5245:3:33",
                        "type": ""
                      }
                    ],
                    "src": "5206:232:33"
                  }
                ]
              },
              "contents": "{\n    { }\n    function validator_revert_address(value)\n    {\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_address(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_address(value)\n        value0 := value\n    }\n    function abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n    function abi_decode_tuple_t_addresst_uint256t_array$_t_bytes32_$dyn_calldata_ptr(headStart, dataEnd) -> value0, value1, value2, value3\n    {\n        if slt(sub(dataEnd, headStart), 96) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_address(value)\n        value0 := value\n        value1 := calldataload(add(headStart, 32))\n        let offset := calldataload(add(headStart, 64))\n        let _1 := 0xffffffffffffffff\n        if gt(offset, _1) { revert(0, 0) }\n        let _2 := add(headStart, offset)\n        if iszero(slt(add(_2, 0x1f), dataEnd)) { revert(0, 0) }\n        let length := calldataload(_2)\n        if gt(length, _1) { revert(0, 0) }\n        if gt(add(add(_2, shl(5, length)), 32), dataEnd) { revert(0, 0) }\n        value2 := add(_2, 32)\n        value3 := length\n    }\n    function abi_encode_tuple_t_contract$_ERC20_$566__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, iszero(iszero(value0)))\n    }\n    function abi_decode_tuple_t_contract$_Authority_$171(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_address(value)\n        value0 := value\n    }\n    function abi_encode_tuple_t_address__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_encode_tuple_t_contract$_veAPHRA_$15196__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_encode_tuple_t_contract$_Authority_$171__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_encode_tuple_t_stringliteral_269df367cd41cace5897a935d0e0858fe4543b5619d45e09af6b124c1bb3d528__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        mstore(headStart, 32)\n        mstore(add(headStart, 32), 12)\n        mstore(add(headStart, 64), \"UNAUTHORIZED\")\n        tail := add(headStart, 96)\n    }\n    function abi_encode_tuple_packed_t_address_t_uint256__to_t_address_t_uint256__nonPadded_inplace_fromStack_reversed(pos, value1, value0) -> end\n    {\n        mstore(pos, and(shl(96, value0), not(0xffffffffffffffffffffffff)))\n        mstore(add(pos, 20), value1)\n        end := add(pos, 52)\n    }\n    function abi_encode_tuple_t_uint256_t_uint256_t_address__to_t_uint256_t_uint256_t_address__fromStack_reversed(headStart, value2, value1, value0) -> tail\n    {\n        tail := add(headStart, 96)\n        mstore(headStart, value0)\n        mstore(add(headStart, 32), value1)\n        mstore(add(headStart, 64), and(value2, sub(shl(160, 1), 1)))\n    }\n    function abi_decode_tuple_t_uint256_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        value0 := mload(headStart)\n    }\n    function abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n    function abi_encode_tuple_t_address_t_address_t_bytes4__to_t_address_t_address_t_bytes4__fromStack_reversed(headStart, value2, value1, value0) -> tail\n    {\n        tail := add(headStart, 96)\n        let _1 := sub(shl(160, 1), 1)\n        mstore(headStart, and(value0, _1))\n        mstore(add(headStart, 32), and(value1, _1))\n        mstore(add(headStart, 64), and(value2, shl(224, 0xffffffff)))\n    }\n    function abi_decode_tuple_t_bool_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := mload(headStart)\n        if iszero(eq(value, iszero(iszero(value)))) { revert(0, 0) }\n        value0 := value\n    }\n    function abi_encode_tuple_t_address_t_uint256__to_t_address_t_uint256__fromStack_reversed(headStart, value1, value0) -> tail\n    {\n        tail := add(headStart, 64)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n        mstore(add(headStart, 32), value1)\n    }\n    function panic_error_0x32()\n    {\n        mstore(0, shl(224, 0x4e487b71))\n        mstore(4, 0x32)\n        revert(0, 0x24)\n    }\n    function increment_t_uint256(value) -> ret\n    {\n        if eq(value, not(0))\n        {\n            mstore(0, shl(224, 0x4e487b71))\n            mstore(4, 0x11)\n            revert(0, 0x24)\n        }\n        ret := add(value, 1)\n    }\n}",
              "id": 33,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "immutableReferences": {
            "1019": [
              {
                "length": 32,
                "start": 189
              },
              {
                "length": 32,
                "start": 809
              }
            ],
            "1025": [
              {
                "length": 32,
                "start": 266
              },
              {
                "length": 32,
                "start": 1495
              }
            ]
          },
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b506004361061009e5760003560e01c80637a9e5e4b116100665780637a9e5e4b146101775780638da5cb5b1461018a5780638dd598fb1461019d578063bf7e214f146101b0578063d4fc9e9b146101c357600080fd5b806313af4035146100a35780632eb4a7ab146100b85780633d13f874146100f25780634732977c1461010557806373b2e80e14610144575b600080fd5b6100b66100b1366004610796565b6101d6565b005b6100df7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100b66101003660046107ba565b610277565b61012c7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e9565b610167610152366004610796565b60036020526000908152604090205460ff1681565b60405190151581526020016100e9565b6100b6610185366004610796565b61045e565b60005461012c906001600160a01b031681565b60025461012c906001600160a01b031681565b60015461012c906001600160a01b031681565b6100b66101d1366004610796565b610548565b6101ec336000356001600160e01b03191661064a565b61022c5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b60448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6001600160a01b03841660009081526003602052604090205460ff16156102b157604051630c8d9eab60e31b815260040160405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006103548484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f000000000000000000000000000000000000000000000000000000000000000092508691506106f49050565b9050806103745760405163452c2df160e11b815260040160405180910390fd5b6001600160a01b0386811660008181526003602052604090819020805460ff19166001179055600254905163d4e54c3b60e01b8152600481018990526303c26700602482015260448101929092529091169063d4e54c3b906064016020604051808303816000875af11580156103ee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104129190610846565b50856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161044e91815260200190565b60405180910390a2505050505050565b6000546001600160a01b03163314806104f3575060015460405163b700961360e01b81526001600160a01b039091169063b7009613906104b290339030906001600160e01b0319600035169060040161085f565b602060405180830381865afa1580156104cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f3919061088c565b6104fc57600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b61055e336000356001600160e01b03191661064a565b6105995760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610223565b600280546001600160a01b0319166001600160a01b0383811691821790925560405163095ea7b360e01b8152600481019190915260001960248201527f00000000000000000000000000000000000000000000000000000000000000009091169063095ea7b3906044016020604051808303816000875af1158015610622573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610646919061088c565b5050565b6001546000906001600160a01b031680158015906106d4575060405163b700961360e01b81526001600160a01b0382169063b7009613906106939087903090889060040161085f565b602060405180830381865afa1580156106b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d4919061088c565b806106ec57506000546001600160a01b038581169116145b949350505050565b600082610701858461070a565b14949350505050565b600081815b845181101561077657600085828151811061072c5761072c6108ae565b602002602001015190508083116107525760008381526020829052604090209250610763565b600081815260208490526040902092505b508061076e816108c4565b91505061070f565b509392505050565b6001600160a01b038116811461079357600080fd5b50565b6000602082840312156107a857600080fd5b81356107b38161077e565b9392505050565b600080600080606085870312156107d057600080fd5b84356107db8161077e565b935060208501359250604085013567ffffffffffffffff808211156107ff57600080fd5b818701915087601f83011261081357600080fd5b81358181111561082257600080fd5b8860208260051b850101111561083757600080fd5b95989497505060200194505050565b60006020828403121561085857600080fd5b5051919050565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561089e57600080fd5b815180151581146107b357600080fd5b634e487b7160e01b600052603260045260246000fd5b60006000198214156108e657634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220a2441b2b59bbf334515989f62a464e9cd66f423ffbb277380b7e3fb1c1e8cdb764736f6c634300080b0033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x9E JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x7A9E5E4B GT PUSH2 0x66 JUMPI DUP1 PUSH4 0x7A9E5E4B EQ PUSH2 0x177 JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x18A JUMPI DUP1 PUSH4 0x8DD598FB EQ PUSH2 0x19D JUMPI DUP1 PUSH4 0xBF7E214F EQ PUSH2 0x1B0 JUMPI DUP1 PUSH4 0xD4FC9E9B EQ PUSH2 0x1C3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x13AF4035 EQ PUSH2 0xA3 JUMPI DUP1 PUSH4 0x2EB4A7AB EQ PUSH2 0xB8 JUMPI DUP1 PUSH4 0x3D13F874 EQ PUSH2 0xF2 JUMPI DUP1 PUSH4 0x4732977C EQ PUSH2 0x105 JUMPI DUP1 PUSH4 0x73B2E80E EQ PUSH2 0x144 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xB6 PUSH2 0xB1 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH2 0x1D6 JUMP JUMPDEST STOP JUMPDEST PUSH2 0xDF PUSH32 0x0 DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xB6 PUSH2 0x100 CALLDATASIZE PUSH1 0x4 PUSH2 0x7BA JUMP JUMPDEST PUSH2 0x277 JUMP JUMPDEST PUSH2 0x12C PUSH32 0x0 DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xE9 JUMP JUMPDEST PUSH2 0x167 PUSH2 0x152 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH1 0x3 PUSH1 0x20 MSTORE PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD PUSH1 0xFF AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 ISZERO ISZERO DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xE9 JUMP JUMPDEST PUSH2 0xB6 PUSH2 0x185 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH2 0x45E JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH2 0x12C SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x2 SLOAD PUSH2 0x12C SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH2 0x12C SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH2 0xB6 PUSH2 0x1D1 CALLDATASIZE PUSH1 0x4 PUSH2 0x796 JUMP JUMPDEST PUSH2 0x548 JUMP JUMPDEST PUSH2 0x1EC CALLER PUSH1 0x0 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT AND PUSH2 0x64A JUMP JUMPDEST PUSH2 0x22C JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xC PUSH1 0x24 DUP3 ADD MSTORE PUSH12 0x15539055551213D492569151 PUSH1 0xA2 SHL PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR DUP3 SSTORE PUSH1 0x40 MLOAD SWAP1 SWAP2 CALLER SWAP2 PUSH32 0x8292FCE18FA69EDF4DB7B94EA2E58241DF0AE57F97E0A6C9B29067028BF92D76 SWAP2 SWAP1 LOG3 POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x3 PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD PUSH1 0xFF AND ISZERO PUSH2 0x2B1 JUMPI PUSH1 0x40 MLOAD PUSH4 0xC8D9EAB PUSH1 0xE3 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x40 MLOAD PUSH12 0xFFFFFFFFFFFFFFFFFFFFFFFF NOT PUSH1 0x60 DUP7 SWAP1 SHL AND PUSH1 0x20 DUP3 ADD MSTORE PUSH1 0x34 DUP2 ADD DUP5 SWAP1 MSTORE PUSH1 0x0 SWAP1 PUSH1 0x54 ADD PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE DUP1 MLOAD SWAP1 PUSH1 0x20 ADD KECCAK256 SWAP1 POP PUSH1 0x0 PUSH2 0x354 DUP5 DUP5 DUP1 DUP1 PUSH1 0x20 MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 PUSH1 0x20 MUL DUP1 DUP3 DUP5 CALLDATACOPY PUSH1 0x0 SWAP3 ADD SWAP2 SWAP1 SWAP2 MSTORE POP PUSH32 0x0 SWAP3 POP DUP7 SWAP2 POP PUSH2 0x6F4 SWAP1 POP JUMP JUMPDEST SWAP1 POP DUP1 PUSH2 0x374 JUMPI PUSH1 0x40 MLOAD PUSH4 0x452C2DF1 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP7 DUP2 AND PUSH1 0x0 DUP2 DUP2 MSTORE PUSH1 0x3 PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 DUP2 SWAP1 KECCAK256 DUP1 SLOAD PUSH1 0xFF NOT AND PUSH1 0x1 OR SWAP1 SSTORE PUSH1 0x2 SLOAD SWAP1 MLOAD PUSH4 0xD4E54C3B PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP10 SWAP1 MSTORE PUSH4 0x3C26700 PUSH1 0x24 DUP3 ADD MSTORE PUSH1 0x44 DUP2 ADD SWAP3 SWAP1 SWAP3 MSTORE SWAP1 SWAP2 AND SWAP1 PUSH4 0xD4E54C3B SWAP1 PUSH1 0x64 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH2 0x3EE JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x412 SWAP2 SWAP1 PUSH2 0x846 JUMP JUMPDEST POP DUP6 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH32 0x47CEE97CB7ACD717B3C0AA1435D004CD5B3C8C57D70DBCEB4E4458BBD60E39D4 DUP7 PUSH1 0x40 MLOAD PUSH2 0x44E SWAP2 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG2 POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ DUP1 PUSH2 0x4F3 JUMPI POP PUSH1 0x1 SLOAD PUSH1 0x40 MLOAD PUSH4 0xB7009613 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND SWAP1 PUSH4 0xB7009613 SWAP1 PUSH2 0x4B2 SWAP1 CALLER SWAP1 ADDRESS SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT PUSH1 0x0 CALLDATALOAD AND SWAP1 PUSH1 0x4 ADD PUSH2 0x85F JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x4CF JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x4F3 SWAP2 SWAP1 PUSH2 0x88C JUMP JUMPDEST PUSH2 0x4FC JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 DUP2 OR SWAP1 SWAP2 SSTORE PUSH1 0x40 MLOAD CALLER SWAP1 PUSH32 0xA3396FD7F6E0A21B50E5089D2DA70D5AC0A3BBBD1F617A93F134B76389980198 SWAP1 PUSH1 0x0 SWAP1 LOG3 POP JUMP JUMPDEST PUSH2 0x55E CALLER PUSH1 0x0 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT AND PUSH2 0x64A JUMP JUMPDEST PUSH2 0x599 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0xC PUSH1 0x24 DUP3 ADD MSTORE PUSH12 0x15539055551213D492569151 PUSH1 0xA2 SHL PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x223 JUMP JUMPDEST PUSH1 0x2 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND SWAP2 DUP3 OR SWAP1 SWAP3 SSTORE PUSH1 0x40 MLOAD PUSH4 0x95EA7B3 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH1 0x0 NOT PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x0 SWAP1 SWAP2 AND SWAP1 PUSH4 0x95EA7B3 SWAP1 PUSH1 0x44 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH2 0x622 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x646 SWAP2 SWAP1 PUSH2 0x88C JUMP JUMPDEST POP POP JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH1 0x0 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP1 ISZERO DUP1 ISZERO SWAP1 PUSH2 0x6D4 JUMPI POP PUSH1 0x40 MLOAD PUSH4 0xB7009613 PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND SWAP1 PUSH4 0xB7009613 SWAP1 PUSH2 0x693 SWAP1 DUP8 SWAP1 ADDRESS SWAP1 DUP9 SWAP1 PUSH1 0x4 ADD PUSH2 0x85F JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x6B0 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x6D4 SWAP2 SWAP1 PUSH2 0x88C JUMP JUMPDEST DUP1 PUSH2 0x6EC JUMPI POP PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP6 DUP2 AND SWAP2 AND EQ JUMPDEST SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH2 0x701 DUP6 DUP5 PUSH2 0x70A JUMP JUMPDEST EQ SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 DUP2 JUMPDEST DUP5 MLOAD DUP2 LT ISZERO PUSH2 0x776 JUMPI PUSH1 0x0 DUP6 DUP3 DUP2 MLOAD DUP2 LT PUSH2 0x72C JUMPI PUSH2 0x72C PUSH2 0x8AE JUMP JUMPDEST PUSH1 0x20 MUL PUSH1 0x20 ADD ADD MLOAD SWAP1 POP DUP1 DUP4 GT PUSH2 0x752 JUMPI PUSH1 0x0 DUP4 DUP2 MSTORE PUSH1 0x20 DUP3 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SWAP3 POP PUSH2 0x763 JUMP JUMPDEST PUSH1 0x0 DUP2 DUP2 MSTORE PUSH1 0x20 DUP5 SWAP1 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SWAP3 POP JUMPDEST POP DUP1 PUSH2 0x76E DUP2 PUSH2 0x8C4 JUMP JUMPDEST SWAP2 POP POP PUSH2 0x70F JUMP JUMPDEST POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x793 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x7A8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH2 0x7B3 DUP2 PUSH2 0x77E JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0x60 DUP6 DUP8 SUB SLT ISZERO PUSH2 0x7D0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP5 CALLDATALOAD PUSH2 0x7DB DUP2 PUSH2 0x77E JUMP JUMPDEST SWAP4 POP PUSH1 0x20 DUP6 ADD CALLDATALOAD SWAP3 POP PUSH1 0x40 DUP6 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x7FF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP8 ADD SWAP2 POP DUP8 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x813 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0x822 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP9 PUSH1 0x20 DUP3 PUSH1 0x5 SHL DUP6 ADD ADD GT ISZERO PUSH2 0x837 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP6 SWAP9 SWAP5 SWAP8 POP POP PUSH1 0x20 ADD SWAP5 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x858 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP MLOAD SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP4 DUP5 AND DUP2 MSTORE SWAP2 SWAP1 SWAP3 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT SWAP1 SWAP2 AND PUSH1 0x40 DUP3 ADD MSTORE PUSH1 0x60 ADD SWAP1 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x89E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD DUP1 ISZERO ISZERO DUP2 EQ PUSH2 0x7B3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x32 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x0 NOT DUP3 EQ ISZERO PUSH2 0x8E6 JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST POP PUSH1 0x1 ADD SWAP1 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 LOG2 DIFFICULTY SHL 0x2B MSIZE 0xBB RETURN CALLVALUE MLOAD MSIZE DUP10 0xF6 0x2A CHAINID 0x4E SWAP13 0xD6 PUSH16 0x423FFBB277380B7E3FB1C1E8CDB76473 PUSH16 0x6C634300080B00330000000000000000 ",
          "sourceMap": "272:1795:8:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1936:147:0;;;;;;:::i;:::-;;:::i;:::-;;362:35:8;;;;;;;;548:25:33;;;536:2;521:18;362:35:8;;;;;;;;1341:724;;;;;;:::i;:::-;;:::i;428:28::-;;;;;;;;-1:-1:-1;;;;;1584:32:33;;;1566:51;;1554:2;1539:18;428:28:8;1407:216:33;514:42:8;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;1793:14:33;;1786:22;1768:41;;1756:2;1741:18;514:42:8;1628:187:33;1496:434:0;;;;;;:::i;:::-;;:::i;551:20::-;;;;;-1:-1:-1;;;;;551:20:0;;;404:18:8;;;;;-1:-1:-1;;;;;404:18:8;;;578:26:0;;;;;-1:-1:-1;;;;;578:26:0;;;1173:162:8;;;;;;:::i;:::-;;:::i;1936:147:0:-;875:33;888:10;900:7;;-1:-1:-1;;;;;;900:7:0;875:12;:33::i;:::-;867:58;;;;-1:-1:-1;;;867:58:0;;2949:2:33;867:58:0;;;2931:21:33;2988:2;2968:18;;;2961:30;-1:-1:-1;;;3007:18:33;;;3000:42;3059:18;;867:58:0;;;;;;;;;2010:5:::1;:16:::0;;-1:-1:-1;;;;;;2010:16:0::1;-1:-1:-1::0;;;;;2010:16:0;::::1;::::0;;::::1;::::0;;2042:34:::1;::::0;2010:16;;2055:10:::1;::::0;2042:34:::1;::::0;2010:5;2042:34:::1;1936:147:::0;:::o;1341:724:8:-;-1:-1:-1;;;;;1488:14:8;;;;;;:10;:14;;;;;;;;1484:43;;;1511:16;;-1:-1:-1;;;1511:16:8;;;;;;;;;;;1484:43;1620:28;;-1:-1:-1;;3265:2:33;3261:15;;;3257:53;1620:28:8;;;3245:66:33;3327:12;;;3320:28;;;1595:12:8;;3364::33;;1620:28:8;;;;;;;;;;;;1610:39;;;;;;1595:54;;1659:16;1678:43;1697:5;;1678:43;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1704:10:8;;-1:-1:-1;1716:4:8;;-1:-1:-1;1678:18:8;;-1:-1:-1;1678:43:8:i;:::-;1659:62;;1736:11;1731:38;;1756:13;;-1:-1:-1;;;1756:13:8;;;;;;;;;;;1731:38;-1:-1:-1;;;;;1814:14:8;;;;;;;:10;:14;;;;;;;:21;;-1:-1:-1;;1814:21:8;1831:4;1814:21;;;1952:3;;:45;;-1:-1:-1;;;1952:45:8;;;;;3589:25:33;;;708:15:8;3630:18:33;;;3623:34;3673:18;;;3666:60;;;;1952:3:8;;;;:19;;3562:18:33;;1952:45:8;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;2047:2;-1:-1:-1;;;;;2041:17:8;;2051:6;2041:17;;;;548:25:33;;536:2;521:18;;402:177;2041:17:8;;;;;;;;1419:646;;1341:724;;;;:::o;1496:434:0:-;1767:5;;-1:-1:-1;;;;;1767:5:0;1753:10;:19;;:76;;-1:-1:-1;1776:9:0;;:53;;-1:-1:-1;;;1776:53:0;;-1:-1:-1;;;;;1776:9:0;;;;:17;;:53;;1794:10;;1814:4;;-1:-1:-1;;;;;;1776:9:0;1821:7;;;1776:53;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1745:85;;;;;;1841:9;:24;;-1:-1:-1;;;;;;1841:24:0;-1:-1:-1;;;;;1841:24:0;;;;;;;;1881:42;;1898:10;;1881:42;;-1:-1:-1;;1881:42:0;1496:434;:::o;1173:162:8:-;875:33:0;888:10;900:7;;-1:-1:-1;;;;;;900:7:0;875:12;:33::i;:::-;867:58;;;;-1:-1:-1;;;867:58:0;;2949:2:33;867:58:0;;;2931:21:33;2988:2;2968:18;;;2961:30;-1:-1:-1;;;3007:18:33;;;3000:42;3059:18;;867:58:0;2747:336:33;867:58:0;1246:3:8::1;:28:::0;;-1:-1:-1;;;;;;1246:28:8::1;-1:-1:-1::0;;;;;1246:28:8;;::::1;::::0;;::::1;::::0;;;1284:44:::1;::::0;-1:-1:-1;;;1284:44:8;;::::1;::::0;::::1;4969:51:33::0;;;;-1:-1:-1;;5036:18:33;;;5029:34;1284:5:8::1;:13:::0;;::::1;::::0;::::1;::::0;4942:18:33;;1284:44:8::1;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;1173:162:::0;:::o;950:540:0:-;1070:9;;1037:4;;-1:-1:-1;;;;;1070:9:0;1388:27;;;;;:77;;-1:-1:-1;1419:46:0;;-1:-1:-1;;;1419:46:0;;-1:-1:-1;;;;;1419:12:0;;;;;:46;;1432:4;;1446;;1453:11;;1419:46;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1387:96;;;-1:-1:-1;1478:5:0;;-1:-1:-1;;;;;1470:13:0;;;1478:5;;1470:13;1387:96;1380:103;950:540;-1:-1:-1;;;;950:540:0:o;847:184:11:-;968:4;1020;991:25;1004:5;1011:4;991:12;:25::i;:::-;:33;;847:184;-1:-1:-1;;;;847:184:11:o;1383:662::-;1466:7;1508:4;1466:7;1522:488;1546:5;:12;1542:1;:16;1522:488;;;1579:20;1602:5;1608:1;1602:8;;;;;;;;:::i;:::-;;;;;;;1579:31;;1644:12;1628;:28;1624:376;;2119:13;2167:15;;;2202:4;2195:15;;;2248:4;2232:21;;1754:57;;1624:376;;;2119:13;2167:15;;;2202:4;2195:15;;;2248:4;2232:21;;1928:57;;1624:376;-1:-1:-1;1560:3:11;;;;:::i;:::-;;;;1522:488;;;-1:-1:-1;2026:12:11;1383:662;-1:-1:-1;;;1383:662:11:o;14:131:33:-;-1:-1:-1;;;;;89:31:33;;79:42;;69:70;;135:1;132;125:12;69:70;14:131;:::o;150:247::-;209:6;262:2;250:9;241:7;237:23;233:32;230:52;;;278:1;275;268:12;230:52;317:9;304:23;336:31;361:5;336:31;:::i;:::-;386:5;150:247;-1:-1:-1;;;150:247:33:o;584:818::-;688:6;696;704;712;765:2;753:9;744:7;740:23;736:32;733:52;;;781:1;778;771:12;733:52;820:9;807:23;839:31;864:5;839:31;:::i;:::-;889:5;-1:-1:-1;941:2:33;926:18;;913:32;;-1:-1:-1;996:2:33;981:18;;968:32;1019:18;1049:14;;;1046:34;;;1076:1;1073;1066:12;1046:34;1114:6;1103:9;1099:22;1089:32;;1159:7;1152:4;1148:2;1144:13;1140:27;1130:55;;1181:1;1178;1171:12;1130:55;1221:2;1208:16;1247:2;1239:6;1236:14;1233:34;;;1263:1;1260;1253:12;1233:34;1316:7;1311:2;1301:6;1298:1;1294:14;1290:2;1286:23;1282:32;1279:45;1276:65;;;1337:1;1334;1327:12;1276:65;584:818;;;;-1:-1:-1;;1368:2:33;1360:11;;-1:-1:-1;;;584:818:33:o;3737:184::-;3807:6;3860:2;3848:9;3839:7;3835:23;3831:32;3828:52;;;3876:1;3873;3866:12;3828:52;-1:-1:-1;3899:16:33;;3737:184;-1:-1:-1;3737:184:33:o;4108:400::-;-1:-1:-1;;;;;4364:15:33;;;4346:34;;4416:15;;;;4411:2;4396:18;;4389:43;-1:-1:-1;;;;;;4468:33:33;;;4463:2;4448:18;;4441:61;4296:2;4281:18;;4108:400::o;4513:277::-;4580:6;4633:2;4621:9;4612:7;4608:23;4604:32;4601:52;;;4649:1;4646;4639:12;4601:52;4681:9;4675:16;4734:5;4727:13;4720:21;4713:5;4710:32;4700:60;;4756:1;4753;4746:12;5074:127;5135:10;5130:3;5126:20;5123:1;5116:31;5166:4;5163:1;5156:15;5190:4;5187:1;5180:15;5206:232;5245:3;-1:-1:-1;;5266:17:33;;5263:140;;;5325:10;5320:3;5316:20;5313:1;5306:31;5360:4;5357:1;5350:15;5388:4;5385:1;5378:15;5263:140;-1:-1:-1;5430:1:33;5419:13;;5206:232::o"
        },
        "gasEstimates": {
          "creation": {
            "codeDepositCost": "467800",
            "executionCost": "infinite",
            "totalCost": "infinite"
          },
          "external": {
            "_ve()": "2381",
            "aphra()": "infinite",
            "authority()": "2403",
            "claim(address,uint256,bytes32[])": "infinite",
            "hasClaimed(address)": "2614",
            "merkleRoot()": "infinite",
            "owner()": "2359",
            "setAuthority(address)": "infinite",
            "setNewVe(address)": "infinite",
            "setOwner(address)": "infinite"
          }
        },
        "methodIdentifiers": {
          "_ve()": "8dd598fb",
          "aphra()": "4732977c",
          "authority()": "bf7e214f",
          "claim(address,uint256,bytes32[])": "3d13f874",
          "hasClaimed(address)": "73b2e80e",
          "merkleRoot()": "2eb4a7ab",
          "owner()": "8da5cb5b",
          "setAuthority(address)": "7a9e5e4b",
          "setNewVe(address)": "d4fc9e9b",
          "setOwner(address)": "13af4035"
        }
      },
      "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"GOVERNANCE_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"MERKLE_ROOT_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"veAPHRA_ADDR_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInMerkle\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_ve\",\"outputs\":[{\"internalType\":\"contract veAPHRA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aphra\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"veAPHRA_ADDR_\",\"type\":\"address\"}],\"name\":\"setNewVe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"hasClaimed(address)\":{\"notice\":\"============ Mutable storage ============\"},\"merkleRoot()\":{\"notice\":\"============ Immutable storage ============\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"srcBuild/AirdropClaim.sol\":\"AirdropClaim\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@rari-capital/solmate/src/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x45a3dedcffe229eb4393a1ac5233da3d332cddae4cf97fc44602614329c1f70a\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x698cdbf614109fafc2bf00057b60715fa3aba9dad447c42f4f8b749ae16ce84f\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/AirdropClaim.sol\":{\"content\":\"pragma solidity ^0.8.11;\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport { MerkleProof } from \\\"./MerkleProof.sol\\\"; // OZ: MerkleProof\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {veAPHRA} from \\\"./veAPHRA.sol\\\";\\n\\ncontract AirdropClaim is Auth {\\n\\n    /// ============ Immutable storage ============\\n\\n    bytes32 public immutable merkleRoot;\\n\\n    veAPHRA public _ve;\\n    ERC20 public immutable aphra;\\n\\n    /// ============ Mutable storage ============\\n\\n    mapping(address => bool) public hasClaimed;\\n\\n    error AlreadyClaimed();\\n    error NotInMerkle();\\n\\n    event Claim(address indexed to, uint256 amount);\\n    uint internal constant AIRDROP_LOCK = 2 * 365 * 86400;\\n\\n    constructor(\\n        address GOVERNANCE_,\\n        bytes32 MERKLE_ROOT_,\\n        address veAPHRA_ADDR_\\n    ) Auth(GOVERNANCE_, Authority(address(0))) {\\n        merkleRoot = MERKLE_ROOT_;\\n        _ve = veAPHRA(veAPHRA_ADDR_);\\n        aphra = ERC20(_ve.token());\\n        aphra.approve(veAPHRA_ADDR_, type(uint).max);\\n    }\\n\\n    //should the ve get updated before the system is crystalized ensure airdrop claimers can get their portion always\\n    function setNewVe(address veAPHRA_ADDR_) requiresAuth external {\\n        _ve = veAPHRA(veAPHRA_ADDR_);\\n        aphra.approve(veAPHRA_ADDR_, type(uint).max);\\n    }\\n\\n    function claim(address to, uint256 amount, bytes32[] calldata proof) external {\\n        // Throw if address has already claimed tokens\\n        if (hasClaimed[to]) revert AlreadyClaimed();\\n\\n        // Verify merkle proof, or revert if not in tree\\n        bytes32 leaf = keccak256(abi.encodePacked(to, amount));\\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\\n        if (!isValidLeaf) revert NotInMerkle();\\n\\n        // Set address to claimed\\n        hasClaimed[to] = true;\\n\\n        // push tokens into veAPHRA lock expiring after 2 years,\\n        //congrats on the responsibility\\n        _ve.create_lock_for(amount, AIRDROP_LOCK, to);\\n\\n        // Emit claim event\\n        emit Claim(to, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x9c072390adae7595cbde99e7bdbd985d962a8b2d7d9a288278e946714ab2f103\"},\"srcBuild/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x990050a0191060180c62dcdd81ffe077411ca26eabd5af335f8491f48311e3a9\",\"license\":\"MIT\"},\"srcBuild/veAPHRA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\n/**\\n@title Voting Escrow\\n@author Curve Finance\\n@license MIT\\n@notice Votes have a weight depending on time, so that users are\\ncommitted to the future of (whatever they are voting for)\\n@dev Vote weight decays linearly over time. Lock time cannot be\\nmore than `MAXTIME` (4 years).\\n\\n# Voting escrow to have time-weighted votes\\n# Votes have a weight depending on time, so that users are committed\\n# to the future of (whatever they are voting for).\\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\\n# w ^\\n# 1 +        /\\n#   |      /\\n#   |    /\\n#   |  /\\n#   |/\\n# 0 +--------+------> time\\n#       maxtime (4 years?)\\n*/\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\\n/**\\n* @dev Interface of the ERC165 standard, as defined in the\\n* https://eips.ethereum.org/EIPS/eip-165[EIP].\\n*\\n* Implementers can declare support of contract interfaces, which can then be\\n* queried by others ({ERC165Checker}).\\n*\\n* For an implementation, see {ERC165}.\\n*/\\ninterface IERC165 {\\n    /**\\n    * @dev Returns true if this contract implements the interface defined by\\n    * `interfaceId`. See the corresponding\\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n    * to learn more about how these ids are created.\\n    *\\n    * This function call must use less than 30 000 gas.\\n    */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n* @dev Required interface of an ERC721 compliant contract.\\n*/\\ninterface IERC721 is IERC165 {\\n    /**\\n    * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n    */\\n    event Transfer(address indexed from, address indexed to, uint indexed tokenId);\\n\\n    /**\\n    * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n    */\\n    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\\n\\n    /**\\n    * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n    */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n    * @dev Returns the number of tokens in ``owner``'s account.\\n    */\\n    function balanceOf(address owner) external view returns (uint balance);\\n\\n    /**\\n    * @dev Returns the owner of the `tokenId` token.\\n    *\\n    * Requirements:\\n    *\\n    * - `tokenId` must exist.\\n    */\\n    function ownerOf(uint tokenId) external view returns (address owner);\\n\\n    /**\\n    * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n    * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n    *\\n    * Requirements:\\n    *\\n    * - `from` cannot be the zero address.\\n    * - `to` cannot be the zero address.\\n    * - `tokenId` token must exist and be owned by `from`.\\n    * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n    * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint tokenId\\n    ) external;\\n\\n    /**\\n    * @dev Transfers `tokenId` token from `from` to `to`.\\n    *\\n    * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n    *\\n    * Requirements:\\n    *\\n    * - `from` cannot be the zero address.\\n    * - `to` cannot be the zero address.\\n    * - `tokenId` token must be owned by `from`.\\n    * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint tokenId\\n    ) external;\\n\\n    /**\\n    * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n    * The approval is cleared when the token is transferred.\\n    *\\n    * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n    *\\n    * Requirements:\\n    *\\n    * - The caller must own the token or be an approved operator.\\n    * - `tokenId` must exist.\\n    *\\n    * Emits an {Approval} event.\\n    */\\n    function approve(address to, uint tokenId) external;\\n\\n    /**\\n    * @dev Returns the account approved for `tokenId` token.\\n    *\\n    * Requirements:\\n    *\\n    * - `tokenId` must exist.\\n    */\\n    function getApproved(uint tokenId) external view returns (address operator);\\n\\n    /**\\n    * @dev Approve or remove `operator` as an operator for the caller.\\n    * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n    *\\n    * Requirements:\\n    *\\n    * - The `operator` cannot be the caller.\\n    *\\n    * Emits an {ApprovalForAll} event.\\n    */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n    * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n    *\\n    * See {setApprovalForAll}\\n    */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n    * @dev Safely transfers `tokenId` token from `from` to `to`.\\n    *\\n    * Requirements:\\n    *\\n    * - `from` cannot be the zero address.\\n    * - `to` cannot be the zero address.\\n    * - `tokenId` token must exist and be owned by `from`.\\n    * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n    * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n* @title ERC721 token receiver interface\\n* @dev Interface for any contract that wants to support safeTransfers\\n* from ERC721 asset contracts.\\n*/\\ninterface IERC721Receiver {\\n    /**\\n    * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n    * by `operator` from `from`, this function is called.\\n    *\\n    * It must return its Solidity selector to confirm the token transfer.\\n    * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n    *\\n    * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n    */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n* @dev See https://eips.ethereum.org/EIPS/eip-721\\n*/\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n    * @dev Returns the token collection name.\\n    */\\n    function name() external view returns (string memory);\\n\\n    /**\\n    * @dev Returns the token collection symbol.\\n    */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n    * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n    */\\n    function tokenURI(uint tokenId) external view returns (string memory);\\n}\\n\\n/**\\n* @dev Interface of the ERC20 standard as defined in the EIP.\\n*/\\ninterface IERC20 {\\n    /**\\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    /**\\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n    * allowance mechanism. `amount` is then deducted from the caller's\\n    * allowance.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n}\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint ts;\\n        uint blk; // block\\n    }\\n/* We cannot really do block numbers per se b/c slope is per time, not per block\\n* and per block could be fairly bad b/c Ethereum changes blocktimes.\\n* What we can do is to extrapolate ***At functions */\\n\\n    struct LockedBalance {\\n        int128 amount;\\n        uint end;\\n    }\\n\\ncontract veAPHRA is Auth, IERC721, IERC721Metadata {\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME,\\n        MERGE_TYPE\\n    }\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint tokenId,\\n        uint value,\\n        uint indexed locktime,\\n        DepositType deposit_type,\\n        uint ts\\n    );\\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\\n    event Supply(uint prevSupply, uint supply);\\n\\n    uint internal constant WEEK = 1 weeks;\\n    uint internal constant MAXTIME = 2 * 365 * 86400;\\n    int128 internal constant iMAXTIME = 2 * 365 * 86400;\\n    uint internal constant MULTIPLIER = 1 ether;\\n\\n    address immutable public token;\\n    uint public supply;\\n    mapping(uint => LockedBalance) public locked;\\n\\n    mapping(uint => uint) public ownership_change;\\n\\n    uint public epoch;\\n    mapping(uint => Point) public point_history; // epoch -> unsigned point\\n    mapping(uint => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\\n\\n    mapping(uint => uint) public user_point_epoch;\\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\\n\\n    mapping(uint => uint) public attachments;\\n    mapping(uint => bool) public voted;\\n    address public voter;\\n\\n    string constant public name = \\\"veAPHRA\\\";\\n    string constant public symbol = \\\"veAPHRA\\\";\\n    string constant public version = \\\"1.0.0\\\";\\n    uint8 constant public decimals = 18;\\n\\n    string public badgeDescription;\\n    /// @dev Current count of token\\n    uint internal tokenId;\\n\\n    /// @dev Mapping from NFT ID to the address that owns it.\\n    mapping(uint => address) internal idToOwner;\\n\\n    /// @dev Mapping from NFT ID to approved address.\\n    mapping(uint => address) internal idToApprovals;\\n\\n    /// @dev Mapping from owner address to count of his tokens.\\n    mapping(address => uint) internal ownerToNFTokenCount;\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenIds\\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\\n\\n    /// @dev Mapping from NFT ID to index of owner\\n    mapping(uint => uint) internal tokenToOwnerIndex;\\n\\n    /// @dev Mapping from owner address to mapping of operator addresses.\\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\\n\\n    /// @dev Mapping of interface id to bool about whether or not it's supported\\n    mapping(bytes4 => bool) internal supportedInterfaces;\\n\\n    /// @dev ERC165 interface ID of ERC165\\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\\n\\n    /// @dev ERC165 interface ID of ERC721\\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\\n\\n    /// @dev ERC165 interface ID of ERC721Metadata\\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\\n\\n    bool internal _unlocked;\\n    /// @dev reentrancy guard\\n    uint8 internal constant _not_entered = 1;\\n    uint8 internal constant _entered = 2;\\n    uint8 internal _entered_state = 1;\\n    modifier nonreentrant() {\\n        require(_entered_state == _not_entered);\\n        _entered_state = _entered;\\n        _;\\n        _entered_state = _not_entered;\\n    }\\n\\n    /// @notice Contract constructor\\n    /// @param TOKEN_ADDR_ `ERC20APHRA` token address\\n    /// @param GOVERNANCE_ `GOVERNANCE`  address\\n    /// @param AUTHORITY_ `Authority`  address\\n    constructor(\\n        address TOKEN_ADDR_,\\n        address GOVERNANCE_,\\n        address AUTHORITY_\\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_)) {\\n        token = TOKEN_ADDR_;\\n        voter = msg.sender;\\n        point_history[0].blk = block.number;\\n        point_history[0].ts = block.timestamp;\\n        _unlocked = false;\\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\\n        badgeDescription = string(\\\"APHRA Badges, can be used to boost gauge yields, vote on new token emissions, receive protocol bribes and participate in governance\\\");\\n        // mint-ish\\n        emit Transfer(address(0), address(this), tokenId);\\n        // burn-ish\\n        emit Transfer(address(this), address(0), tokenId);\\n    }\\n\\n    function isUnlocked() public view returns (bool) {\\n        return _unlocked;\\n    }\\n\\n    function setBadgeDescription(string memory _newDescription) requiresAuth external {\\n        badgeDescription = _newDescription;\\n    }\\n\\n    //todo setup so that this is hard coded to be veGovernor\\n    function unlock() public requiresAuth {\\n        require(_unlocked == false, \\\"unlock already happened\\\");\\n        _unlocked = true;\\n    }\\n\\n    modifier unlocked() {\\n        require(_unlocked, \\\"contract must be unlocked\\\");\\n        _;\\n    }\\n\\n    /// @dev Interface identification is specified in ERC-165.\\n    /// @param _interfaceID Id of the interface\\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\\n        return supportedInterfaces[_interfaceID];\\n    }\\n\\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\\n    /// @param _tokenId token of the NFT\\n    /// @return Value of the slope\\n    function get_last_user_slope(uint _tokenId) external view returns (int128) {\\n        uint uepoch = user_point_epoch[_tokenId];\\n        return user_point_history[_tokenId][uepoch].slope;\\n    }\\n\\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\\n    /// @param _tokenId token of the NFT\\n    /// @param _idx User epoch number\\n    /// @return Epoch time of the checkpoint\\n    function user_point_history__ts(uint _tokenId, uint _idx) external view returns (uint) {\\n        return user_point_history[_tokenId][_idx].ts;\\n    }\\n\\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\\n    /// @param _tokenId User NFT\\n    /// @return Epoch time of the lock end\\n    function locked__end(uint _tokenId) external view returns (uint) {\\n        return locked[_tokenId].end;\\n    }\\n\\n    /// @dev Returns the number of NFTs owned by `_owner`.\\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\\n    /// @param _owner Address for whom to query the balance.\\n    function _balance(address _owner) internal view returns (uint) {\\n        return ownerToNFTokenCount[_owner];\\n    }\\n\\n    /// @dev Returns the number of NFTs owned by `_owner`.\\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\\n    /// @param _owner Address for whom to query the balance.\\n    function balanceOf(address _owner) external view returns (uint) {\\n        return _balance(_owner);\\n    }\\n\\n    /// @dev Returns the address of the owner of the NFT.\\n    /// @param _tokenId The identifier for an NFT.\\n    function ownerOf(uint _tokenId) public view returns (address) {\\n        return idToOwner[_tokenId];\\n    }\\n\\n    /// @dev Get the approved address for a single NFT.\\n    /// @param _tokenId ID of the NFT to query the approval of.\\n    function getApproved(uint _tokenId) external view returns (address) {\\n        return idToApprovals[_tokenId];\\n    }\\n\\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\\n    /// @param _owner The address that owns the NFTs.\\n    /// @param _operator The address that acts on behalf of the owner.\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\\n        return (ownerToOperators[_owner])[_operator];\\n    }\\n\\n    /// @dev  Get token by index\\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\\n    }\\n\\n    /// @dev Returns whether the given spender can transfer a given token ID\\n    /// @param _spender address of the spender to query\\n    /// @param _tokenId uint ID of the token to be transferred\\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\\n    function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\\n        address owner = idToOwner[_tokenId];\\n        bool spenderIsOwner = owner == _spender;\\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\\n    }\\n\\n    function isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\\n        return _isApprovedOrOwner(_spender, _tokenId);\\n    }\\n\\n    /// @dev Add a NFT to an index mapping to a given address\\n    /// @param _to address of the receiver\\n    /// @param _tokenId uint ID Of the token to be added\\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\\n        uint current_count = _balance(_to);\\n\\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\\n        tokenToOwnerIndex[_tokenId] = current_count;\\n    }\\n\\n    /// @dev Remove a NFT from an index mapping to a given address\\n    /// @param _from address of the sender\\n    /// @param _tokenId uint ID Of the token to be removed\\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\\n        // Delete\\n        uint current_count = _balance(_from) - 1;\\n        uint current_index = tokenToOwnerIndex[_tokenId];\\n\\n        if (current_count == current_index) {\\n            // update ownerToNFTokenIdList\\n            ownerToNFTokenIdList[_from][current_count] = 0;\\n            // update tokenToOwnerIndex\\n            tokenToOwnerIndex[_tokenId] = 0;\\n        } else {\\n            uint lastTokenId = ownerToNFTokenIdList[_from][current_count];\\n\\n            // Add\\n            // update ownerToNFTokenIdList\\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\\n            // update tokenToOwnerIndex\\n            tokenToOwnerIndex[lastTokenId] = current_index;\\n\\n            // Delete\\n            // update ownerToNFTokenIdList\\n            ownerToNFTokenIdList[_from][current_count] = 0;\\n            // update tokenToOwnerIndex\\n            tokenToOwnerIndex[_tokenId] = 0;\\n        }\\n    }\\n\\n    /// @dev Add a NFT to a given address\\n    ///      Throws if `_tokenId` is owned by someone.\\n    function _addTokenTo(address _to, uint _tokenId) internal {\\n        // Throws if `_tokenId` is owned by someone\\n        assert(idToOwner[_tokenId] == address(0));\\n        // Change the owner\\n        idToOwner[_tokenId] = _to;\\n        // Update owner token index tracking\\n        _addTokenToOwnerList(_to, _tokenId);\\n        // Change count tracking\\n        ownerToNFTokenCount[_to] += 1;\\n    }\\n\\n    /// @dev Remove a NFT from a given address\\n    ///      Throws if `_from` is not the current owner.\\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\\n        // Throws if `_from` is not the current owner\\n        assert(idToOwner[_tokenId] == _from);\\n        // Change the owner\\n        idToOwner[_tokenId] = address(0);\\n        // Update owner token index tracking\\n        _removeTokenFromOwnerList(_from, _tokenId);\\n        // Change count tracking\\n        ownerToNFTokenCount[_from] -= 1;\\n    }\\n\\n    /// @dev Clear an approval of a given address\\n    ///      Throws if `_owner` is not the current owner.\\n    function _clearApproval(address _owner, uint _tokenId) internal {\\n        // Throws if `_owner` is not the current owner\\n        assert(idToOwner[_tokenId] == _owner);\\n        if (idToApprovals[_tokenId] != address(0)) {\\n            // Reset approvals\\n            idToApprovals[_tokenId] = address(0);\\n        }\\n    }\\n\\n    /// @dev Exeute transfer of a NFT.\\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    function _transferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId,\\n        address _sender\\n    ) internal {\\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \\\"attached\\\");\\n        // Check requirements\\n        require(_isApprovedOrOwner(_sender, _tokenId));\\n        // Clear approval. Throws if `_from` is not the current owner\\n        _clearApproval(_from, _tokenId);\\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\\n        _removeTokenFrom(_from, _tokenId);\\n        // Add NFT\\n        _addTokenTo(_to, _tokenId);\\n        // Set the block of ownership transfer (for Flash NFT protection)\\n        ownership_change[_tokenId] = block.number;\\n        // Log the transfer\\n        emit Transfer(_from, _to, _tokenId);\\n    }\\n\\n    /* TRANSFER FUNCTIONS */\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n    ///        they maybe be permanently lost.\\n    /// @param _from The current owner of the NFT.\\n    /// @param _to The new owner.\\n    /// @param _tokenId The NFT to transfer.\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId\\n    ) unlocked external {\\n        _transferFrom(_from, _to, _tokenId, msg.sender);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /// @dev Transfers the ownership of an NFT from one address to another address.\\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n    ///      approved address for this NFT.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\\n    ///      the return value is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT.\\n    /// @param _to The new owner.\\n    /// @param _tokenId The NFT to transfer.\\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId,\\n        bytes memory _data\\n    ) unlocked public {\\n        _transferFrom(_from, _to, _tokenId, msg.sender);\\n\\n        if (_isContract(_to)) {\\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (\\n                bytes memory reason\\n            ) {\\n                if (reason.length == 0) {\\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers the ownership of an NFT from one address to another address.\\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n    ///      approved address for this NFT.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\\n    ///      the return value is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT.\\n    /// @param _to The new owner.\\n    /// @param _tokenId The NFT to transfer.\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId\\n    ) unlocked external {\\n        safeTransferFrom(_from, _to, _tokenId, '');\\n    }\\n\\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\\n    /// @param _approved Address to be approved for the given NFT ID.\\n    /// @param _tokenId ID of the token to be approved.\\n    function approve(address _approved, uint _tokenId) unlocked public {\\n        address owner = idToOwner[_tokenId];\\n        // Throws if `_tokenId` is not a valid NFT\\n        require(owner != address(0));\\n        // Throws if `_approved` is the current owner\\n        require(_approved != owner);\\n        // Check requirements\\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\\n        require(senderIsOwner || senderIsApprovedForAll);\\n        // Set the approval\\n        idToApprovals[_tokenId] = _approved;\\n        emit Approval(owner, _approved, _tokenId);\\n    }\\n\\n    /// @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\\n    /// @notice This works even if sender doesn't own any tokens at the time.\\n    /// @param _operator Address to add to the set of authorized operators.\\n    /// @param _approved True if the operators is approved, false to revoke approval.\\n    function setApprovalForAll(address _operator, bool _approved) unlocked external {\\n        // Throws if `_operator` is the `msg.sender`\\n        assert(_operator != msg.sender);\\n        ownerToOperators[msg.sender][_operator] = _approved;\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\n    }\\n\\n    /// @dev Function to mint tokens\\n    ///      Throws if `_to` is zero address.\\n    ///      Throws if `_tokenId` is owned by someone.\\n    /// @param _to The address that will receive the minted tokens.\\n    /// @param _tokenId The token id to mint.\\n    /// @return A boolean that indicates if the operation was successful.\\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\\n        // Throws if `_to` is zero address\\n        assert(_to != address(0));\\n        // Add NFT. Throws if `_tokenId` is owned by someone\\n        _addTokenTo(_to, _tokenId);\\n        emit Transfer(address(0), _to, _tokenId);\\n        return true;\\n    }\\n\\n    /// @notice Record global and per-user data to checkpoint\\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\\n    /// @param old_locked Pevious locked amount / end lock time for the user\\n    /// @param new_locked New locked amount / end lock time for the user\\n    function _checkpoint(\\n        uint _tokenId,\\n        LockedBalance memory old_locked,\\n        LockedBalance memory new_locked\\n    ) internal {\\n        Point memory u_old;\\n        Point memory u_new;\\n        int128 old_dslope = 0;\\n        int128 new_dslope = 0;\\n        uint _epoch = epoch;\\n\\n        if (_tokenId != 0) {\\n            // Calculate slopes and biases\\n            // Kept at zero when they have to\\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\\n                u_old.slope = old_locked.amount / iMAXTIME;\\n                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\\n            }\\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\\n                u_new.slope = new_locked.amount / iMAXTIME;\\n                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\\n            }\\n\\n            // Read values of scheduled changes in the slope\\n            // old_locked.end can be in the past and in the future\\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\\n            old_dslope = slope_changes[old_locked.end];\\n            if (new_locked.end != 0) {\\n                if (new_locked.end == old_locked.end) {\\n                    new_dslope = old_dslope;\\n                } else {\\n                    new_dslope = slope_changes[new_locked.end];\\n                }\\n            }\\n        }\\n\\n        Point memory last_point = Point({bias : 0, slope : 0, ts : block.timestamp, blk : block.number});\\n        if (_epoch > 0) {\\n            last_point = point_history[_epoch];\\n        }\\n        uint last_checkpoint = last_point.ts;\\n        // initial_last_point is used for extrapolation to calculate block number\\n        // (approximately, for *At methods) and save them\\n        // as we cannot figure that out exactly from inside the contract\\n        Point memory initial_last_point = last_point;\\n        uint block_slope = 0;\\n        // dblock/dt\\n        if (block.timestamp > last_point.ts) {\\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\\n        }\\n        // If last point is already recorded in this block, slope=0\\n        // But that's ok b/c we know the block in such case\\n\\n        // Go over weeks to fill history and calculate what the current point is\\n        {\\n            uint t_i = (last_checkpoint / WEEK) * WEEK;\\n            for (uint i = 0; i < 255; ++i) {\\n                // Hopefully it won't happen that this won't get used in 5 years!\\n                // If it does, users will be able to withdraw but vote weight will be broken\\n                t_i += WEEK;\\n                int128 d_slope = 0;\\n                if (t_i > block.timestamp) {\\n                    t_i = block.timestamp;\\n                } else {\\n                    d_slope = slope_changes[t_i];\\n                }\\n                last_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\\n                last_point.slope += d_slope;\\n                if (last_point.bias < 0) {\\n                    // This can happen\\n                    last_point.bias = 0;\\n                }\\n                if (last_point.slope < 0) {\\n                    // This cannot happen - just in case\\n                    last_point.slope = 0;\\n                }\\n                last_checkpoint = t_i;\\n                last_point.ts = t_i;\\n                last_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\\n                _epoch += 1;\\n                if (t_i == block.timestamp) {\\n                    last_point.blk = block.number;\\n                    break;\\n                } else {\\n                    point_history[_epoch] = last_point;\\n                }\\n            }\\n        }\\n\\n        epoch = _epoch;\\n        // Now point_history is filled until t=now\\n\\n        if (_tokenId != 0) {\\n            // If last point was in this block, the slope change has been applied already\\n            // But in such case we have 0 slope(s)\\n            last_point.slope += (u_new.slope - u_old.slope);\\n            last_point.bias += (u_new.bias - u_old.bias);\\n            if (last_point.slope < 0) {\\n                last_point.slope = 0;\\n            }\\n            if (last_point.bias < 0) {\\n                last_point.bias = 0;\\n            }\\n        }\\n\\n        // Record the changed point into history\\n        point_history[_epoch] = last_point;\\n\\n        if (_tokenId != 0) {\\n            // Schedule the slope changes (slope is going down)\\n            // We subtract new_user_slope from [new_locked.end]\\n            // and add old_user_slope to [old_locked.end]\\n            if (old_locked.end > block.timestamp) {\\n                // old_dslope was <something> - u_old.slope, so we cancel that\\n                old_dslope += u_old.slope;\\n                if (new_locked.end == old_locked.end) {\\n                    old_dslope -= u_new.slope;\\n                    // It was a new deposit, not extension\\n                }\\n                slope_changes[old_locked.end] = old_dslope;\\n            }\\n\\n            if (new_locked.end > block.timestamp) {\\n                if (new_locked.end > old_locked.end) {\\n                    new_dslope -= u_new.slope;\\n                    // old slope disappeared at this point\\n                    slope_changes[new_locked.end] = new_dslope;\\n                }\\n                // else: we recorded it already in old_dslope\\n            }\\n            // Now handle user history\\n            uint user_epoch = user_point_epoch[_tokenId] + 1;\\n\\n            user_point_epoch[_tokenId] = user_epoch;\\n            u_new.ts = block.timestamp;\\n            u_new.blk = block.number;\\n            user_point_history[_tokenId][user_epoch] = u_new;\\n        }\\n    }\\n\\n    /// @notice Deposit and lock tokens for a user\\n    /// @param _tokenId NFT that holds lock\\n    /// @param _value Amount to deposit\\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\\n    /// @param locked_balance Previous locked amount / timestamp\\n    /// @param deposit_type The type of deposit\\n    function _deposit_for(\\n        uint _tokenId,\\n        uint _value,\\n        uint unlock_time,\\n        LockedBalance memory locked_balance,\\n        DepositType deposit_type\\n    ) internal {\\n        LockedBalance memory _locked = locked_balance;\\n        uint supply_before = supply;\\n\\n        supply = supply_before + _value;\\n        LockedBalance memory old_locked;\\n        (old_locked.amount, old_locked.end) = (_locked.amount, _locked.end);\\n        // Adding to existing lock, or if a lock is expired - creating a new one\\n        _locked.amount += int128(int256(_value));\\n        if (unlock_time != 0) {\\n            _locked.end = unlock_time;\\n        }\\n        locked[_tokenId] = _locked;\\n\\n        // Possibilities:\\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\\n        // _locked.end > block.timestamp (always)\\n        _checkpoint(_tokenId, old_locked, _locked);\\n\\n        address from = msg.sender;\\n        if (_value != 0 && deposit_type != DepositType.MERGE_TYPE) {\\n            assert(IERC20(token).transferFrom(from, address(this), _value));\\n        }\\n\\n        emit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\\n        emit Supply(supply_before, supply_before + _value);\\n    }\\n\\n    function setVoter(address _voter) external {\\n        require(msg.sender == voter);\\n        voter = _voter;\\n    }\\n\\n    function voting(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        voted[_tokenId] = true;\\n    }\\n\\n    function abstain(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        voted[_tokenId] = false;\\n    }\\n\\n    function attach(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        attachments[_tokenId] = attachments[_tokenId] + 1;\\n    }\\n\\n    function detach(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        attachments[_tokenId] = attachments[_tokenId] - 1;\\n    }\\n\\n    function merge(uint _from, uint _to) unlocked external {\\n        require(attachments[_from] == 0 && !voted[_from], \\\"attached\\\");\\n        require(_from != _to);\\n        require(_isApprovedOrOwner(msg.sender, _from));\\n        require(_isApprovedOrOwner(msg.sender, _to));\\n\\n        LockedBalance memory _locked0 = locked[_from];\\n        LockedBalance memory _locked1 = locked[_to];\\n        uint value0 = uint(int256(_locked0.amount));\\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\\n\\n        locked[_from] = LockedBalance(0, 0);\\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\\n        _burn(_from);\\n        _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\\n    }\\n\\n    function block_number() external view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external {\\n        _checkpoint(0, LockedBalance(0, 0), LockedBalance(0, 0));\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function deposit_for(uint _tokenId, uint _value) external nonreentrant {\\n        LockedBalance memory _locked = locked[_tokenId];\\n\\n        require(_value > 0);\\n        // dev: need non-zero value\\n        require(_locked.amount > 0 || !isUnlocked(), 'No existing lock found');\\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\\n    /// @param _value Amount to deposit\\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    function _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\\n        // Locktime is rounded down to weeks\\n\\n        require(_value > 0 || !isUnlocked());\\n        // dev: need non-zero value\\n        require(unlock_time > block.timestamp, 'Can only lock until time in the future');\\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 2 years max');\\n\\n        ++tokenId;\\n        uint _tokenId = tokenId;\\n        _mint(_to, _tokenId);\\n\\n        _deposit_for(_tokenId, _value, unlock_time, locked[_tokenId], DepositType.CREATE_LOCK_TYPE);\\n        return _tokenId;\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\\n    /// @param _value Amount to deposit\\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\\n        return _create_lock(_value, _lock_duration, _to);\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\\n    /// @param _value Amount to deposit\\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\\n    function create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\\n        return _create_lock(_value, _lock_duration, msg.sender);\\n    }\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increase_amount(uint _tokenId, uint _value) external nonreentrant {\\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\\n\\n        LockedBalance memory _locked = locked[_tokenId];\\n\\n        assert(_value > 0 || !isUnlocked());\\n        // dev: need non-zero value\\n        require(_locked.amount > 0 || !isUnlocked(), 'No existing lock found');\\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\\n\\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\\n    }\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    /// @param _lock_duration New number of seconds until tokens unlock\\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\\n\\n        LockedBalance memory _locked = locked[_tokenId];\\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\\n        // Locktime is rounded down to weeks\\n\\n        require(_locked.end > block.timestamp, 'Lock expired');\\n        require(_locked.amount > 0, 'Nothing is locked');\\n        require(unlock_time > _locked.end, 'Can only increase lock duration');\\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\\n\\n        _deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\\n    }\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock has expired\\n    function withdraw(uint _tokenId) unlocked external nonreentrant {\\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \\\"attached\\\");\\n\\n        LockedBalance memory _locked = locked[_tokenId];\\n        require(block.timestamp >= _locked.end, \\\"The lock didn't expire\\\");\\n        uint value = uint(int256(_locked.amount));\\n\\n        locked[_tokenId] = LockedBalance(0, 0);\\n        uint supply_before = supply;\\n        supply = supply_before - value;\\n\\n        // old_locked can have either expired <= timestamp or zero end\\n        // _locked has only 0 end\\n        // Both can have >= 0 amount\\n        _checkpoint(_tokenId, _locked, LockedBalance(0, 0));\\n\\n        assert(IERC20(token).transfer(msg.sender, value));\\n\\n        // Burn the NFT\\n        _burn(_tokenId);\\n\\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\\n        emit Supply(supply_before, supply_before - value);\\n    }\\n\\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\\n    // They measure the weights for the purpose of voting, so they don't represent\\n    // real coins.\\n\\n    /// @notice Binary search to estimate timestamp for block number\\n    /// @param _block Block to find\\n    /// @param max_epoch Don't go beyond this epoch\\n    /// @return Approximate timestamp for block\\n    function _find_block_epoch(uint _block, uint max_epoch) internal view returns (uint) {\\n        // Binary search\\n        uint _min = 0;\\n        uint _max = max_epoch;\\n        for (uint i = 0; i < 128; ++i) {\\n            // Will be always enough for 128-bit numbers\\n            if (_min >= _max) {\\n                break;\\n            }\\n            uint _mid = (_min + _max + 1) / 2;\\n            if (point_history[_mid].blk <= _block) {\\n                _min = _mid;\\n            } else {\\n                _max = _mid - 1;\\n            }\\n        }\\n        return _min;\\n    }\\n\\n    /// @notice Get the current voting power for `_tokenId`\\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\n    /// @param _tokenId NFT for lock\\n    /// @param _t Epoch time to return voting power at\\n    /// @return User voting power\\n    function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\\n        uint _epoch = user_point_epoch[_tokenId];\\n        if (_epoch == 0) {\\n            return 0;\\n        } else {\\n            Point memory last_point = user_point_history[_tokenId][_epoch];\\n            last_point.bias -= last_point.slope * int128(int256(_t) - int256(last_point.ts));\\n            if (last_point.bias < 0) {\\n                last_point.bias = 0;\\n            }\\n            return uint(int256(last_point.bias));\\n        }\\n    }\\n\\n    /// @dev Returns current token URI metadata\\n    /// @param _tokenId Token ID to fetch URI for.\\n    function tokenURI(uint _tokenId) external view returns (string memory) {\\n        require(idToOwner[_tokenId] != address(0), \\\"Query for nonexistent token\\\");\\n        LockedBalance memory _locked = locked[_tokenId];\\n        return\\n        _tokenURI(\\n            _tokenId,\\n            _balanceOfNFT(_tokenId, block.timestamp),\\n            _locked.end,\\n            uint(int256(_locked.amount)),\\n            badgeDescription\\n        );\\n    }\\n\\n    function balanceOfNFT(uint _tokenId) external view returns (uint) {\\n        if (ownership_change[_tokenId] == block.number) return 0;\\n        return _balanceOfNFT(_tokenId, block.timestamp);\\n    }\\n\\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\\n        return _balanceOfNFT(_tokenId, _t);\\n    }\\n\\n    /// @notice Measure voting power of `_tokenId` at block height `_block`\\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\\n    /// @param _tokenId User's wallet NFT\\n    /// @param _block Block to calculate the voting power at\\n    /// @return Voting power\\n    function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\\n        // Copying and pasting totalSupply code because Vyper cannot pass by\\n        // reference yet\\n        assert(_block <= block.number);\\n\\n        // Binary search\\n        uint _min = 0;\\n        uint _max = user_point_epoch[_tokenId];\\n        for (uint i = 0; i < 128; ++i) {\\n            // Will be always enough for 128-bit numbers\\n            if (_min >= _max) {\\n                break;\\n            }\\n            uint _mid = (_min + _max + 1) / 2;\\n            if (user_point_history[_tokenId][_mid].blk <= _block) {\\n                _min = _mid;\\n            } else {\\n                _max = _mid - 1;\\n            }\\n        }\\n\\n        Point memory upoint = user_point_history[_tokenId][_min];\\n\\n        uint max_epoch = epoch;\\n        uint _epoch = _find_block_epoch(_block, max_epoch);\\n        Point memory point_0 = point_history[_epoch];\\n        uint d_block = 0;\\n        uint d_t = 0;\\n        if (_epoch < max_epoch) {\\n            Point memory point_1 = point_history[_epoch + 1];\\n            d_block = point_1.blk - point_0.blk;\\n            d_t = point_1.ts - point_0.ts;\\n        } else {\\n            d_block = block.number - point_0.blk;\\n            d_t = block.timestamp - point_0.ts;\\n        }\\n        uint block_time = point_0.ts;\\n        if (d_block != 0) {\\n            block_time += (d_t * (_block - point_0.blk)) / d_block;\\n        }\\n\\n        upoint.bias -= upoint.slope * int128(int256(block_time - upoint.ts));\\n        if (upoint.bias >= 0) {\\n            return uint(uint128(upoint.bias));\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\\n        return _balanceOfAtNFT(_tokenId, _block);\\n    }\\n\\n    /// @notice Calculate total voting power at some point in the past\\n    /// @param point The point (bias/slope) to start search from\\n    /// @param t Time to calculate the total voting power at\\n    /// @return Total voting power at that time\\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\\n        Point memory last_point = point;\\n        uint t_i = (last_point.ts / WEEK) * WEEK;\\n        for (uint i = 0; i < 255; ++i) {\\n            t_i += WEEK;\\n            int128 d_slope = 0;\\n            if (t_i > t) {\\n                t_i = t;\\n            } else {\\n                d_slope = slope_changes[t_i];\\n            }\\n            last_point.bias -= last_point.slope * int128(int256(t_i - last_point.ts));\\n            if (t_i == t) {\\n                break;\\n            }\\n            last_point.slope += d_slope;\\n            last_point.ts = t_i;\\n        }\\n\\n        if (last_point.bias < 0) {\\n            last_point.bias = 0;\\n        }\\n        return uint(uint128(last_point.bias));\\n    }\\n\\n    /// @notice Calculate total voting power\\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\\n    /// @return Total voting power\\n    function totalSupplyAtT(uint t) public view returns (uint) {\\n        uint _epoch = epoch;\\n        Point memory last_point = point_history[_epoch];\\n        return _supply_at(last_point, t);\\n    }\\n\\n    function totalSupply() external view returns (uint) {\\n        return totalSupplyAtT(block.timestamp);\\n    }\\n\\n    /// @notice Calculate total voting power at some point in the past\\n    /// @param _block Block to calculate the total voting power at\\n    /// @return Total voting power at `_block`\\n    function totalSupplyAt(uint _block) external view returns (uint) {\\n        assert(_block <= block.number);\\n        uint _epoch = epoch;\\n        uint target_epoch = _find_block_epoch(_block, _epoch);\\n\\n        Point memory point = point_history[target_epoch];\\n        uint dt = 0;\\n        if (target_epoch < _epoch) {\\n            Point memory point_next = point_history[target_epoch + 1];\\n            if (point.blk != point_next.blk) {\\n                dt = ((_block - point.blk) * (point_next.ts - point.ts)) / (point_next.blk - point.blk);\\n            }\\n        } else {\\n            if (point.blk != block.number) {\\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\\n            }\\n        }\\n        // Now dt contains info on how far are we beyond point\\n        return _supply_at(point, point.ts + dt);\\n    }\\n\\n    function _tokenURI(uint _tokenId, uint _balanceOf, uint _locked_end, uint _value, string memory description) internal pure returns (string memory output) {\\n        output = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\" /><text x=\\\"10\\\" y=\\\"20\\\" class=\\\"base\\\">';\\n        output = string(abi.encodePacked(output, \\\"token \\\", toString(_tokenId), '</text><text x=\\\"10\\\" y=\\\"40\\\" class=\\\"base\\\">'));\\n        output = string(abi.encodePacked(output, \\\"balanceOf \\\", toString(_balanceOf), '</text><text x=\\\"10\\\" y=\\\"60\\\" class=\\\"base\\\">'));\\n        output = string(abi.encodePacked(output, \\\"locked_end \\\", toString(_locked_end), '</text><text x=\\\"10\\\" y=\\\"80\\\" class=\\\"base\\\">'));\\n        output = string(abi.encodePacked(output, \\\"value \\\", toString(_value), '</text></svg>'));\\n\\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"Badge #', toString(_tokenId), '\\\", \\\"description\\\": \\\"', description, '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\\\"}'))));\\n        output = string(abi.encodePacked('data:application/json;base64,', json));\\n    }\\n\\n    function toString(uint value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint temp = value;\\n        uint digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function _burn(uint _tokenId) internal {\\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \\\"caller is not owner nor approved\\\");\\n\\n        address owner = ownerOf(_tokenId);\\n\\n        // Clear approval\\n        approve(address(0), _tokenId);\\n        // Remove token\\n        _removeTokenFrom(msg.sender, _tokenId);\\n        emit Transfer(owner, address(0), _tokenId);\\n    }\\n}\\n\",\"keccak256\":\"0x12a5ace9b76f460469fa0545122f21d9c6f0ff9a6004375feb11f23d83202475\",\"license\":\"MIT\"}},\"version\":1}",
      "storageLayout": {
        "storage": [
          {
            "astId": 17,
            "contract": "srcBuild/AirdropClaim.sol:AirdropClaim",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 20,
            "contract": "srcBuild/AirdropClaim.sol:AirdropClaim",
            "label": "authority",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(Authority)171"
          },
          {
            "astId": 1022,
            "contract": "srcBuild/AirdropClaim.sol:AirdropClaim",
            "label": "_ve",
            "offset": 0,
            "slot": "2",
            "type": "t_contract(veAPHRA)15196"
          },
          {
            "astId": 1030,
            "contract": "srcBuild/AirdropClaim.sol:AirdropClaim",
            "label": "hasClaimed",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_address,t_bool)"
          }
        ],
        "types": {
          "t_address": {
            "encoding": "inplace",
            "label": "address",
            "numberOfBytes": "20"
          },
          "t_bool": {
            "encoding": "inplace",
            "label": "bool",
            "numberOfBytes": "1"
          },
          "t_contract(Authority)171": {
            "encoding": "inplace",
            "label": "contract Authority",
            "numberOfBytes": "20"
          },
          "t_contract(veAPHRA)15196": {
            "encoding": "inplace",
            "label": "contract veAPHRA",
            "numberOfBytes": "20"
          },
          "t_mapping(t_address,t_bool)": {
            "encoding": "mapping",
            "key": "t_address",
            "label": "mapping(address => bool)",
            "numberOfBytes": "32",
            "value": "t_bool"
          }
        }
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "hasClaimed(address)": {
            "notice": "============ Mutable storage ============"
          },
          "merkleRoot()": {
            "notice": "============ Immutable storage ============"
          }
        },
        "version": 1
      },
      "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"srcBuild/AirdropClaim.sol\": {\n      \"content\": \"pragma solidity ^0.8.11;\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport { MerkleProof } from \\\"./MerkleProof.sol\\\"; // OZ: MerkleProof\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {veAPHRA} from \\\"./veAPHRA.sol\\\";\\n\\ncontract AirdropClaim is Auth {\\n\\n    /// ============ Immutable storage ============\\n\\n    bytes32 public immutable merkleRoot;\\n\\n    veAPHRA public _ve;\\n    ERC20 public immutable aphra;\\n\\n    /// ============ Mutable storage ============\\n\\n    mapping(address => bool) public hasClaimed;\\n\\n    error AlreadyClaimed();\\n    error NotInMerkle();\\n\\n    event Claim(address indexed to, uint256 amount);\\n    uint internal constant AIRDROP_LOCK = 2 * 365 * 86400;\\n\\n    constructor(\\n        address GOVERNANCE_,\\n        bytes32 MERKLE_ROOT_,\\n        address veAPHRA_ADDR_\\n    ) Auth(GOVERNANCE_, Authority(address(0))) {\\n        merkleRoot = MERKLE_ROOT_;\\n        _ve = veAPHRA(veAPHRA_ADDR_);\\n        aphra = ERC20(_ve.token());\\n        aphra.approve(veAPHRA_ADDR_, type(uint).max);\\n    }\\n\\n    //should the ve get updated before the system is crystalized ensure airdrop claimers can get their portion always\\n    function setNewVe(address veAPHRA_ADDR_) requiresAuth external {\\n        _ve = veAPHRA(veAPHRA_ADDR_);\\n        aphra.approve(veAPHRA_ADDR_, type(uint).max);\\n    }\\n\\n    function claim(address to, uint256 amount, bytes32[] calldata proof) external {\\n        // Throw if address has already claimed tokens\\n        if (hasClaimed[to]) revert AlreadyClaimed();\\n\\n        // Verify merkle proof, or revert if not in tree\\n        bytes32 leaf = keccak256(abi.encodePacked(to, amount));\\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\\n        if (!isValidLeaf) revert NotInMerkle();\\n\\n        // Set address to claimed\\n        hasClaimed[to] = true;\\n\\n        // push tokens into veAPHRA lock expiring after 2 years,\\n        //congrats on the responsibility\\n        _ve.create_lock_for(amount, AIRDROP_LOCK, to);\\n\\n        // Emit claim event\\n        emit Claim(to, amount);\\n    }\\n}\\n\"\n    },\n    \"@rari-capital/solmate/src/auth/Auth.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\n    },\n    \"srcBuild/MerkleProof.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\n    },\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\n    },\n    \"srcBuild/veAPHRA.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\n/**\\n@title Voting Escrow\\n@author Curve Finance\\n@license MIT\\n@notice Votes have a weight depending on time, so that users are\\ncommitted to the future of (whatever they are voting for)\\n@dev Vote weight decays linearly over time. Lock time cannot be\\nmore than `MAXTIME` (4 years).\\n\\n# Voting escrow to have time-weighted votes\\n# Votes have a weight depending on time, so that users are committed\\n# to the future of (whatever they are voting for).\\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\\n# w ^\\n# 1 +        /\\n#   |      /\\n#   |    /\\n#   |  /\\n#   |/\\n# 0 +--------+------> time\\n#       maxtime (4 years?)\\n*/\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\\n/**\\n* @dev Interface of the ERC165 standard, as defined in the\\n* https://eips.ethereum.org/EIPS/eip-165[EIP].\\n*\\n* Implementers can declare support of contract interfaces, which can then be\\n* queried by others ({ERC165Checker}).\\n*\\n* For an implementation, see {ERC165}.\\n*/\\ninterface IERC165 {\\n    /**\\n    * @dev Returns true if this contract implements the interface defined by\\n    * `interfaceId`. See the corresponding\\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n    * to learn more about how these ids are created.\\n    *\\n    * This function call must use less than 30 000 gas.\\n    */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n* @dev Required interface of an ERC721 compliant contract.\\n*/\\ninterface IERC721 is IERC165 {\\n    /**\\n    * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n    */\\n    event Transfer(address indexed from, address indexed to, uint indexed tokenId);\\n\\n    /**\\n    * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n    */\\n    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\\n\\n    /**\\n    * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n    */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n    * @dev Returns the number of tokens in ``owner``'s account.\\n    */\\n    function balanceOf(address owner) external view returns (uint balance);\\n\\n    /**\\n    * @dev Returns the owner of the `tokenId` token.\\n    *\\n    * Requirements:\\n    *\\n    * - `tokenId` must exist.\\n    */\\n    function ownerOf(uint tokenId) external view returns (address owner);\\n\\n    /**\\n    * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n    * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n    *\\n    * Requirements:\\n    *\\n    * - `from` cannot be the zero address.\\n    * - `to` cannot be the zero address.\\n    * - `tokenId` token must exist and be owned by `from`.\\n    * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n    * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint tokenId\\n    ) external;\\n\\n    /**\\n    * @dev Transfers `tokenId` token from `from` to `to`.\\n    *\\n    * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n    *\\n    * Requirements:\\n    *\\n    * - `from` cannot be the zero address.\\n    * - `to` cannot be the zero address.\\n    * - `tokenId` token must be owned by `from`.\\n    * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint tokenId\\n    ) external;\\n\\n    /**\\n    * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n    * The approval is cleared when the token is transferred.\\n    *\\n    * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n    *\\n    * Requirements:\\n    *\\n    * - The caller must own the token or be an approved operator.\\n    * - `tokenId` must exist.\\n    *\\n    * Emits an {Approval} event.\\n    */\\n    function approve(address to, uint tokenId) external;\\n\\n    /**\\n    * @dev Returns the account approved for `tokenId` token.\\n    *\\n    * Requirements:\\n    *\\n    * - `tokenId` must exist.\\n    */\\n    function getApproved(uint tokenId) external view returns (address operator);\\n\\n    /**\\n    * @dev Approve or remove `operator` as an operator for the caller.\\n    * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n    *\\n    * Requirements:\\n    *\\n    * - The `operator` cannot be the caller.\\n    *\\n    * Emits an {ApprovalForAll} event.\\n    */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n    * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n    *\\n    * See {setApprovalForAll}\\n    */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n    * @dev Safely transfers `tokenId` token from `from` to `to`.\\n    *\\n    * Requirements:\\n    *\\n    * - `from` cannot be the zero address.\\n    * - `to` cannot be the zero address.\\n    * - `tokenId` token must exist and be owned by `from`.\\n    * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n    * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n* @title ERC721 token receiver interface\\n* @dev Interface for any contract that wants to support safeTransfers\\n* from ERC721 asset contracts.\\n*/\\ninterface IERC721Receiver {\\n    /**\\n    * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n    * by `operator` from `from`, this function is called.\\n    *\\n    * It must return its Solidity selector to confirm the token transfer.\\n    * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n    *\\n    * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n    */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n* @dev See https://eips.ethereum.org/EIPS/eip-721\\n*/\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n    * @dev Returns the token collection name.\\n    */\\n    function name() external view returns (string memory);\\n\\n    /**\\n    * @dev Returns the token collection symbol.\\n    */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n    * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n    */\\n    function tokenURI(uint tokenId) external view returns (string memory);\\n}\\n\\n/**\\n* @dev Interface of the ERC20 standard as defined in the EIP.\\n*/\\ninterface IERC20 {\\n    /**\\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    /**\\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n    * allowance mechanism. `amount` is then deducted from the caller's\\n    * allowance.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n}\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint ts;\\n        uint blk; // block\\n    }\\n/* We cannot really do block numbers per se b/c slope is per time, not per block\\n* and per block could be fairly bad b/c Ethereum changes blocktimes.\\n* What we can do is to extrapolate ***At functions */\\n\\n    struct LockedBalance {\\n        int128 amount;\\n        uint end;\\n    }\\n\\ncontract veAPHRA is Auth, IERC721, IERC721Metadata {\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME,\\n        MERGE_TYPE\\n    }\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint tokenId,\\n        uint value,\\n        uint indexed locktime,\\n        DepositType deposit_type,\\n        uint ts\\n    );\\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\\n    event Supply(uint prevSupply, uint supply);\\n\\n    uint internal constant WEEK = 1 weeks;\\n    uint internal constant MAXTIME = 2 * 365 * 86400;\\n    int128 internal constant iMAXTIME = 2 * 365 * 86400;\\n    uint internal constant MULTIPLIER = 1 ether;\\n\\n    address immutable public token;\\n    uint public supply;\\n    mapping(uint => LockedBalance) public locked;\\n\\n    mapping(uint => uint) public ownership_change;\\n\\n    uint public epoch;\\n    mapping(uint => Point) public point_history; // epoch -> unsigned point\\n    mapping(uint => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\\n\\n    mapping(uint => uint) public user_point_epoch;\\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\\n\\n    mapping(uint => uint) public attachments;\\n    mapping(uint => bool) public voted;\\n    address public voter;\\n\\n    string constant public name = \\\"veAPHRA\\\";\\n    string constant public symbol = \\\"veAPHRA\\\";\\n    string constant public version = \\\"1.0.0\\\";\\n    uint8 constant public decimals = 18;\\n\\n    string public badgeDescription;\\n    /// @dev Current count of token\\n    uint internal tokenId;\\n\\n    /// @dev Mapping from NFT ID to the address that owns it.\\n    mapping(uint => address) internal idToOwner;\\n\\n    /// @dev Mapping from NFT ID to approved address.\\n    mapping(uint => address) internal idToApprovals;\\n\\n    /// @dev Mapping from owner address to count of his tokens.\\n    mapping(address => uint) internal ownerToNFTokenCount;\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenIds\\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\\n\\n    /// @dev Mapping from NFT ID to index of owner\\n    mapping(uint => uint) internal tokenToOwnerIndex;\\n\\n    /// @dev Mapping from owner address to mapping of operator addresses.\\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\\n\\n    /// @dev Mapping of interface id to bool about whether or not it's supported\\n    mapping(bytes4 => bool) internal supportedInterfaces;\\n\\n    /// @dev ERC165 interface ID of ERC165\\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\\n\\n    /// @dev ERC165 interface ID of ERC721\\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\\n\\n    /// @dev ERC165 interface ID of ERC721Metadata\\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\\n\\n    bool internal _unlocked;\\n    /// @dev reentrancy guard\\n    uint8 internal constant _not_entered = 1;\\n    uint8 internal constant _entered = 2;\\n    uint8 internal _entered_state = 1;\\n    modifier nonreentrant() {\\n        require(_entered_state == _not_entered);\\n        _entered_state = _entered;\\n        _;\\n        _entered_state = _not_entered;\\n    }\\n\\n    /// @notice Contract constructor\\n    /// @param TOKEN_ADDR_ `ERC20APHRA` token address\\n    /// @param GOVERNANCE_ `GOVERNANCE`  address\\n    /// @param AUTHORITY_ `Authority`  address\\n    constructor(\\n        address TOKEN_ADDR_,\\n        address GOVERNANCE_,\\n        address AUTHORITY_\\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_)) {\\n        token = TOKEN_ADDR_;\\n        voter = msg.sender;\\n        point_history[0].blk = block.number;\\n        point_history[0].ts = block.timestamp;\\n        _unlocked = false;\\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\\n        badgeDescription = string(\\\"APHRA Badges, can be used to boost gauge yields, vote on new token emissions, receive protocol bribes and participate in governance\\\");\\n        // mint-ish\\n        emit Transfer(address(0), address(this), tokenId);\\n        // burn-ish\\n        emit Transfer(address(this), address(0), tokenId);\\n    }\\n\\n    function isUnlocked() public view returns (bool) {\\n        return _unlocked;\\n    }\\n\\n    function setBadgeDescription(string memory _newDescription) requiresAuth external {\\n        badgeDescription = _newDescription;\\n    }\\n\\n    //todo setup so that this is hard coded to be veGovernor\\n    function unlock() public requiresAuth {\\n        require(_unlocked == false, \\\"unlock already happened\\\");\\n        _unlocked = true;\\n    }\\n\\n    modifier unlocked() {\\n        require(_unlocked, \\\"contract must be unlocked\\\");\\n        _;\\n    }\\n\\n    /// @dev Interface identification is specified in ERC-165.\\n    /// @param _interfaceID Id of the interface\\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\\n        return supportedInterfaces[_interfaceID];\\n    }\\n\\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\\n    /// @param _tokenId token of the NFT\\n    /// @return Value of the slope\\n    function get_last_user_slope(uint _tokenId) external view returns (int128) {\\n        uint uepoch = user_point_epoch[_tokenId];\\n        return user_point_history[_tokenId][uepoch].slope;\\n    }\\n\\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\\n    /// @param _tokenId token of the NFT\\n    /// @param _idx User epoch number\\n    /// @return Epoch time of the checkpoint\\n    function user_point_history__ts(uint _tokenId, uint _idx) external view returns (uint) {\\n        return user_point_history[_tokenId][_idx].ts;\\n    }\\n\\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\\n    /// @param _tokenId User NFT\\n    /// @return Epoch time of the lock end\\n    function locked__end(uint _tokenId) external view returns (uint) {\\n        return locked[_tokenId].end;\\n    }\\n\\n    /// @dev Returns the number of NFTs owned by `_owner`.\\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\\n    /// @param _owner Address for whom to query the balance.\\n    function _balance(address _owner) internal view returns (uint) {\\n        return ownerToNFTokenCount[_owner];\\n    }\\n\\n    /// @dev Returns the number of NFTs owned by `_owner`.\\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\\n    /// @param _owner Address for whom to query the balance.\\n    function balanceOf(address _owner) external view returns (uint) {\\n        return _balance(_owner);\\n    }\\n\\n    /// @dev Returns the address of the owner of the NFT.\\n    /// @param _tokenId The identifier for an NFT.\\n    function ownerOf(uint _tokenId) public view returns (address) {\\n        return idToOwner[_tokenId];\\n    }\\n\\n    /// @dev Get the approved address for a single NFT.\\n    /// @param _tokenId ID of the NFT to query the approval of.\\n    function getApproved(uint _tokenId) external view returns (address) {\\n        return idToApprovals[_tokenId];\\n    }\\n\\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\\n    /// @param _owner The address that owns the NFTs.\\n    /// @param _operator The address that acts on behalf of the owner.\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\\n        return (ownerToOperators[_owner])[_operator];\\n    }\\n\\n    /// @dev  Get token by index\\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\\n    }\\n\\n    /// @dev Returns whether the given spender can transfer a given token ID\\n    /// @param _spender address of the spender to query\\n    /// @param _tokenId uint ID of the token to be transferred\\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\\n    function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\\n        address owner = idToOwner[_tokenId];\\n        bool spenderIsOwner = owner == _spender;\\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\\n    }\\n\\n    function isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\\n        return _isApprovedOrOwner(_spender, _tokenId);\\n    }\\n\\n    /// @dev Add a NFT to an index mapping to a given address\\n    /// @param _to address of the receiver\\n    /// @param _tokenId uint ID Of the token to be added\\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\\n        uint current_count = _balance(_to);\\n\\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\\n        tokenToOwnerIndex[_tokenId] = current_count;\\n    }\\n\\n    /// @dev Remove a NFT from an index mapping to a given address\\n    /// @param _from address of the sender\\n    /// @param _tokenId uint ID Of the token to be removed\\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\\n        // Delete\\n        uint current_count = _balance(_from) - 1;\\n        uint current_index = tokenToOwnerIndex[_tokenId];\\n\\n        if (current_count == current_index) {\\n            // update ownerToNFTokenIdList\\n            ownerToNFTokenIdList[_from][current_count] = 0;\\n            // update tokenToOwnerIndex\\n            tokenToOwnerIndex[_tokenId] = 0;\\n        } else {\\n            uint lastTokenId = ownerToNFTokenIdList[_from][current_count];\\n\\n            // Add\\n            // update ownerToNFTokenIdList\\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\\n            // update tokenToOwnerIndex\\n            tokenToOwnerIndex[lastTokenId] = current_index;\\n\\n            // Delete\\n            // update ownerToNFTokenIdList\\n            ownerToNFTokenIdList[_from][current_count] = 0;\\n            // update tokenToOwnerIndex\\n            tokenToOwnerIndex[_tokenId] = 0;\\n        }\\n    }\\n\\n    /// @dev Add a NFT to a given address\\n    ///      Throws if `_tokenId` is owned by someone.\\n    function _addTokenTo(address _to, uint _tokenId) internal {\\n        // Throws if `_tokenId` is owned by someone\\n        assert(idToOwner[_tokenId] == address(0));\\n        // Change the owner\\n        idToOwner[_tokenId] = _to;\\n        // Update owner token index tracking\\n        _addTokenToOwnerList(_to, _tokenId);\\n        // Change count tracking\\n        ownerToNFTokenCount[_to] += 1;\\n    }\\n\\n    /// @dev Remove a NFT from a given address\\n    ///      Throws if `_from` is not the current owner.\\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\\n        // Throws if `_from` is not the current owner\\n        assert(idToOwner[_tokenId] == _from);\\n        // Change the owner\\n        idToOwner[_tokenId] = address(0);\\n        // Update owner token index tracking\\n        _removeTokenFromOwnerList(_from, _tokenId);\\n        // Change count tracking\\n        ownerToNFTokenCount[_from] -= 1;\\n    }\\n\\n    /// @dev Clear an approval of a given address\\n    ///      Throws if `_owner` is not the current owner.\\n    function _clearApproval(address _owner, uint _tokenId) internal {\\n        // Throws if `_owner` is not the current owner\\n        assert(idToOwner[_tokenId] == _owner);\\n        if (idToApprovals[_tokenId] != address(0)) {\\n            // Reset approvals\\n            idToApprovals[_tokenId] = address(0);\\n        }\\n    }\\n\\n    /// @dev Exeute transfer of a NFT.\\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    function _transferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId,\\n        address _sender\\n    ) internal {\\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \\\"attached\\\");\\n        // Check requirements\\n        require(_isApprovedOrOwner(_sender, _tokenId));\\n        // Clear approval. Throws if `_from` is not the current owner\\n        _clearApproval(_from, _tokenId);\\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\\n        _removeTokenFrom(_from, _tokenId);\\n        // Add NFT\\n        _addTokenTo(_to, _tokenId);\\n        // Set the block of ownership transfer (for Flash NFT protection)\\n        ownership_change[_tokenId] = block.number;\\n        // Log the transfer\\n        emit Transfer(_from, _to, _tokenId);\\n    }\\n\\n    /* TRANSFER FUNCTIONS */\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n    ///        they maybe be permanently lost.\\n    /// @param _from The current owner of the NFT.\\n    /// @param _to The new owner.\\n    /// @param _tokenId The NFT to transfer.\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId\\n    ) unlocked external {\\n        _transferFrom(_from, _to, _tokenId, msg.sender);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /// @dev Transfers the ownership of an NFT from one address to another address.\\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n    ///      approved address for this NFT.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\\n    ///      the return value is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT.\\n    /// @param _to The new owner.\\n    /// @param _tokenId The NFT to transfer.\\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId,\\n        bytes memory _data\\n    ) unlocked public {\\n        _transferFrom(_from, _to, _tokenId, msg.sender);\\n\\n        if (_isContract(_to)) {\\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (\\n                bytes memory reason\\n            ) {\\n                if (reason.length == 0) {\\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers the ownership of an NFT from one address to another address.\\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n    ///      approved address for this NFT.\\n    ///      Throws if `_from` is not the current owner.\\n    ///      Throws if `_to` is the zero address.\\n    ///      Throws if `_tokenId` is not a valid NFT.\\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\\n    ///      the return value is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT.\\n    /// @param _to The new owner.\\n    /// @param _tokenId The NFT to transfer.\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId\\n    ) unlocked external {\\n        safeTransferFrom(_from, _to, _tokenId, '');\\n    }\\n\\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\\n    /// @param _approved Address to be approved for the given NFT ID.\\n    /// @param _tokenId ID of the token to be approved.\\n    function approve(address _approved, uint _tokenId) unlocked public {\\n        address owner = idToOwner[_tokenId];\\n        // Throws if `_tokenId` is not a valid NFT\\n        require(owner != address(0));\\n        // Throws if `_approved` is the current owner\\n        require(_approved != owner);\\n        // Check requirements\\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\\n        require(senderIsOwner || senderIsApprovedForAll);\\n        // Set the approval\\n        idToApprovals[_tokenId] = _approved;\\n        emit Approval(owner, _approved, _tokenId);\\n    }\\n\\n    /// @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\\n    /// @notice This works even if sender doesn't own any tokens at the time.\\n    /// @param _operator Address to add to the set of authorized operators.\\n    /// @param _approved True if the operators is approved, false to revoke approval.\\n    function setApprovalForAll(address _operator, bool _approved) unlocked external {\\n        // Throws if `_operator` is the `msg.sender`\\n        assert(_operator != msg.sender);\\n        ownerToOperators[msg.sender][_operator] = _approved;\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\n    }\\n\\n    /// @dev Function to mint tokens\\n    ///      Throws if `_to` is zero address.\\n    ///      Throws if `_tokenId` is owned by someone.\\n    /// @param _to The address that will receive the minted tokens.\\n    /// @param _tokenId The token id to mint.\\n    /// @return A boolean that indicates if the operation was successful.\\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\\n        // Throws if `_to` is zero address\\n        assert(_to != address(0));\\n        // Add NFT. Throws if `_tokenId` is owned by someone\\n        _addTokenTo(_to, _tokenId);\\n        emit Transfer(address(0), _to, _tokenId);\\n        return true;\\n    }\\n\\n    /// @notice Record global and per-user data to checkpoint\\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\\n    /// @param old_locked Pevious locked amount / end lock time for the user\\n    /// @param new_locked New locked amount / end lock time for the user\\n    function _checkpoint(\\n        uint _tokenId,\\n        LockedBalance memory old_locked,\\n        LockedBalance memory new_locked\\n    ) internal {\\n        Point memory u_old;\\n        Point memory u_new;\\n        int128 old_dslope = 0;\\n        int128 new_dslope = 0;\\n        uint _epoch = epoch;\\n\\n        if (_tokenId != 0) {\\n            // Calculate slopes and biases\\n            // Kept at zero when they have to\\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\\n                u_old.slope = old_locked.amount / iMAXTIME;\\n                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\\n            }\\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\\n                u_new.slope = new_locked.amount / iMAXTIME;\\n                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\\n            }\\n\\n            // Read values of scheduled changes in the slope\\n            // old_locked.end can be in the past and in the future\\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\\n            old_dslope = slope_changes[old_locked.end];\\n            if (new_locked.end != 0) {\\n                if (new_locked.end == old_locked.end) {\\n                    new_dslope = old_dslope;\\n                } else {\\n                    new_dslope = slope_changes[new_locked.end];\\n                }\\n            }\\n        }\\n\\n        Point memory last_point = Point({bias : 0, slope : 0, ts : block.timestamp, blk : block.number});\\n        if (_epoch > 0) {\\n            last_point = point_history[_epoch];\\n        }\\n        uint last_checkpoint = last_point.ts;\\n        // initial_last_point is used for extrapolation to calculate block number\\n        // (approximately, for *At methods) and save them\\n        // as we cannot figure that out exactly from inside the contract\\n        Point memory initial_last_point = last_point;\\n        uint block_slope = 0;\\n        // dblock/dt\\n        if (block.timestamp > last_point.ts) {\\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\\n        }\\n        // If last point is already recorded in this block, slope=0\\n        // But that's ok b/c we know the block in such case\\n\\n        // Go over weeks to fill history and calculate what the current point is\\n        {\\n            uint t_i = (last_checkpoint / WEEK) * WEEK;\\n            for (uint i = 0; i < 255; ++i) {\\n                // Hopefully it won't happen that this won't get used in 5 years!\\n                // If it does, users will be able to withdraw but vote weight will be broken\\n                t_i += WEEK;\\n                int128 d_slope = 0;\\n                if (t_i > block.timestamp) {\\n                    t_i = block.timestamp;\\n                } else {\\n                    d_slope = slope_changes[t_i];\\n                }\\n                last_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\\n                last_point.slope += d_slope;\\n                if (last_point.bias < 0) {\\n                    // This can happen\\n                    last_point.bias = 0;\\n                }\\n                if (last_point.slope < 0) {\\n                    // This cannot happen - just in case\\n                    last_point.slope = 0;\\n                }\\n                last_checkpoint = t_i;\\n                last_point.ts = t_i;\\n                last_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\\n                _epoch += 1;\\n                if (t_i == block.timestamp) {\\n                    last_point.blk = block.number;\\n                    break;\\n                } else {\\n                    point_history[_epoch] = last_point;\\n                }\\n            }\\n        }\\n\\n        epoch = _epoch;\\n        // Now point_history is filled until t=now\\n\\n        if (_tokenId != 0) {\\n            // If last point was in this block, the slope change has been applied already\\n            // But in such case we have 0 slope(s)\\n            last_point.slope += (u_new.slope - u_old.slope);\\n            last_point.bias += (u_new.bias - u_old.bias);\\n            if (last_point.slope < 0) {\\n                last_point.slope = 0;\\n            }\\n            if (last_point.bias < 0) {\\n                last_point.bias = 0;\\n            }\\n        }\\n\\n        // Record the changed point into history\\n        point_history[_epoch] = last_point;\\n\\n        if (_tokenId != 0) {\\n            // Schedule the slope changes (slope is going down)\\n            // We subtract new_user_slope from [new_locked.end]\\n            // and add old_user_slope to [old_locked.end]\\n            if (old_locked.end > block.timestamp) {\\n                // old_dslope was <something> - u_old.slope, so we cancel that\\n                old_dslope += u_old.slope;\\n                if (new_locked.end == old_locked.end) {\\n                    old_dslope -= u_new.slope;\\n                    // It was a new deposit, not extension\\n                }\\n                slope_changes[old_locked.end] = old_dslope;\\n            }\\n\\n            if (new_locked.end > block.timestamp) {\\n                if (new_locked.end > old_locked.end) {\\n                    new_dslope -= u_new.slope;\\n                    // old slope disappeared at this point\\n                    slope_changes[new_locked.end] = new_dslope;\\n                }\\n                // else: we recorded it already in old_dslope\\n            }\\n            // Now handle user history\\n            uint user_epoch = user_point_epoch[_tokenId] + 1;\\n\\n            user_point_epoch[_tokenId] = user_epoch;\\n            u_new.ts = block.timestamp;\\n            u_new.blk = block.number;\\n            user_point_history[_tokenId][user_epoch] = u_new;\\n        }\\n    }\\n\\n    /// @notice Deposit and lock tokens for a user\\n    /// @param _tokenId NFT that holds lock\\n    /// @param _value Amount to deposit\\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\\n    /// @param locked_balance Previous locked amount / timestamp\\n    /// @param deposit_type The type of deposit\\n    function _deposit_for(\\n        uint _tokenId,\\n        uint _value,\\n        uint unlock_time,\\n        LockedBalance memory locked_balance,\\n        DepositType deposit_type\\n    ) internal {\\n        LockedBalance memory _locked = locked_balance;\\n        uint supply_before = supply;\\n\\n        supply = supply_before + _value;\\n        LockedBalance memory old_locked;\\n        (old_locked.amount, old_locked.end) = (_locked.amount, _locked.end);\\n        // Adding to existing lock, or if a lock is expired - creating a new one\\n        _locked.amount += int128(int256(_value));\\n        if (unlock_time != 0) {\\n            _locked.end = unlock_time;\\n        }\\n        locked[_tokenId] = _locked;\\n\\n        // Possibilities:\\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\\n        // _locked.end > block.timestamp (always)\\n        _checkpoint(_tokenId, old_locked, _locked);\\n\\n        address from = msg.sender;\\n        if (_value != 0 && deposit_type != DepositType.MERGE_TYPE) {\\n            assert(IERC20(token).transferFrom(from, address(this), _value));\\n        }\\n\\n        emit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\\n        emit Supply(supply_before, supply_before + _value);\\n    }\\n\\n    function setVoter(address _voter) external {\\n        require(msg.sender == voter);\\n        voter = _voter;\\n    }\\n\\n    function voting(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        voted[_tokenId] = true;\\n    }\\n\\n    function abstain(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        voted[_tokenId] = false;\\n    }\\n\\n    function attach(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        attachments[_tokenId] = attachments[_tokenId] + 1;\\n    }\\n\\n    function detach(uint _tokenId) external {\\n        require(msg.sender == voter);\\n        attachments[_tokenId] = attachments[_tokenId] - 1;\\n    }\\n\\n    function merge(uint _from, uint _to) unlocked external {\\n        require(attachments[_from] == 0 && !voted[_from], \\\"attached\\\");\\n        require(_from != _to);\\n        require(_isApprovedOrOwner(msg.sender, _from));\\n        require(_isApprovedOrOwner(msg.sender, _to));\\n\\n        LockedBalance memory _locked0 = locked[_from];\\n        LockedBalance memory _locked1 = locked[_to];\\n        uint value0 = uint(int256(_locked0.amount));\\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\\n\\n        locked[_from] = LockedBalance(0, 0);\\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\\n        _burn(_from);\\n        _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\\n    }\\n\\n    function block_number() external view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external {\\n        _checkpoint(0, LockedBalance(0, 0), LockedBalance(0, 0));\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function deposit_for(uint _tokenId, uint _value) external nonreentrant {\\n        LockedBalance memory _locked = locked[_tokenId];\\n\\n        require(_value > 0);\\n        // dev: need non-zero value\\n        require(_locked.amount > 0 || !isUnlocked(), 'No existing lock found');\\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\\n    /// @param _value Amount to deposit\\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    function _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\\n        // Locktime is rounded down to weeks\\n\\n        require(_value > 0 || !isUnlocked());\\n        // dev: need non-zero value\\n        require(unlock_time > block.timestamp, 'Can only lock until time in the future');\\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 2 years max');\\n\\n        ++tokenId;\\n        uint _tokenId = tokenId;\\n        _mint(_to, _tokenId);\\n\\n        _deposit_for(_tokenId, _value, unlock_time, locked[_tokenId], DepositType.CREATE_LOCK_TYPE);\\n        return _tokenId;\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\\n    /// @param _value Amount to deposit\\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\\n        return _create_lock(_value, _lock_duration, _to);\\n    }\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\\n    /// @param _value Amount to deposit\\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\\n    function create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\\n        return _create_lock(_value, _lock_duration, msg.sender);\\n    }\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increase_amount(uint _tokenId, uint _value) external nonreentrant {\\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\\n\\n        LockedBalance memory _locked = locked[_tokenId];\\n\\n        assert(_value > 0 || !isUnlocked());\\n        // dev: need non-zero value\\n        require(_locked.amount > 0 || !isUnlocked(), 'No existing lock found');\\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\\n\\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\\n    }\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    /// @param _lock_duration New number of seconds until tokens unlock\\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\\n\\n        LockedBalance memory _locked = locked[_tokenId];\\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\\n        // Locktime is rounded down to weeks\\n\\n        require(_locked.end > block.timestamp, 'Lock expired');\\n        require(_locked.amount > 0, 'Nothing is locked');\\n        require(unlock_time > _locked.end, 'Can only increase lock duration');\\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\\n\\n        _deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\\n    }\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock has expired\\n    function withdraw(uint _tokenId) unlocked external nonreentrant {\\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \\\"attached\\\");\\n\\n        LockedBalance memory _locked = locked[_tokenId];\\n        require(block.timestamp >= _locked.end, \\\"The lock didn't expire\\\");\\n        uint value = uint(int256(_locked.amount));\\n\\n        locked[_tokenId] = LockedBalance(0, 0);\\n        uint supply_before = supply;\\n        supply = supply_before - value;\\n\\n        // old_locked can have either expired <= timestamp or zero end\\n        // _locked has only 0 end\\n        // Both can have >= 0 amount\\n        _checkpoint(_tokenId, _locked, LockedBalance(0, 0));\\n\\n        assert(IERC20(token).transfer(msg.sender, value));\\n\\n        // Burn the NFT\\n        _burn(_tokenId);\\n\\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\\n        emit Supply(supply_before, supply_before - value);\\n    }\\n\\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\\n    // They measure the weights for the purpose of voting, so they don't represent\\n    // real coins.\\n\\n    /// @notice Binary search to estimate timestamp for block number\\n    /// @param _block Block to find\\n    /// @param max_epoch Don't go beyond this epoch\\n    /// @return Approximate timestamp for block\\n    function _find_block_epoch(uint _block, uint max_epoch) internal view returns (uint) {\\n        // Binary search\\n        uint _min = 0;\\n        uint _max = max_epoch;\\n        for (uint i = 0; i < 128; ++i) {\\n            // Will be always enough for 128-bit numbers\\n            if (_min >= _max) {\\n                break;\\n            }\\n            uint _mid = (_min + _max + 1) / 2;\\n            if (point_history[_mid].blk <= _block) {\\n                _min = _mid;\\n            } else {\\n                _max = _mid - 1;\\n            }\\n        }\\n        return _min;\\n    }\\n\\n    /// @notice Get the current voting power for `_tokenId`\\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\n    /// @param _tokenId NFT for lock\\n    /// @param _t Epoch time to return voting power at\\n    /// @return User voting power\\n    function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\\n        uint _epoch = user_point_epoch[_tokenId];\\n        if (_epoch == 0) {\\n            return 0;\\n        } else {\\n            Point memory last_point = user_point_history[_tokenId][_epoch];\\n            last_point.bias -= last_point.slope * int128(int256(_t) - int256(last_point.ts));\\n            if (last_point.bias < 0) {\\n                last_point.bias = 0;\\n            }\\n            return uint(int256(last_point.bias));\\n        }\\n    }\\n\\n    /// @dev Returns current token URI metadata\\n    /// @param _tokenId Token ID to fetch URI for.\\n    function tokenURI(uint _tokenId) external view returns (string memory) {\\n        require(idToOwner[_tokenId] != address(0), \\\"Query for nonexistent token\\\");\\n        LockedBalance memory _locked = locked[_tokenId];\\n        return\\n        _tokenURI(\\n            _tokenId,\\n            _balanceOfNFT(_tokenId, block.timestamp),\\n            _locked.end,\\n            uint(int256(_locked.amount)),\\n            badgeDescription\\n        );\\n    }\\n\\n    function balanceOfNFT(uint _tokenId) external view returns (uint) {\\n        if (ownership_change[_tokenId] == block.number) return 0;\\n        return _balanceOfNFT(_tokenId, block.timestamp);\\n    }\\n\\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\\n        return _balanceOfNFT(_tokenId, _t);\\n    }\\n\\n    /// @notice Measure voting power of `_tokenId` at block height `_block`\\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\\n    /// @param _tokenId User's wallet NFT\\n    /// @param _block Block to calculate the voting power at\\n    /// @return Voting power\\n    function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\\n        // Copying and pasting totalSupply code because Vyper cannot pass by\\n        // reference yet\\n        assert(_block <= block.number);\\n\\n        // Binary search\\n        uint _min = 0;\\n        uint _max = user_point_epoch[_tokenId];\\n        for (uint i = 0; i < 128; ++i) {\\n            // Will be always enough for 128-bit numbers\\n            if (_min >= _max) {\\n                break;\\n            }\\n            uint _mid = (_min + _max + 1) / 2;\\n            if (user_point_history[_tokenId][_mid].blk <= _block) {\\n                _min = _mid;\\n            } else {\\n                _max = _mid - 1;\\n            }\\n        }\\n\\n        Point memory upoint = user_point_history[_tokenId][_min];\\n\\n        uint max_epoch = epoch;\\n        uint _epoch = _find_block_epoch(_block, max_epoch);\\n        Point memory point_0 = point_history[_epoch];\\n        uint d_block = 0;\\n        uint d_t = 0;\\n        if (_epoch < max_epoch) {\\n            Point memory point_1 = point_history[_epoch + 1];\\n            d_block = point_1.blk - point_0.blk;\\n            d_t = point_1.ts - point_0.ts;\\n        } else {\\n            d_block = block.number - point_0.blk;\\n            d_t = block.timestamp - point_0.ts;\\n        }\\n        uint block_time = point_0.ts;\\n        if (d_block != 0) {\\n            block_time += (d_t * (_block - point_0.blk)) / d_block;\\n        }\\n\\n        upoint.bias -= upoint.slope * int128(int256(block_time - upoint.ts));\\n        if (upoint.bias >= 0) {\\n            return uint(uint128(upoint.bias));\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\\n        return _balanceOfAtNFT(_tokenId, _block);\\n    }\\n\\n    /// @notice Calculate total voting power at some point in the past\\n    /// @param point The point (bias/slope) to start search from\\n    /// @param t Time to calculate the total voting power at\\n    /// @return Total voting power at that time\\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\\n        Point memory last_point = point;\\n        uint t_i = (last_point.ts / WEEK) * WEEK;\\n        for (uint i = 0; i < 255; ++i) {\\n            t_i += WEEK;\\n            int128 d_slope = 0;\\n            if (t_i > t) {\\n                t_i = t;\\n            } else {\\n                d_slope = slope_changes[t_i];\\n            }\\n            last_point.bias -= last_point.slope * int128(int256(t_i - last_point.ts));\\n            if (t_i == t) {\\n                break;\\n            }\\n            last_point.slope += d_slope;\\n            last_point.ts = t_i;\\n        }\\n\\n        if (last_point.bias < 0) {\\n            last_point.bias = 0;\\n        }\\n        return uint(uint128(last_point.bias));\\n    }\\n\\n    /// @notice Calculate total voting power\\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\\n    /// @return Total voting power\\n    function totalSupplyAtT(uint t) public view returns (uint) {\\n        uint _epoch = epoch;\\n        Point memory last_point = point_history[_epoch];\\n        return _supply_at(last_point, t);\\n    }\\n\\n    function totalSupply() external view returns (uint) {\\n        return totalSupplyAtT(block.timestamp);\\n    }\\n\\n    /// @notice Calculate total voting power at some point in the past\\n    /// @param _block Block to calculate the total voting power at\\n    /// @return Total voting power at `_block`\\n    function totalSupplyAt(uint _block) external view returns (uint) {\\n        assert(_block <= block.number);\\n        uint _epoch = epoch;\\n        uint target_epoch = _find_block_epoch(_block, _epoch);\\n\\n        Point memory point = point_history[target_epoch];\\n        uint dt = 0;\\n        if (target_epoch < _epoch) {\\n            Point memory point_next = point_history[target_epoch + 1];\\n            if (point.blk != point_next.blk) {\\n                dt = ((_block - point.blk) * (point_next.ts - point.ts)) / (point_next.blk - point.blk);\\n            }\\n        } else {\\n            if (point.blk != block.number) {\\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\\n            }\\n        }\\n        // Now dt contains info on how far are we beyond point\\n        return _supply_at(point, point.ts + dt);\\n    }\\n\\n    function _tokenURI(uint _tokenId, uint _balanceOf, uint _locked_end, uint _value, string memory description) internal pure returns (string memory output) {\\n        output = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\" /><text x=\\\"10\\\" y=\\\"20\\\" class=\\\"base\\\">';\\n        output = string(abi.encodePacked(output, \\\"token \\\", toString(_tokenId), '</text><text x=\\\"10\\\" y=\\\"40\\\" class=\\\"base\\\">'));\\n        output = string(abi.encodePacked(output, \\\"balanceOf \\\", toString(_balanceOf), '</text><text x=\\\"10\\\" y=\\\"60\\\" class=\\\"base\\\">'));\\n        output = string(abi.encodePacked(output, \\\"locked_end \\\", toString(_locked_end), '</text><text x=\\\"10\\\" y=\\\"80\\\" class=\\\"base\\\">'));\\n        output = string(abi.encodePacked(output, \\\"value \\\", toString(_value), '</text></svg>'));\\n\\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"Badge #', toString(_tokenId), '\\\", \\\"description\\\": \\\"', description, '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\\\"}'))));\\n        output = string(abi.encodePacked('data:application/json;base64,', json));\\n    }\\n\\n    function toString(uint value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint temp = value;\\n        uint digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function _burn(uint _tokenId) internal {\\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \\\"caller is not owner nor approved\\\");\\n\\n        address owner = ownerOf(_tokenId);\\n\\n        // Clear approval\\n        approve(address(0), _tokenId);\\n        // Remove token\\n        _removeTokenFrom(msg.sender, _tokenId);\\n        emit Transfer(owner, address(0), _tokenId);\\n    }\\n}\\n\"\n    },\n    \"srcBuild/vesting/TokenVestingFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\nimport {Auth, Authority, ERC20, TokenVesting} from \\\"./TokenVesting.sol\\\";\\nimport {veAPHRA} from \\\"../veAPHRA.sol\\\";\\n/**\\n * @title TokenVestingFactory\\n * @dev A factory to deploy instances of TokenVesting for RSR, nothing more.\\n */\\ncontract TokenVestingFactory is Auth  {\\n\\n    event TokenVestingDeployed(address indexed location, address indexed recipient);\\n    veAPHRA public _ve;\\n    mapping (address => address) public vestingContracts;\\n    constructor(\\n        address GOVERNANCE_,\\n        address VE_APHRA_ADDR_\\n    ) Auth (GOVERNANCE_, Authority(address(0))) {\\n        _ve = veAPHRA(VE_APHRA_ADDR_);\\n    }\\n\\n    function deployVestingContract(address recipient, uint256 vestForThisManySeconds) requiresAuth external returns (address) {\\n\\n        TokenVesting vesting = new TokenVesting(\\n            recipient,\\n            block.timestamp,\\n            block.timestamp + vestForThisManySeconds\\n        );\\n\\n        vestingContracts[recipient] = address(vesting);\\n\\n        emit TokenVestingDeployed(address(vesting), recipient);\\n        return address(vesting);\\n    }\\n\\n    function clawbackVesting(ERC20 token, TokenVesting vesting) requiresAuth external {\\n        vesting.reclaimUnderlying(token, owner);\\n    }\\n\\n    //should we update ve before unlock switch happens\\n    function setVe(address newVEAPHRA_) requiresAuth external {\\n        require(!_ve.isUnlocked(), \\\"veAPHRA has already been unlocked, nothing can be done\\\");\\n        _ve = veAPHRA(newVEAPHRA_);\\n    }\\n\\n    function getVe() external view returns (address) {\\n        return address(_ve);\\n    }\\n\\n    function getVestingContract(address benefactor) external view returns (address) {\\n        return vestingContracts[benefactor];\\n    }\\n}\\n\"\n    },\n    \"srcBuild/vesting/TokenVesting.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport {ReentrancyGuard} from \\\"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\ninterface ve {\\n    function isUnlocked() external view returns (bool);\\n}\\n\\ninterface IVestingFactory {\\n    function getVe() external view returns (address);\\n}\\n\\n/**\\n * @title TokenVesting\\n * @dev This contract handles the vesting of ERC20 tokens for a given beneficiary. Custody of multiple tokens\\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\\n * The vesting schedule is customizable through the {vestedAmount} function.\\n *\\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\\n * be immediately releasable.\\n */\\ncontract TokenVesting is Auth {\\n    using SafeTransferLib for ERC20;\\n\\n    event ERC20Released(address indexed token, uint amount);\\n\\n    mapping(address => uint) private _erc20Released;\\n    address private immutable _beneficiary;\\n    uint private immutable _start;\\n    uint private immutable _duration;\\n\\n    /**\\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\\n     */\\n    constructor(\\n        address beneficiaryAddress,\\n        uint startTimestamp,\\n        uint durationSeconds\\n    ) Auth(msg.sender, Authority(address(0))) {\\n        require(beneficiaryAddress != address(0), \\\"VestingWallet: beneficiary is zero address\\\");\\n        _beneficiary = beneficiaryAddress;\\n        _start = startTimestamp;\\n        _duration = durationSeconds;\\n    }\\n\\n    /**\\n     * @dev The contract should be able to receive Eth.\\n     */\\n    receive() external payable virtual {}\\n\\n    function reclaimUnderlying(ERC20 token, address destination) external requiresAuth {\\n        uint reclaim = token.balanceOf(address(this)) - (vestedAmount(address(token), block.timestamp) - released(address(token)));\\n        token.safeTransfer(destination, reclaim);\\n    }\\n\\n    /**\\n     * @dev Getter for the beneficiary address.\\n     */\\n    function beneficiary() public view virtual returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    /**\\n     * @dev Getter for the start timestamp.\\n     */\\n    function start() public view virtual returns (uint256) {\\n        return _start;\\n    }\\n\\n    /**\\n     * @dev Getter for the vesting duration.\\n     */\\n    function duration() public view virtual returns (uint256) {\\n        return _duration;\\n    }\\n\\n    /**\\n     * @dev Amount of token already released\\n     */\\n    function released(address token) public view virtual returns (uint256) {\\n        return _erc20Released[token];\\n    }\\n\\n\\n\\n    /**\\n     * @dev Release the tokens that have already vested.\\n     *\\n     * Emits a {TokensReleased} event.\\n     */\\n    function release(address token) public virtual {\\n        uint256 releasable = vestedAmount(token, block.timestamp) - released(token);\\n        _erc20Released[token] += releasable;\\n        emit ERC20Released(token, releasable);\\n        ERC20(token).safeTransfer(beneficiary(), releasable);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\\n     */\\n    function vestedAmount(address token, uint timestamp) public view virtual returns (uint256) {\\n        return _vestingSchedule(ERC20(token).balanceOf(address(this)) + released(token), timestamp);\\n    }\\n\\n    /**\\n     * @dev Virtual implementation of the vesting formula. This returns the amout vested, as a function of time, for\\n     * an asset given its total historical allocation.\\n     */\\n    function _vestingSchedule(uint256 totalAllocation, uint timestamp) internal view virtual returns (uint256) {\\n\\n        if (!ve(IVestingFactory(owner).getVe()).isUnlocked()) {\\n            return 0;\\n        } else if (timestamp >= start() + duration()) {\\n            return totalAllocation;\\n        } else {\\n            return (totalAllocation * (timestamp - start())) / duration();\\n        }\\n    }\\n}\\n\"\n    },\n    \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private reentrancyStatus = 1;\\n\\n    modifier nonReentrant() {\\n        require(reentrancyStatus == 1, \\\"REENTRANCY\\\");\\n\\n        reentrancyStatus = 2;\\n\\n        _;\\n\\n        reentrancyStatus = 1;\\n    }\\n}\\n\"\n    },\n    \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"srcBuild/Voter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nlibrary Math {\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\ninterface IListingFee {\\n    function listing_fee() external view returns (uint);\\n}\\n\\ninterface erc20 {\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function balanceOf(address) external view returns (uint);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    function approve(address spender, uint value) external returns (bool);\\n}\\n\\ninterface ve {\\n    function token() external view returns (address);\\n    function balanceOfNFT(uint) external view returns (uint);\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function ownerOf(uint) external view returns (address);\\n    function transferFrom(address, address, uint) external;\\n    function attach(uint tokenId) external;\\n    function detach(uint tokenId) external;\\n    function voting(uint tokenId) external;\\n    function abstain(uint tokenId) external;\\n}\\n\\ninterface GaugeFactory {\\n    function createGauge(address, address, address) external returns (address);\\n}\\n\\ninterface BribeFactory {\\n    function createBribe() external returns (address);\\n}\\n\\ninterface IGauge {\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function stopDeposits() external;\\n    function openDeposits() external;\\n    function isDepositsOpen() external view returns (bool);\\n    function getReward(address account, address[] memory tokens) external;\\n    function left(address token) external view returns (uint);\\n}\\n\\ninterface IBribe {\\n    function _deposit(uint amount, uint tokenId) external;\\n    function _withdraw(uint amount, uint tokenId) external;\\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\\n}\\n\\ninterface IMinter {\\n    function update_period() external returns (uint);\\n}\\n\\ncontract Voter is Auth {\\n\\n    address public immutable _ve; // the ve token that governs these contracts\\n    address internal immutable base;\\n    address internal listingLP; //deprecated before it even began\\n    address internal listingFeeAddr; //deprecated before it even began\\n    address public immutable gaugefactory;\\n    address public immutable bribefactory;\\n    uint internal constant DURATION = 7 days; // rewards are released over 7 days\\n    address public minter;\\n    bool public openListing;\\n    uint public totalWeight; // total voting weight\\n\\n    address[] public assets; // all assets viable for incentives\\n    mapping(address => address) public gauges; // asset => gauge\\n    mapping(address => address) public assetForGauge; // gauge => asset\\n    mapping(address => address) public bribes; // gauge => bribe\\n    mapping(address => int256) public weights; // pool => weight\\n    mapping(uint => mapping(address => int256)) public votes; // nft => asset => votes\\n    mapping(uint => address[]) public assetVote; // nft => assets\\n    mapping(uint => uint) public usedWeights;  // nft => total voting weight of user\\n    mapping(address => bool) public isGauge;\\n    mapping(address => bool) public isWhitelisted;\\n\\n    event GaugeCreated(address indexed gauge, address creator, address indexed bribe, address indexed pool);\\n    event Voted(address indexed voter, uint tokenId, int256 weight);\\n    event Abstained(uint tokenId, int256 weight);\\n    event Deposit(address indexed lp, address indexed gauge, uint tokenId, uint amount);\\n    event Withdraw(address indexed lp, address indexed gauge, uint tokenId, uint amount);\\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\\n    event Whitelisted(address indexed whitelister, address indexed token);\\n    event DeListed(address indexed delister, address indexed token);\\n\\n    constructor(\\n        address _guardian,\\n        address _authority,\\n        address __ve,\\n        address _gauges,\\n        address _bribes\\n    ) Auth(_guardian, Authority(_authority)) {\\n        _ve = __ve;\\n        base = ve(__ve).token();\\n        gaugefactory = _gauges;\\n        bribefactory = _bribes;\\n        minter = msg.sender;\\n        openListing = false;\\n    }\\n\\n    // simple re-entrancy check\\n    uint internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function initialize(address[] memory _tokens, address _minter) external {\\n        require(msg.sender == minter);\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            _whitelist(_tokens[i]);\\n        }\\n        minter = _minter;\\n    }\\n\\n    function setListingFeeAddress(address listingFeeAddress_) external requiresAuth {\\n        listingFeeAddr = listingFeeAddress_;\\n    }\\n\\n    function listing_fee() public view returns (uint) {\\n        return IListingFee(listingFeeAddr).listing_fee();\\n    }\\n\\n    function reset(uint _tokenId) external {\\n        require(ve(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        _reset(_tokenId);\\n        ve(_ve).abstain(_tokenId);\\n    }\\n\\n    function _reset(uint _tokenId) internal {\\n        address[] storage _assetVote = assetVote[_tokenId];\\n        uint _assetVoteCnt = _assetVote.length;\\n        int256 _totalWeight = 0;\\n\\n        for (uint i = 0; i < _assetVoteCnt; i ++) {\\n            address _asset = _assetVote[i];\\n            int256 _votes = votes[_tokenId][_asset];\\n\\n            if (_votes != 0) {\\n                _updateFor(gauges[_asset]);\\n                weights[_asset] -= _votes;\\n                votes[_tokenId][_asset] -= _votes;\\n                if (_votes > 0) {\\n                    IBribe(bribes[gauges[_asset]])._withdraw(uint256(_votes), _tokenId);\\n                    _totalWeight += _votes;\\n                } else {\\n                    _totalWeight -= _votes;\\n                }\\n                emit Abstained(_tokenId, _votes);\\n            }\\n        }\\n        totalWeight -= uint256(_totalWeight);\\n        usedWeights[_tokenId] = 0;\\n        delete assetVote[_tokenId];\\n    }\\n\\n    function poke(uint _tokenId) external {\\n        address[] memory _assetVote = assetVote[_tokenId];\\n        uint _assetCnt = _assetVote.length;\\n        int256[] memory _weights = new int256[](_assetCnt);\\n\\n        for (uint i = 0; i < _assetCnt; i ++) {\\n            _weights[i] = votes[_tokenId][_assetVote[i]];\\n        }\\n\\n        _vote(_tokenId, _assetVote, _weights);\\n    }\\n\\n    function _vote(uint _tokenId, address[] memory _assetVote, int256[] memory _weights) internal {\\n        _reset(_tokenId);\\n        uint _assetCnt = _assetVote.length;\\n        int256 _weight = int256(ve(_ve).balanceOfNFT(_tokenId));\\n        int256 _totalVoteWeight = 0;\\n        int256 _totalWeight = 0;\\n        int256 _usedWeight = 0;\\n\\n        for (uint i = 0; i < _assetCnt; i++) {\\n            _totalVoteWeight += _weights[i] > 0 ? _weights[i] : -_weights[i];\\n        }\\n\\n        for (uint i = 0; i < _assetCnt; i++) {\\n            address _asset = _assetVote[i];\\n            address _gauge = gauges[_asset];\\n\\n            if (isGauge[_gauge] && IGauge(_gauge).isDepositsOpen()) {\\n                int256 _assetWeight = _weights[i] * _weight / _totalVoteWeight;\\n                require(votes[_tokenId][_asset] == 0);\\n                require(_assetWeight != 0);\\n                _updateFor(_gauge);\\n\\n                assetVote[_tokenId].push(_asset);\\n\\n                weights[_asset] += _assetWeight;\\n                votes[_tokenId][_asset] += _assetWeight;\\n                if (_assetWeight > 0) {\\n                    IBribe(bribes[_gauge])._deposit(uint256(_assetWeight), _tokenId);\\n                } else {\\n                    _assetWeight = -_assetWeight;\\n                }\\n                _usedWeight += _assetWeight;\\n                _totalWeight += _assetWeight;\\n                emit Voted(msg.sender, _tokenId, _assetWeight);\\n            }\\n        }\\n        if (_usedWeight > 0) ve(_ve).voting(_tokenId);\\n        totalWeight += uint256(_totalWeight);\\n        usedWeights[_tokenId] = uint256(_usedWeight);\\n    }\\n\\n    function vote(uint tokenId, address[] calldata _assetVote, int256[] calldata _weights) external {\\n        require(ve(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        require(_assetVote.length == _weights.length);\\n        _vote(tokenId, _assetVote, _weights);\\n    }\\n\\n    function gaugeStopDeposits(address _gauge) external requiresAuth {\\n        IGauge(_gauge).stopDeposits();\\n    }\\n\\n    function gaugeOpenDeposits(address _gauge) external requiresAuth {\\n        IGauge(_gauge).openDeposits();\\n    }\\n\\n    function whitelist(address _token) external {\\n        require(openListing, \\\"not open for general listing\\\");\\n\\n        _safeTransferFrom(listingLP, owner, minter, listing_fee());\\n\\n        _whitelist(_token);\\n    }\\n\\n    function enableOpenListing() external requiresAuth {\\n        openListing = true;\\n    }\\n\\n    function disableOpenListing() external requiresAuth {\\n        openListing = false;\\n    }\\n\\n    function removeListing(address _token) external requiresAuth {\\n        _removeListing(_token);\\n    }\\n\\n    function whitelistAsAuth(address _token) external requiresAuth {\\n        _whitelist(_token);\\n    }\\n\\n    function _removeListing(address _token) internal {\\n        require(isWhitelisted[_token]);\\n        isWhitelisted[_token] = false;\\n        emit DeListed(msg.sender, _token);\\n    }\\n\\n    function _whitelist(address _token) internal {\\n        require(!isWhitelisted[_token]);\\n        isWhitelisted[_token] = true;\\n        emit Whitelisted(msg.sender, _token);\\n    }\\n\\n    function createGauge(address _asset) external returns (address) {\\n        require(gauges[_asset] == address(0x0), \\\"exists\\\");\\n        require(isWhitelisted[_asset], \\\"!whitelisted\\\");\\n        address _bribe = BribeFactory(bribefactory).createBribe();\\n        address _gauge = GaugeFactory(gaugefactory).createGauge(_asset, _bribe, _ve);\\n        erc20(base).approve(_gauge, type(uint).max);\\n        bribes[_gauge] = _bribe;\\n        gauges[_asset] = _gauge;\\n        assetForGauge[_gauge] = _asset;\\n        isGauge[_gauge] = true;\\n        IGauge(_gauge).openDeposits();\\n        _updateFor(_gauge);\\n        assets.push(_asset);\\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _asset);\\n        return _gauge;\\n    }\\n\\n    function attachTokenToGauge(uint tokenId, address account) external {\\n        require(isGauge[msg.sender]);\\n        if (tokenId > 0) ve(_ve).attach(tokenId);\\n        emit Attach(account, msg.sender, tokenId);\\n    }\\n\\n    function emitDeposit(uint tokenId, address account, uint amount) external {\\n        require(isGauge[msg.sender]);\\n        emit Deposit(account, msg.sender, tokenId, amount);\\n    }\\n\\n    function detachTokenFromGauge(uint tokenId, address account) external {\\n        require(isGauge[msg.sender]);\\n        if (tokenId > 0) ve(_ve).detach(tokenId);\\n        emit Detach(account, msg.sender, tokenId);\\n    }\\n\\n    function emitWithdraw(uint tokenId, address account, uint amount) external {\\n        require(isGauge[msg.sender]);\\n        emit Withdraw(account, msg.sender, tokenId, amount);\\n    }\\n\\n    function length() external view returns (uint) {\\n        return assets.length;\\n    }\\n\\n    uint internal index;\\n    mapping(address => uint) internal supplyIndex;\\n    mapping(address => uint) public claimable;\\n\\n    function notifyRewardAmount(uint amount) external {\\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\\n        uint256 _ratio = amount * 1e18 / totalWeight; // 1e18 adjustment is removed during claim\\n        if (_ratio > 0) {\\n            index += _ratio;\\n        }\\n        emit NotifyReward(msg.sender, base, amount);\\n    }\\n\\n    function updateFor(address[] memory _gauges) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            _updateFor(_gauges[i]);\\n        }\\n    }\\n\\n    function updateForRange(uint start, uint end) public {\\n        for (uint i = start; i < end; i++) {\\n            _updateFor(gauges[assets[i]]);\\n        }\\n    }\\n\\n    function updateAll() external {\\n        updateForRange(0, assets.length);\\n    }\\n\\n    function updateGauge(address _gauge) external {\\n        _updateFor(_gauge);\\n    }\\n\\n    function _updateFor(address _gauge) internal {\\n        address _asset = assetForGauge[_gauge];\\n        int256 _supplied = weights[_asset];\\n        if (_supplied > 0) {\\n            uint _supplyIndex = supplyIndex[_gauge];\\n            uint _index = index; // get global index0 for accumulated distro\\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\\n            uint _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\\n            if (_delta > 0) {\\n                uint _share = uint(_supplied) * _delta / 1e18; // add accrued difference for each supplied token\\n                claimable[_gauge] += _share;\\n            }\\n        } else {\\n            supplyIndex[_gauge] = index; // new users are set to the default global state\\n        }\\n    }\\n\\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\\n        }\\n    }\\n\\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\\n        require(ve(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        for (uint i = 0; i < _bribes.length; i++) {\\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\\n        }\\n    }\\n\\n    function distribute(address _gauge) public lock {\\n        IMinter(minter).update_period();\\n        _updateFor(_gauge);\\n        uint _claimable = claimable[_gauge];\\n        if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\\n            claimable[_gauge] = 0;\\n            IGauge(_gauge).notifyRewardAmount(base, _claimable);\\n            emit DistributeReward(msg.sender, _gauge, _claimable);\\n        }\\n    }\\n\\n    function distro() external {\\n        distribute(0, assets.length);\\n    }\\n\\n    function distribute() external {\\n        distribute(0, assets.length);\\n    }\\n\\n    function distribute(uint start, uint finish) public {\\n        for (uint x = start; x < finish; x++) {\\n            distribute(gauges[assets[x]]);\\n        }\\n    }\\n\\n    function distribute(address[] memory _gauges) external {\\n        for (uint x = 0; x < _gauges.length; x++) {\\n            distribute(_gauges[x]);\\n        }\\n    }\\n\\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\"\n    },\n    \"srcBuild/strategies/USDVUnderPegStrategy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {SafeCastLib} from \\\"@rari-capital/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../FixedPointMathLib.sol\\\"; //added fdiv and fmul TODO: looking at new rari/next code perhaps we're moving to a new library\\nimport {ERC20Strategy} from \\\"../interfaces/Strategy.sol\\\";\\nimport {VaderGateway, IVaderMinter} from \\\"../VaderGateway.sol\\\";\\nimport {IERC20, IUniswap, IXVader, ICurve} from \\\"../interfaces/StrategyInterfaces.sol\\\";\\n\\ncontract USDVUnderPegStrategy is Auth, ERC20(\\\"USDVUnderPegStrategy\\\", \\\"aUSDVUnderPegStrategy\\\", 18), ERC20Strategy {\\n\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    ERC20 public constant DAI = ERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F));  //our flip\\n    ERC20 public constant USDC = ERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)); //our flap\\n    ERC20 public constant USDT = ERC20(address(0xdAC17F958D2ee523a2206206994597C13D831ec7)); //our flop\\n    ERC20 public constant USDV = ERC20(address(0xea3Fb6f331735252E7Bfb0b24b3B761301293DBe));\\n\\n    ERC20 public immutable WETH;\\n    ICurve public immutable POOL;\\n    IUniswap public immutable UNISWAP;\\n    IXVader public immutable XVADER;\\n    IVaderMinter public immutable VADERGATEWAY;\\n\\n    constructor(\\n        ERC20 UNDERLYING_,\\n        address GOVERNANCE_,\\n        Authority AUTHORITY_,\\n        address POOL_,\\n        address XVADER_,\\n        address VADERGATEWAY_,\\n        address UNIROUTER_,\\n        address WETH_\\n    ) Auth(GOVERNANCE_, AUTHORITY_) { //set authority to something that enables operators for aphra\\n        UNDERLYING = UNDERLYING_; //vader\\n        BASE_UNIT = 10**UNDERLYING_.decimals();\\n\\n        POOL = ICurve(POOL_);\\n        XVADER = IXVader(XVADER_);\\n\\n        VADERGATEWAY = IVaderMinter(VADERGATEWAY_); // our partner minter\\n        UNISWAP = IUniswap(UNIROUTER_);\\n        WETH = ERC20(WETH_);\\n\\n        USDV.safeApprove(POOL_, type(uint256).max); //set unlimited approval to the pool for usdv\\n        DAI.safeApprove(UNIROUTER_, type(uint256).max);\\n        USDC.safeApprove(UNIROUTER_, type(uint256).max);\\n        USDT.safeApprove(UNIROUTER_, type(uint256).max);\\n        WETH.safeApprove(UNIROUTER_, type(uint256).max); //prob not needed\\n        UNDERLYING.safeApprove(XVADER_, type(uint256).max);\\n        UNDERLYING.safeApprove(VADERGATEWAY_, type(uint256).max);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             STRATEGY LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n\\n    function hit(uint256 uAmount_, int128 enterCoin_, address[] memory path_) external requiresAuth () {\\n        uint vAmount = VADERGATEWAY.partnerBurn(uAmount_, uint(1));\\n        uint uAmount = _swapToUnderlying(vAmount, enterCoin_, path_);\\n        require(uAmount > uAmount_, \\\"Failed to arb for profit\\\");\\n    unchecked {\\n        require( POOL.balances(1) * 1e3 / (POOL.balances(0)) <= 1e3, \\\"peg must be at or below 1\\\");\\n    }\\n    }\\n\\n    function isCEther() external pure override returns (bool) {\\n        return false;\\n    }\\n\\n    function ethToUnderlying(uint256 ethAmount_) external view returns (uint256) {\\n        if (ethAmount_ == 0) {\\n            return 0;\\n        }\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(WETH);\\n        path[1] = address(UNDERLYING);\\n        uint256[] memory amounts = UNISWAP.getAmountsOut(ethAmount_, path);\\n\\n        return amounts[amounts.length - 1];\\n    }\\n\\n    function underlying() external view override returns (ERC20) {\\n        return UNDERLYING;\\n    }\\n\\n    function mint(uint256 amount) external requiresAuth override returns (uint256) {\\n        _mint(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), amount);\\n        return 0;\\n    }\\n\\n    function redeemUnderlying(uint256 amount) external override returns (uint256) {\\n        _burn(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\\n\\n        UNDERLYING.safeTransfer(msg.sender, amount);\\n\\n        return 0;\\n    }\\n\\n    function balanceOfUnderlying(address user) external view override returns (uint256) {\\n        return balanceOf[user].fmul(_exchangeRate(), BASE_UNIT);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                            INTERNAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    ERC20 internal immutable UNDERLYING;\\n\\n    uint256 internal immutable BASE_UNIT;\\n\\n\\n    function _swapToUnderlying(uint vAmountIn_, int128 enterCoin_, address[] memory path_) internal returns (uint oAmount) {\\n\\n\\n        //we have vader, we want to get usdv, so we need dai/usdc/usdt first\\n\\n        //get best exit address\\n        //get mins for swap\\n\\n        address enterCoinAddress = address(DAI);\\n        if (enterCoin_ == int128(2)) {\\n            enterCoinAddress = address(USDC);\\n        } else if (enterCoin_ == int128(3)) {\\n            enterCoinAddress = address(USDT);\\n        }\\n\\n\\n        address[] memory path;\\n        if(path_.length == 0) {\\n            path = new address[](3);\\n            path[0] = address(UNDERLYING);\\n            path[1] = address(WETH);\\n            path[2] = enterCoinAddress; //vader eth pool has the best depth for vader\\n        } else {\\n            path = path_;\\n        }\\n\\n        uint256[] memory amounts = UNISWAP.getAmountsOut(vAmountIn_, path);\\n        uint256 swapOut = amounts[amounts.length - 1];\\n\\n        UNISWAP.swapExactTokensForTokens(\\n            vAmountIn_,\\n            swapOut,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        uint256 usdvBalanceBefore;\\n        unchecked {\\n            usdvBalanceBefore = USDV.balanceOf(address(this));\\n        }\\n\\n        POOL.exchange_underlying(enterCoin_, int128(0), swapOut, uint(1));\\n\\n        unchecked {\\n            oAmount = USDV.balanceOf(address(this)) - usdvBalanceBefore;\\n        }\\n\\n    }\\n\\n    function _exchangeRate() internal view returns (uint256) {\\n        uint256 cTokenSupply = totalSupply;\\n\\n        if (cTokenSupply == 0) return BASE_UNIT;\\n        uint underlyingBalance;\\n        unchecked {\\n            underlyingBalance = UNDERLYING.balanceOf(address(this));\\n        }\\n        return underlyingBalance.fdiv(cTokenSupply, BASE_UNIT);\\n    }\\n}\\n\\n\"\n    },\n    \"@rari-capital/solmate/src/utils/SafeCastLib.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x <= type(uint248).max);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x <= type(uint96).max);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x <= type(uint64).max);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max);\\n\\n        y = uint32(x);\\n    }\\n}\\n\"\n    },\n    \"srcBuild/FixedPointMathLib.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /* ///////////////////////////////////////////////////////////////\\n    SIMPLIFIED FIXED POINT OPERATIONS\\n    ////////////////////////////////////////////////////////////// */\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n        // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n        // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\\n                revert(0, 0)\\n            }\\n\\n        // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // First, divide z - 1 by the denominator and add 1.\\n        // Then multiply it by 0 if z is zero, or 1 otherwise.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                // 0 ** 0 = 1\\n                    z := denominator\\n                }\\n                default {\\n                // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                // If n is even, store denominator in z for now.\\n                    z := denominator\\n                }\\n                default {\\n                // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, denominator)\\n\\n                for {\\n                // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                // Revert immediately if x ** 2 would overflow.\\n                // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Set x to scaled xxRound.\\n                    x := div(xxRound, denominator)\\n\\n                // If n is even:\\n                    if mod(n, 2) {\\n                    // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                    // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                        // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                    // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                    // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                    // Return properly scaled zxRound.\\n                        z := div(zxRound, denominator)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n        // Start off with z at 1.\\n            z := 1\\n\\n        // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n        // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z)\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z)\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z)\\n            }\\n            if iszero(lt(y, 0x8)) {\\n            // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n        // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n        // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n        // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"srcBuild/interfaces/Strategy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\n/// @dev Designed for out of the box compatibility with Fuse cTokens.\\n/// @dev Like cTokens, strategies must be transferrable ERC20s.\\nabstract contract Strategy is ERC20 {\\n    /// @notice Returns whether the strategy accepts ETH or an ERC20.\\n    /// @return True if the strategy accepts ETH, false otherwise.\\n    /// @dev Only present in Fuse cTokens, not Compound cTokens.\\n    function isCEther() external view virtual returns (bool);\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the strategy.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external virtual returns (uint256);\\n\\n    /// @notice Returns a user's strategy balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's strategy balance in underlying tokens.\\n    /// @dev May mutate the state of the strategy by accruing interest.\\n    function balanceOfUnderlying(address user) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\\n/// @dev Designed for out of the box compatibility with Fuse cERC20s.\\nabstract contract ERC20Strategy is Strategy {\\n    /// @notice Returns the underlying ERC20 token the strategy accepts.\\n    /// @return The underlying ERC20 token the strategy accepts.\\n    function underlying() external view virtual returns (ERC20);\\n\\n    /// @notice Deposit a specific amount of underlying tokens into the strategy.\\n    /// @param amount The amount of underlying tokens to deposit.\\n    /// @return An error code, or 0 if the deposit was successful.\\n    function mint(uint256 amount) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ETH.\\n/// @dev Designed for out of the box compatibility with Fuse cEther.\\nabstract contract ETHStrategy is Strategy {\\n    /// @notice Deposit a specific amount of ETH into the strategy.\\n    /// @dev The amount of ETH is specified via msg.value. Reverts on error.\\n    function mint() external payable virtual;\\n}\\n\"\n    },\n    \"srcBuild/VaderGateway.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {SafeCastLib} from \\\"@rari-capital/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {IVaderMinter} from \\\"./interfaces/vader/IVaderMinter.sol\\\";\\n\\ncontract VaderGateway is Auth, IVaderMinter {\\n\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n    using SafeCastLib for uint256;\\n\\n    IVaderMinter public immutable VADERMINTER;\\n\\n    ERC20 public immutable VADER;\\n    ERC20 public immutable USDV;\\n\\n    constructor(\\n        address VADERMINTER_,\\n        address GOVERNANCE_,\\n        Authority AUTHORITY_,\\n        address VADER_,\\n        address USDV_\\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_))\\n    {\\n        VADERMINTER = IVaderMinter(VADERMINTER_);\\n        VADER = ERC20(VADER_);\\n        USDV = ERC20(USDV_);\\n\\n        //set approvals\\n        VADER.safeApprove(VADERMINTER_, type(uint256).max);\\n        VADER.safeApprove(address(USDV), type(uint256).max);\\n        USDV.safeApprove(VADERMINTER_, type(uint256).max);\\n    }\\n\\n\\n    function lbt() external view returns (address) {\\n        return VADERMINTER.lbt();\\n    }\\n\\n    // The 24 hour limits on USDV mints that are available for public minting and burning as well as the fee.\\n    function dailyLimits() external view returns (Limits memory) {\\n        return VADERMINTER.dailyLimits();\\n    }\\n\\n    // The current cycle end timestamp\\n    function cycleTimestamp() external view returns (uint) {\\n        return VADERMINTER.cycleTimestamp();\\n    }\\n\\n    // The current cycle cumulative mints\\n    function cycleMints() external view returns (uint) {\\n        return VADERMINTER.cycleMints();\\n    }\\n\\n    // The current cycle cumulative burns\\n    function cycleBurns() external view returns (uint){\\n        return VADERMINTER.cycleBurns();\\n    }\\n\\n    function partnerLimits(address partner) external view returns (Limits memory){\\n        return VADERMINTER.partnerLimits(partner);\\n    }\\n\\n    // USDV Contract for Mint / Burn Operations\\n    function usdv() external view returns (address) {\\n        return VADERMINTER.usdv();\\n    }\\n\\n    /*\\n     * @dev Partner mint function that receives Vader and mints USDV.\\n     * @param vAmount Vader amount to burn.\\n     * @returns uAmount in USDV, represents the USDV amount received from the mint.\\n     *\\n     * Requirements:\\n     * - Can only be called by whitelisted partners.\\n     **/\\n    function partnerMint(uint256 vAmount, uint256 uMinOut) external requiresAuth returns (uint256 uAmount) {\\n        VADER.transferFrom(msg.sender, address(this), vAmount);\\n\\n        uAmount = VADERMINTER.partnerMint(vAmount, uMinOut);\\n\\n        USDV.safeTransfer(msg.sender, uAmount);\\n    }\\n    /*\\n     * @dev Partner burn function that receives USDV and mints Vader.\\n     * @param uAmount USDV amount to burn.\\n     * @returns vAmount in Vader, represents the Vader amount received from the mint.\\n     *\\n     * Requirements:\\n     * - Can only be called by whitelisted partners.\\n     **/\\n    function partnerBurn(uint256 uAmount, uint256 vMinOut) external requiresAuth returns (uint256 vAmount) {\\n        USDV.transferFrom(msg.sender, address(this), uAmount);\\n        vAmount = VADERMINTER.partnerBurn(uAmount, vMinOut);\\n        VADER.safeTransfer(msg.sender, vAmount);\\n    }\\n\\n}\\n\"\n    },\n    \"srcBuild/interfaces/StrategyInterfaces.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\ninterface IUniswap {\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    )\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] memory path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] memory path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n}\\n\\ninterface ICurve {\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function balances(uint256) external view returns (uint256);\\n}\\n\\ninterface IXVader is IERC20 {\\n    function enter(uint256 amount) external;\\n    function leave(uint256 share) external;\\n}\\n\"\n    },\n    \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            COMMON BASE UNITS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant YAD = 1e8;\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant RAD = 1e45;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n            // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\\n                revert(0, 0)\\n            }\\n\\n            // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function fpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := baseUnit\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store baseUnit in z for now.\\n                    z := baseUnit\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, baseUnit)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, baseUnit)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, baseUnit)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z)\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z)\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z)\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"srcBuild/interfaces/vader/IVaderMinter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\ninterface IVaderMinter {\\n    struct Limits {\\n        uint256 fee;\\n        uint256 mintLimit;\\n        uint256 burnLimit;\\n    }\\n\\n    event PublicMintCapChanged(\\n        uint256 previousPublicMintCap,\\n        uint256 publicMintCap\\n    );\\n\\n    event PublicMintFeeChanged(\\n        uint256 previousPublicMintFee,\\n        uint256 publicMintFee\\n    );\\n\\n    event PartnerMintCapChanged(\\n        uint256 previousPartnerMintCap,\\n        uint256 partnerMintCap\\n    );\\n\\n    event PartnerMintFeeChanged(\\n        uint256 previousPartnercMintFee,\\n        uint256 partnerMintFee\\n    );\\n\\n    event DailyLimitsChanged(Limits previousLimits, Limits nextLimits);\\n    event WhitelistPartner(\\n        address partner,\\n        uint256 mintLimit,\\n        uint256 burnLimit,\\n        uint256 fee\\n    );\\n\\n    function lbt() external view returns (address);\\n\\n    // The 24 hour limits on USDV mints that are available for public minting and burning as well as the fee.\\n    function dailyLimits() external view returns (Limits memory);\\n\\n    // The current cycle end timestamp\\n    function cycleTimestamp() external view returns (uint);\\n\\n    // The current cycle cumulative mints\\n    function cycleMints() external view returns (uint);\\n\\n    // The current cycle cumulative burns\\n    function cycleBurns() external view returns (uint);\\n\\n    function partnerLimits(address) external view returns (Limits memory);\\n\\n    // USDV Contract for Mint / Burn Operations\\n    function usdv() external view returns (address);\\n\\n    function partnerMint(uint256 vAmount, uint256 uAmountMinOut) external returns (uint256 uAmount);\\n\\n    function partnerBurn(uint256 uAmount, uint256 vAmountMinOut) external returns (uint256 vAmount);\\n}\\n\"\n    },\n    \"srcBuild/strategies/USDVOverPegStrategy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {SafeCastLib} from \\\"@rari-capital/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../FixedPointMathLib.sol\\\";\\nimport {ERC20Strategy} from \\\"../interfaces/Strategy.sol\\\";\\nimport {VaderGateway, IVaderMinter} from \\\"../VaderGateway.sol\\\";\\nimport {IERC20, IUniswap, IXVader, ICurve} from \\\"../interfaces/StrategyInterfaces.sol\\\";\\n\\ncontract USDVOverPegStrategy is Auth, ERC20(\\\"USDVOverPegStrategy\\\", \\\"aUSDVOverPegStrategy\\\", 18), ERC20Strategy {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    ERC20 public constant DAI = ERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F));  //our flip\\n    ERC20 public constant USDC = ERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)); //our flap\\n    ERC20 public constant USDT = ERC20(address(0xdAC17F958D2ee523a2206206994597C13D831ec7)); //our flop\\n    ERC20 public constant USDV = ERC20(address(0xea3Fb6f331735252E7Bfb0b24b3B761301293DBe));\\n\\n    ERC20 public immutable WETH;\\n    ICurve public immutable POOL;\\n    IUniswap public immutable UNISWAP;\\n    IXVader public immutable XVADER;\\n    IVaderMinter public immutable VADERGATEWAY;\\n\\n    constructor(\\n        ERC20 UNDERLYING_,\\n        address GOVERNANCE_,\\n        Authority AUTHORITY_,\\n        address POOL_,\\n        address XVADER_,\\n        address VADERGATEWAY_,\\n        address UNIROUTER_,\\n        address WETH_\\n    ) Auth(GOVERNANCE_, AUTHORITY_) { //set authority to something that enables operators for aphra\\n        UNDERLYING = UNDERLYING_; //vader\\n        BASE_UNIT = 10e18;\\n\\n        POOL = ICurve(POOL_);\\n        XVADER = IXVader(XVADER_);\\n\\n        VADERGATEWAY = IVaderMinter(VADERGATEWAY_); // our partner minter\\n        UNISWAP = IUniswap(UNIROUTER_);\\n        WETH = ERC20(WETH_);\\n\\n        USDV.safeApprove(POOL_, type(uint256).max); //set unlimited approval to the pool for usdv\\n        DAI.safeApprove(UNIROUTER_, type(uint256).max);\\n        USDC.safeApprove(UNIROUTER_, type(uint256).max);\\n        USDT.safeApprove(UNIROUTER_, type(uint256).max);\\n        WETH.safeApprove(UNIROUTER_, type(uint256).max); //prob not needed\\n        UNDERLYING.safeApprove(XVADER_, type(uint256).max);\\n        UNDERLYING.safeApprove(VADERGATEWAY_, type(uint256).max);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             STRATEGY LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n\\n    function hit(uint256 vAmount_, int128 exitCoin_, address[] memory pathToVader_) external requiresAuth () {\\n        _unstakeUnderlying(vAmount_);\\n        uint uAmount = VADERGATEWAY.partnerMint(UNDERLYING.balanceOf(address(this)), uint(1));\\n        uint vAmount = _swapUSDVToVader(uAmount, exitCoin_, pathToVader_);\\n        _stakeUnderlying(vAmount);\\n        require(vAmount > vAmount_, \\\"Failed to arb for profit\\\");\\n    unchecked {\\n        require( POOL.balances(1) * 1e3 / (POOL.balances(0)) >= 1e3, \\\"peg must be at or above 1\\\");\\n    }\\n\\n    }\\n\\n    function isCEther() external pure override returns (bool) {\\n        return false;\\n    }\\n\\n    function ethToUnderlying(uint256 ethAmount_) external view returns (uint256) {\\n        if (ethAmount_ == 0) {\\n            return 0;\\n        }\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(WETH);\\n        path[1] = address(UNDERLYING);\\n        uint256[] memory amounts = UNISWAP.getAmountsOut(ethAmount_, path);\\n\\n        return amounts[amounts.length - 1];\\n    }\\n\\n    function underlying() external view override returns (ERC20) {\\n        return UNDERLYING;\\n    }\\n\\n    function mint(uint256 amount) external requiresAuth override returns (uint256) {\\n        _mint(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), amount);\\n        _stakeUnderlying(UNDERLYING.balanceOf(address(this)));\\n        return 0;\\n    }\\n\\n    function redeemUnderlying(uint256 amount) external override returns (uint256) {\\n        _burn(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\\n\\n        if (UNDERLYING.balanceOf(address(this)) < amount) {\\n            uint leaveAmount = amount - UNDERLYING.balanceOf(address(this));\\n            _unstakeUnderlying(leaveAmount);\\n        }\\n        UNDERLYING.safeTransfer(msg.sender, amount);\\n\\n        return 0;\\n    }\\n\\n    function balanceOfUnderlying(address user) external view override returns (uint256) {\\n        return balanceOf[user].fmul(_exchangeRate(), BASE_UNIT);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                            INTERNAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    ERC20 internal immutable UNDERLYING;\\n\\n    uint256 internal immutable BASE_UNIT;\\n\\n    function _stakeUnderlying(uint vAmount) internal {\\n        XVADER.enter(vAmount);\\n    }\\n\\n    function _computeStakedSharesForUnderlying(uint vAmount) internal view returns(uint256) {\\n        return (vAmount * XVADER.totalSupply()) / UNDERLYING.balanceOf(address(XVADER));\\n    }\\n\\n    function _unstakeUnderlying(uint vAmount) internal {\\n        uint shares = _computeStakedSharesForUnderlying(vAmount);\\n        XVADER.leave(shares);\\n    }\\n\\n    function _swapUSDVToVader(uint uAmount_, int128 exitCoin_, address[] memory path_) internal returns (uint vAmount) {\\n        //get best exit address\\n        //get mins for swap\\n        address exitCoinAddr = address(DAI);\\n        if (exitCoin_ == int128(2)) {\\n            exitCoinAddr = address(USDC);\\n        } else if (exitCoin_ == int128(3)) {\\n            exitCoinAddr = address(USDT);\\n        }\\n        POOL.exchange_underlying(0, exitCoin_, uAmount_, uint(1));\\n\\n        address[] memory path;\\n        if(path_.length == 0) {\\n            path = new address[](3);\\n            path[0] = exitCoinAddr;\\n            path[1] = address(WETH);\\n            path[2] = address(UNDERLYING); //vader eth pool has the best depth for vader\\n        } else {\\n            path = path_;\\n        }\\n\\n        uint256 amountIn = ERC20(exitCoinAddr).balanceOf(address(this));\\n        uint256[] memory amounts = UNISWAP.getAmountsOut(amountIn, path);\\n        vAmount = amounts[amounts.length - 1];\\n        UNISWAP.swapExactTokensForTokens(\\n            amountIn,\\n            vAmount,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n    }\\n\\n    function _computeStakedUnderlying() internal view returns (uint256) {\\n        return (XVADER.balanceOf(address(this)) * UNDERLYING.balanceOf(address(XVADER))) / XVADER.totalSupply();\\n    }\\n\\n    function _exchangeRate() internal view returns (uint256) {\\n        uint256 cTokenSupply = totalSupply;\\n\\n        if (cTokenSupply == 0) return BASE_UNIT;\\n        uint underlyingBalance;\\n        uint stakedBalance = _computeStakedUnderlying();\\n        unchecked {\\n            underlyingBalance = UNDERLYING.balanceOf(address(this)) + stakedBalance;\\n        }\\n        return underlyingBalance.fdiv(cTokenSupply, BASE_UNIT);\\n    }\\n}\\n\\n\"\n    },\n    \"srcBuild/Vault.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {WETH} from \\\"@rari-capital/solmate/src/tokens/WETH.sol\\\";\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeCastLib} from \\\"@rari-capital/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./FixedPointMathLib.sol\\\";\\n\\nimport {Strategy, ERC20Strategy, ETHStrategy} from \\\"./interfaces/Strategy.sol\\\";\\n\\n/// @title Aphra Vault (avToken)\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Flexible, minimalist, and gas-optimized yield\\n/// aggregator for earning interest on any ERC20 token.\\n/// @notice changes from original are to rename Rari -> Aphra tokens and any usage of rvToken => avToken\\ncontract Vault is ERC20, Auth {\\n    using SafeCastLib for uint256;\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The maximum number of elements allowed on the withdrawal stack.\\n    /// @dev Needed to prevent denial of service attacks by queue operators.\\n    uint256 internal constant MAX_WITHDRAWAL_STACK_SIZE = 32;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                IMMUTABLES\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The underlying token the Vault accepts.\\n    ERC20 public immutable UNDERLYING;\\n\\n    /// @notice The base unit of the underlying token and hence avToken.\\n    /// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\\n    uint256 internal immutable BASE_UNIT;\\n\\n    /// @notice Creates a new Vault that accepts a specific underlying token.\\n    /// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\\n    constructor(ERC20 _UNDERLYING)\\n        ERC20(\\n            // ex:Aphra Vader Vault\\n            string(abi.encodePacked(\\\"Aphra \\\", _UNDERLYING.name(), \\\" Vault\\\")),\\n            // ex: avVader\\n            string(abi.encodePacked(\\\"av\\\", _UNDERLYING.symbol())),\\n            // ex: 18\\n            _UNDERLYING.decimals()\\n        )\\n        Auth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\\n    {\\n        UNDERLYING = _UNDERLYING;\\n\\n        BASE_UNIT = 10**decimals;\\n\\n        // Prevent minting of avTokens until\\n        // the initialize function is called.\\n        totalSupply = type(uint256).max;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                           FEE CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The percentage of profit recognized each harvest to reserve as fees.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public feePercent;\\n\\n    /// @notice Emitted when the fee percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newFeePercent The new fee percentage.\\n    event FeePercentUpdated(address indexed user, uint256 newFeePercent);\\n\\n    /// @notice Sets a new fee percentage.\\n    /// @param newFeePercent The new fee percentage.\\n    function setFeePercent(uint256 newFeePercent) external requiresAuth {\\n        // A fee percentage over 100% doesn't make sense.\\n        require(newFeePercent <= 1e18, \\\"FEE_TOO_HIGH\\\");\\n\\n        // Update the fee percentage.\\n        feePercent = newFeePercent;\\n\\n        emit FeePercentUpdated(msg.sender, newFeePercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        HARVEST CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the harvest window is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestWindow The new harvest window.\\n    event HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\\n\\n    /// @notice Emitted when the harvest delay is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The new harvest delay.\\n    event HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The scheduled updated harvest delay.\\n    event HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice The period in seconds during which multiple harvests can occur\\n    /// regardless if they are taking place before the harvest delay has elapsed.\\n    /// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\\n    uint128 public harvestWindow;\\n\\n    /// @notice The period in seconds over which locked profit is unlocked.\\n    /// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\\n    uint64 public harvestDelay;\\n\\n    /// @notice The value that will replace harvestDelay next harvest.\\n    /// @dev In the case that the next delay is 0, no update will be applied.\\n    uint64 public nextHarvestDelay;\\n\\n    /// @notice Sets a new harvest window.\\n    /// @param newHarvestWindow The new harvest window.\\n    /// @dev The Vault's harvestDelay must already be set before calling.\\n    function setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\\n        // A harvest window longer than the harvest delay doesn't make sense.\\n        require(newHarvestWindow <= harvestDelay, \\\"WINDOW_TOO_LONG\\\");\\n\\n        // Update the harvest window.\\n        harvestWindow = newHarvestWindow;\\n\\n        emit HarvestWindowUpdated(msg.sender, newHarvestWindow);\\n    }\\n\\n    /// @notice Sets a new harvest delay.\\n    /// @param newHarvestDelay The new harvest delay to set.\\n    /// @dev If the current harvest delay is 0, meaning it has not\\n    /// been set before, it will be updated immediately, otherwise\\n    /// it will be scheduled to take effect after the next harvest.\\n    function setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\\n        // A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\\n        require(newHarvestDelay != 0, \\\"DELAY_CANNOT_BE_ZERO\\\");\\n\\n        // A harvest delay longer than 1 year doesn't make sense.\\n        require(newHarvestDelay <= 365 days, \\\"DELAY_TOO_LONG\\\");\\n\\n        // If the harvest delay is 0, meaning it has not been set before:\\n        if (harvestDelay == 0) {\\n            // We'll apply the update immediately.\\n            harvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        } else {\\n            // We'll apply the update next harvest.\\n            nextHarvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       TARGET FLOAT CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The desired percentage of the Vault's holdings to keep as float.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public targetFloatPercent;\\n\\n    /// @notice Emitted when the target float percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    event TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\\n\\n    /// @notice Set a new target float percentage.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    function setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\\n        // A target float percentage over 100% doesn't make sense.\\n        require(newTargetFloatPercent <= 1e18, \\\"TARGET_TOO_HIGH\\\");\\n\\n        // Update the target float percentage.\\n        targetFloatPercent = newTargetFloatPercent;\\n\\n        emit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                   UNDERLYING IS WETH CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Whether the Vault should treat the underlying token as WETH compatible.\\n    /// @dev If enabled the Vault will allow trusting strategies that accept Ether.\\n    bool public underlyingIsWETH;\\n\\n    /// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\\n    event UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\\n\\n    /// @notice Sets whether the Vault treats the underlying as WETH.\\n    /// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\\n    /// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\\n    function setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\\n        // Ensure the underlying token's decimals match ETH if is WETH being set to true.\\n        require(!newUnderlyingIsWETH || UNDERLYING.decimals() == 18, \\\"WRONG_DECIMALS\\\");\\n\\n        // Update whether the Vault treats the underlying as WETH.\\n        underlyingIsWETH = newUnderlyingIsWETH;\\n\\n        emit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          STRATEGY STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\\n    /// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\\n    uint256 public totalStrategyHoldings;\\n\\n    /// @dev Packed struct of strategy data.\\n    /// @param trusted Whether the strategy is trusted.\\n    /// @param balance The amount of underlying tokens held in the strategy.\\n    struct StrategyData {\\n        // Used to determine if the Vault will operate on a strategy.\\n        bool trusted;\\n        // Used to determine profit and loss during harvests of the strategy.\\n        uint248 balance;\\n    }\\n\\n    /// @notice Maps strategies to data the Vault holds on them.\\n    mapping(Strategy => StrategyData) public getStrategyData;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\\n    /// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\\n    uint64 public lastHarvestWindowStart;\\n\\n    /// @notice A timestamp representing when the most recent harvest occurred.\\n    uint64 public lastHarvest;\\n\\n    /// @notice The amount of locked profit at the end of the last harvest.\\n    uint128 public maxLockedProfit;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        WITHDRAWAL STACK STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice An ordered array of strategies representing the withdrawal stack.\\n    /// @dev The stack is processed in descending order, meaning the last index will be withdrawn from first.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\\n    /// withdrawal time, not validated upfront, meaning the stack may not reflect the \\\"true\\\" set used for withdrawals.\\n    Strategy[] public withdrawalStack;\\n\\n    /// @notice Gets the full withdrawal stack.\\n    /// @return An ordered array of strategies representing the withdrawal stack.\\n    /// @dev This is provided because Solidity converts public arrays into index getters,\\n    /// but we need a way to allow external contracts and users to access the whole array.\\n    function getWithdrawalStack() external view returns (Strategy[] memory) {\\n        return withdrawalStack;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful deposit.\\n    /// @param user The address that deposited into the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event Deposit(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after a successful withdrawal.\\n    /// @param user The address that withdrew from the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event Withdraw(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of the underlying token to deposit.\\n    function deposit(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and mint them.\\n        _mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Deposit(msg.sender, underlyingAmount);\\n\\n        // Transfer in underlying tokens from the user.\\n        // This will revert if the user does not have the amount specified.\\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of underlying tokens to withdraw.\\n    function withdraw(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and burn them.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @notice Redeem a specific amount of avTokens for underlying tokens.\\n    /// @param avTokenAmount The amount of avTokens to redeem for underlying tokens.\\n    function redeem(uint256 avTokenAmount) external {\\n        // Determine the equivalent amount of underlying tokens.\\n        uint256 underlyingAmount = avTokenAmount.fmul(exchangeRate(), BASE_UNIT);\\n\\n        // Burn the provided amount of avTokens.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, avTokenAmount);\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\\n    /// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\\n    /// @param recipient The user to transfer the underlying tokens to.\\n    /// @param underlyingAmount The amount of underlying tokens to transfer.\\n    function transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\\n        // Get the Vault's floating balance.\\n        uint256 float = totalFloat();\\n\\n        // If the amount is greater than the float, withdraw from strategies.\\n        if (underlyingAmount > float) {\\n            // Compute the amount needed to reach our target float percentage.\\n            uint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(targetFloatPercent, 1e18);\\n\\n            // Compute the bare minimum amount we need for this withdrawal.\\n            uint256 floatMissingForWithdrawal = underlyingAmount - float;\\n\\n            // Pull enough to cover the withdrawal and reach our target float percentage.\\n            pullFromWithdrawalStack(floatMissingForWithdrawal + floatMissingForTarget);\\n        }\\n\\n        // Transfer the provided amount of underlying tokens.\\n        UNDERLYING.safeTransfer(recipient, underlyingAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        VAULT ACCOUNTING LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Returns a user's Vault balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Vault balance in underlying tokens.\\n    function balanceOfUnderlying(address user) external view returns (uint256) {\\n        return balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens an avToken can be redeemed for.\\n    /// @return The amount of underlying tokens an avToken can be redeemed for.\\n    function exchangeRate() public view returns (uint256) {\\n        // Get the total supply of avTokens.\\n        uint256 avTokenSupply = totalSupply;\\n\\n        // If there are no avTokens in circulation, return an exchange rate of 1:1.\\n        if (avTokenSupply == 0) return BASE_UNIT;\\n\\n        // Calculate the exchange rate by dividing the total holdings by the avToken supply.\\n        return totalHoldings().fdiv(avTokenSupply, BASE_UNIT);\\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds.\\n    /// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\\n    function totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\\n        unchecked {\\n            // Cannot underflow as locked profit can't exceed total strategy holdings.\\n            totalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\\n        }\\n\\n        // Include our floating balance in the total.\\n        totalUnderlyingHeld += totalFloat();\\n    }\\n\\n    /// @notice Calculates the current amount of locked profit.\\n    /// @return The current amount of locked profit.\\n    function lockedProfit() public view returns (uint256) {\\n        // Get the last harvest and harvest delay.\\n        uint256 previousHarvest = lastHarvest;\\n        uint256 harvestInterval = harvestDelay;\\n\\n        unchecked {\\n            // If the harvest delay has passed, there is no locked profit.\\n            // Cannot overflow on human timescales since harvestInterval is capped.\\n            if (block.timestamp >= previousHarvest + harvestInterval) return 0;\\n\\n            // Get the maximum amount we could return.\\n            uint256 maximumLockedProfit = maxLockedProfit;\\n\\n            // Compute how much profit remains locked based on the last harvest and harvest delay.\\n            // It's impossible for the previous harvest to be in the future, so this will never underflow.\\n            return maximumLockedProfit - (maximumLockedProfit * (block.timestamp - previousHarvest)) / harvestInterval;\\n        }\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens that idly sit in the Vault.\\n    /// @return The amount of underlying tokens that sit idly in the Vault.\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful harvest.\\n    /// @param user The authorized user who triggered the harvest.\\n    /// @param strategies The trusted strategies that were harvested.\\n    event Harvest(address indexed user, Strategy[] strategies);\\n\\n    /// @notice Harvest a set of trusted strategies.\\n    /// @param strategies The trusted strategies to harvest.\\n    /// @dev Will always revert if called outside of an active\\n    /// harvest window or before the harvest delay has passed.\\n    function harvest(Strategy[] calldata strategies) external requiresAuth {\\n        // If this is the first harvest after the last window:\\n        if (block.timestamp >= lastHarvest + harvestDelay) {\\n            // Set the harvest window's start timestamp.\\n            // Cannot overflow 64 bits on human timescales.\\n            lastHarvestWindowStart = uint64(block.timestamp);\\n        } else {\\n            // We know this harvest is not the first in the window so we need to ensure it's within it.\\n            require(block.timestamp <= lastHarvestWindowStart + harvestWindow, \\\"BAD_HARVEST_TIME\\\");\\n        }\\n\\n        // Get the Vault's current total strategy holdings.\\n        uint256 oldTotalStrategyHoldings = totalStrategyHoldings;\\n\\n        // Used to store the total profit accrued by the strategies.\\n        uint256 totalProfitAccrued;\\n\\n        // Used to store the new total strategy holdings after harvesting.\\n        uint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\\n\\n        // Will revert if any of the specified strategies are untrusted.\\n        for (uint256 i = 0; i < strategies.length; i++) {\\n            // Get the strategy at the current index.\\n            Strategy strategy = strategies[i];\\n\\n            // If an untrusted strategy could be harvested a malicious user could use\\n            // a fake strategy that over-reports holdings to manipulate the exchange rate.\\n            require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n            // Get the strategy's previous and current balance.\\n            uint256 balanceLastHarvest = getStrategyData[strategy].balance;\\n            uint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\\n\\n            // Update the strategy's stored balance. Cast overflow is unrealistic.\\n            getStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\\n\\n            // Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\\n            // We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\\n            newTotalStrategyHoldings = newTotalStrategyHoldings + balanceThisHarvest - balanceLastHarvest;\\n\\n            unchecked {\\n                // Update the total profit accrued while counting losses as zero profit.\\n                // Cannot overflow as we already increased total holdings without reverting.\\n                totalProfitAccrued += balanceThisHarvest > balanceLastHarvest\\n                    ? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\\n                    : 0; // If the strategy registered a net loss we don't have any new profit.\\n            }\\n        }\\n\\n        // Compute fees as the fee percent multiplied by the profit.\\n        uint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\\n\\n        // If we accrued any fees, mint an equivalent amount of avTokens.\\n        // Authorized users can claim the newly minted avTokens via claimFees.\\n        _mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        // Update max unlocked profit based on any remaining locked profit plus new profit.\\n        maxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\\n\\n        // Set strategy holdings to our new total.\\n        totalStrategyHoldings = newTotalStrategyHoldings;\\n\\n        // Update the last harvest timestamp.\\n        // Cannot overflow on human timescales.\\n        lastHarvest = uint64(block.timestamp);\\n\\n        emit Harvest(msg.sender, strategies);\\n\\n        // Get the next harvest delay.\\n        uint64 newHarvestDelay = nextHarvestDelay;\\n\\n        // If the next harvest delay is not 0:\\n        if (newHarvestDelay != 0) {\\n            // Update the harvest delay.\\n            harvestDelay = newHarvestDelay;\\n\\n            // Reset the next harvest delay.\\n            nextHarvestDelay = 0;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    STRATEGY DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after the Vault deposits into a strategy contract.\\n    /// @param user The authorized user who triggered the deposit.\\n    /// @param strategy The strategy that was deposited into.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event StrategyDeposit(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after the Vault withdraws funds from a strategy contract.\\n    /// @param user The authorized user who triggered the withdrawal.\\n    /// @param strategy The strategy that was withdrawn from.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event StrategyWithdrawal(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of float into a trusted strategy.\\n    /// @param strategy The trusted strategy to deposit into.\\n    /// @param underlyingAmount The amount of underlying tokens in float to deposit.\\n    function depositIntoStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be deposited into.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Increase totalStrategyHoldings to account for the deposit.\\n        totalStrategyHoldings += underlyingAmount;\\n\\n        unchecked {\\n            // Without this the next harvest would count the deposit as profit.\\n            // Cannot overflow as the balance of one strategy can't exceed the sum of all.\\n            getStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\\n        }\\n\\n        emit StrategyDeposit(msg.sender, strategy, underlyingAmount);\\n\\n        // We need to deposit differently if the strategy takes ETH.\\n        if (strategy.isCEther()) {\\n            // Unwrap the right amount of WETH.\\n            WETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\\n\\n            // Deposit into the strategy and assume it will revert on error.\\n            ETHStrategy(address(strategy)).mint{value: underlyingAmount}();\\n        } else {\\n            // Approve underlyingAmount to the strategy so we can deposit.\\n            UNDERLYING.safeApprove(address(strategy), underlyingAmount);\\n\\n            // Deposit into the strategy and revert if it returns an error code.\\n            require(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \\\"MINT_FAILED\\\");\\n        }\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a strategy.\\n    /// @param strategy The strategy to withdraw from.\\n    /// @param underlyingAmount  The amount of underlying tokens to withdraw.\\n    /// @dev Withdrawing from a strategy will not remove it from the withdrawal stack.\\n    function withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be withdrawn from.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Without this the next harvest would count the withdrawal as a loss.\\n        getStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the withdrawal.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        emit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\\n\\n        // Withdraw from the strategy and revert if it returns an error code.\\n        require(strategy.redeemUnderlying(underlyingAmount) == 0, \\\"REDEEM_FAILED\\\");\\n\\n        // Wrap the withdrawn Ether into WETH if necessary.\\n        if (strategy.isCEther()) WETH(payable(address(UNDERLYING))).deposit{value: underlyingAmount}();\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                      STRATEGY TRUST/DISTRUST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is set to trusted.\\n    /// @param user The authorized user who trusted the strategy.\\n    /// @param strategy The strategy that became trusted.\\n    event StrategyTrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Emitted when a strategy is set to untrusted.\\n    /// @param user The authorized user who untrusted the strategy.\\n    /// @param strategy The strategy that became untrusted.\\n    event StrategyDistrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Stores a strategy as trusted, enabling it to be harvested.\\n    /// @param strategy The strategy to make trusted.\\n    function trustStrategy(Strategy strategy) external requiresAuth {\\n        // Ensure the strategy accepts the correct underlying token.\\n        // If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\\n        require(\\n            strategy.isCEther() ? underlyingIsWETH : ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\\n            \\\"WRONG_UNDERLYING\\\"\\n        );\\n\\n        // Store the strategy as trusted.\\n        getStrategyData[strategy].trusted = true;\\n\\n        emit StrategyTrusted(msg.sender, strategy);\\n    }\\n\\n    /// @notice Stores a strategy as untrusted, disabling it from being harvested.\\n    /// @param strategy The strategy to make untrusted.\\n    function distrustStrategy(Strategy strategy) external requiresAuth {\\n        // Store the strategy as untrusted.\\n        getStrategyData[strategy].trusted = false;\\n\\n        emit StrategyDistrusted(msg.sender, strategy);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         WITHDRAWAL STACK LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is pushed to the withdrawal stack.\\n    /// @param user The authorized user who triggered the push.\\n    /// @param pushedStrategy The strategy pushed to the withdrawal stack.\\n    event WithdrawalStackPushed(address indexed user, Strategy indexed pushedStrategy);\\n\\n    /// @notice Emitted when a strategy is popped from the withdrawal stack.\\n    /// @param user The authorized user who triggered the pop.\\n    /// @param poppedStrategy The strategy popped from the withdrawal stack.\\n    event WithdrawalStackPopped(address indexed user, Strategy indexed poppedStrategy);\\n\\n    /// @notice Emitted when the withdrawal stack is updated.\\n    /// @param user The authorized user who triggered the set.\\n    /// @param replacedWithdrawalStack The new withdrawal stack.\\n    event WithdrawalStackSet(address indexed user, Strategy[] replacedWithdrawalStack);\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack that was replaced.\\n    /// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\\n    event WithdrawalStackIndexReplaced(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed replacementStrategy\\n    );\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced with the tip.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack replaced by the tip.\\n    /// @param previousTipStrategy The previous tip of the stack that replaced the strategy.\\n    event WithdrawalStackIndexReplacedWithTip(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed previousTipStrategy\\n    );\\n\\n    /// @notice Emitted when the strategies at two indexes are swapped.\\n    /// @param user The authorized user who triggered the swap.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    /// @param newStrategy1 The strategy (previously at index2) that replaced index1.\\n    /// @param newStrategy2 The strategy (previously at index1) that replaced index2.\\n    event WithdrawalStackIndexesSwapped(\\n        address indexed user,\\n        uint256 index1,\\n        uint256 index2,\\n        Strategy indexed newStrategy1,\\n        Strategy indexed newStrategy2\\n    );\\n\\n    /// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal stack.\\n    /// @param underlyingAmount The amount of underlying tokens to pull into float.\\n    /// @dev Automatically removes depleted strategies from the withdrawal stack.\\n    function pullFromWithdrawalStack(uint256 underlyingAmount) internal {\\n        // We will update this variable as we pull from strategies.\\n        uint256 amountLeftToPull = underlyingAmount;\\n\\n        // We'll start at the tip of the stack and traverse backwards.\\n        uint256 currentIndex = withdrawalStack.length - 1;\\n\\n        // Iterate in reverse so we pull from the stack in a \\\"last in, first out\\\" manner.\\n        // Will revert due to underflow if we empty the stack before pulling the desired amount.\\n        for (; ; currentIndex--) {\\n            // Get the strategy at the current stack index.\\n            Strategy strategy = withdrawalStack[currentIndex];\\n\\n            // Get the balance of the strategy before we withdraw from it.\\n            uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n            // If the strategy is currently untrusted or was already depleted:\\n            if (!getStrategyData[strategy].trusted || strategyBalance == 0) {\\n                // Remove it from the stack.\\n                withdrawalStack.pop();\\n\\n                emit WithdrawalStackPopped(msg.sender, strategy);\\n\\n                // Move onto the next strategy.\\n                continue;\\n            }\\n\\n            // We want to pull as much as we can from the strategy, but no more than we need.\\n            uint256 amountToPull = strategyBalance > amountLeftToPull ? amountLeftToPull : strategyBalance;\\n\\n            unchecked {\\n                // Compute the balance of the strategy that will remain after we withdraw.\\n                // Cannot underflow as we cap the amount to pull at the strategy's balance.\\n                uint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\\n\\n                // Without this the next harvest would count the withdrawal as a loss.\\n                getStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\\n\\n                // Adjust our goal based on how much we can pull from the strategy.\\n                // Cannot underflow as we cap the amount to pull at the amount left to pull.\\n                amountLeftToPull -= amountToPull;\\n\\n                emit StrategyWithdrawal(msg.sender, strategy, amountToPull);\\n\\n                // Withdraw from the strategy and revert if returns an error code.\\n                require(strategy.redeemUnderlying(amountToPull) == 0, \\\"REDEEM_FAILED\\\");\\n\\n                // If we fully depleted the strategy:\\n                if (strategyBalanceAfterWithdrawal == 0) {\\n                    // Remove it from the stack.\\n                    withdrawalStack.pop();\\n\\n                    emit WithdrawalStackPopped(msg.sender, strategy);\\n                }\\n            }\\n\\n            // If we've pulled all we need, exit the loop.\\n            if (amountLeftToPull == 0) break;\\n        }\\n\\n        unchecked {\\n            // Account for the withdrawals done in the loop above.\\n            // Cannot underflow as the balances of some strategies cannot exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        // Cache the Vault's balance of ETH.\\n        uint256 ethBalance = address(this).balance;\\n\\n        // If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\\n        if (ethBalance != 0 && underlyingIsWETH) WETH(payable(address(UNDERLYING))).deposit{value: ethBalance}();\\n    }\\n\\n    /// @notice Pushes a single strategy to front of the withdrawal stack.\\n    /// @param strategy The strategy to be inserted at the front of the withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function pushToWithdrawalStack(Strategy strategy) external requiresAuth {\\n        // Ensure pushing the strategy will not cause the stack exceed its limit.\\n        require(withdrawalStack.length < MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_FULL\\\");\\n\\n        // Push the strategy to the front of the stack.\\n        withdrawalStack.push(strategy);\\n\\n        emit WithdrawalStackPushed(msg.sender, strategy);\\n    }\\n\\n    /// @notice Removes the strategy at the tip of the withdrawal stack.\\n    /// @dev Be careful, another authorized user could push a different strategy\\n    /// than expected to the stack while a popFromWithdrawalStack transaction is pending.\\n    function popFromWithdrawalStack() external requiresAuth {\\n        // Get the (soon to be) popped strategy.\\n        Strategy poppedStrategy = withdrawalStack[withdrawalStack.length - 1];\\n\\n        // Pop the first strategy in the stack.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackPopped(msg.sender, poppedStrategy);\\n    }\\n\\n    /// @notice Sets a new withdrawal stack.\\n    /// @param newStack The new withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function setWithdrawalStack(Strategy[] calldata newStack) external requiresAuth {\\n        // Ensure the new stack is not larger than the maximum stack size.\\n        require(newStack.length <= MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_TOO_BIG\\\");\\n\\n        // Replace the withdrawal stack.\\n        withdrawalStack = newStack;\\n\\n        emit WithdrawalStackSet(msg.sender, newStack);\\n    }\\n\\n    /// @notice Replaces an index in the withdrawal stack with another strategy.\\n    /// @param index The index in the stack to replace.\\n    /// @param replacementStrategy The strategy to override the index with.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function replaceWithdrawalStackIndex(uint256 index, Strategy replacementStrategy) external requiresAuth {\\n        // Get the (soon to be) replaced strategy.\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Update the index with the replacement strategy.\\n        withdrawalStack[index] = replacementStrategy;\\n\\n        emit WithdrawalStackIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\\n    }\\n\\n    /// @notice Moves the strategy at the tip of the stack to the specified index and pop the tip off the stack.\\n    /// @param index The index of the strategy in the withdrawal stack to replace with the tip.\\n    function replaceWithdrawalStackIndexWithTip(uint256 index) external requiresAuth {\\n        // Get the (soon to be) previous tip and strategy we will replace at the index.\\n        Strategy previousTipStrategy = withdrawalStack[withdrawalStack.length - 1];\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Replace the index specified with the tip of the stack.\\n        withdrawalStack[index] = previousTipStrategy;\\n\\n        // Remove the now duplicated tip from the array.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackIndexReplacedWithTip(msg.sender, index, replacedStrategy, previousTipStrategy);\\n    }\\n\\n    /// @notice Swaps two indexes in the withdrawal stack.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    function swapWithdrawalStackIndexes(uint256 index1, uint256 index2) external requiresAuth {\\n        // Get the (soon to be) new strategies at each index.\\n        Strategy newStrategy2 = withdrawalStack[index1];\\n        Strategy newStrategy1 = withdrawalStack[index2];\\n\\n        // Swap the strategies at both indexes.\\n        withdrawalStack[index1] = newStrategy1;\\n        withdrawalStack[index2] = newStrategy2;\\n\\n        emit WithdrawalStackIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         SEIZE STRATEGY LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a strategy is seized.\\n    /// @param user The authorized user who triggered the seize.\\n    /// @param strategy The strategy that was seized.\\n    event StrategySeized(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Seizes a strategy.\\n    /// @param strategy The strategy to seize.\\n    /// @dev Intended for use in emergencies or other extraneous situations where the\\n    /// strategy requires interaction outside of the Vault's standard operating procedures.\\n    function seizeStrategy(Strategy strategy) external requiresAuth {\\n        // Get the strategy's last reported balance of underlying tokens.\\n        uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n        // If the strategy's balance exceeds the Vault's current\\n        // holdings, instantly unlock any remaining locked profit.\\n        if (strategyBalance > totalHoldings()) maxLockedProfit = 0;\\n\\n        // Set the strategy's balance to 0.\\n        getStrategyData[strategy].balance = 0;\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the seize.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= strategyBalance;\\n        }\\n\\n        emit StrategySeized(msg.sender, strategy);\\n\\n        // Transfer all of the strategy's tokens to the caller.\\n        ERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             FEE CLAIM LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after fees are claimed.\\n    /// @param user The authorized user who claimed the fees.\\n    /// @param avTokenAmount The amount of avTokens that were claimed.\\n    event FeesClaimed(address indexed user, uint256 avTokenAmount);\\n\\n    /// @notice Claims fees accrued from harvests.\\n    /// @param avTokenAmount The amount of avTokens to claim.\\n    /// @dev Accrued fees are measured as avTokens held by the Vault.\\n    function claimFees(uint256 avTokenAmount) external requiresAuth {\\n        emit FeesClaimed(msg.sender, avTokenAmount);\\n\\n        // Transfer the provided amount of avTokens to the caller.\\n        ERC20(this).safeTransfer(msg.sender, avTokenAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    INITIALIZATION AND DESTRUCTION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the Vault is initialized.\\n    /// @param user The authorized user who triggered the initialization.\\n    event Initialized(address indexed user);\\n\\n    /// @notice Whether the Vault has been initialized yet.\\n    /// @dev Can go from false to true, never from true to false.\\n    bool public isInitialized;\\n\\n    /// @notice Initializes the Vault, enabling it to receive deposits.\\n    /// @dev All critical parameters must already be set before calling.\\n    function initialize() external requiresAuth {\\n        // Ensure the Vault has not already been initialized.\\n        require(!isInitialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n        // Mark the Vault as initialized.\\n        isInitialized = true;\\n\\n        // Open for deposits.\\n        totalSupply = 0;\\n\\n        emit Initialized(msg.sender);\\n    }\\n\\n    /// @notice Self destructs a Vault, enabling it to be redeployed.\\n    /// @dev Caller will receive any ETH held as float in the Vault.\\n    function destroy() external requiresAuth {\\n        selfdestruct(payable(msg.sender));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          RECIEVE ETHER LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Required for the Vault to receive unwrapped ETH.\\n    receive() external payable {}\\n}\\n\"\n    },\n    \"@rari-capital/solmate/src/tokens/WETH.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\"\n    },\n    \"srcBuild/modules/VaultRouterModule.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {WETH} from \\\"@rari-capital/solmate/src/tokens/WETH.sol\\\";\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../FixedPointMathLib.sol\\\";\\n\\nimport {AllowedPermit} from \\\"../interfaces/AllowedPermit.sol\\\";\\n\\nimport {Vault} from \\\"../Vault.sol\\\";\\n\\n/// @title Rari Vault Router Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module that enables depositing ETH into WETH compatible Vaults\\n/// and approval-free deposits into Vaults with permit compatible underlying.\\ncontract VaultRouterModule {\\n    using SafeTransferLib for ERC20;\\n    using SafeTransferLib for address;\\n    using FixedPointMathLib for uint256;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                              DEPOSIT LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Deposit ETH into a WETH compatible Vault.\\n    /// @param vault The WETH compatible Vault to deposit into.\\n    function depositETHIntoVault(Vault vault) external payable {\\n        // Ensure the Vault's underlying is stored as WETH compatible.\\n        require(vault.underlyingIsWETH(), \\\"UNDERLYING_NOT_WETH\\\");\\n\\n        // Get the Vault's underlying as WETH.\\n        WETH weth = WETH(payable(address(vault.UNDERLYING())));\\n\\n        // Wrap the ETH into WETH.\\n        weth.deposit{value: msg.value}();\\n\\n        // Deposit and transfer the minted rvTokens back to the caller.\\n        depositIntoVaultForCaller(vault, weth, msg.value);\\n    }\\n\\n    /// @notice Deposits into a Vault, transferring in its underlying token from the caller via permit.\\n    /// @param vault The Vault to deposit into.\\n    /// @param underlyingAmount The amount of underlying tokens to deposit into the Vault.\\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\\n    /// @dev Use depositIntoVaultWithAllowedPermit for tokens using DAI's non-standard permit interface.\\n    function depositIntoVaultWithPermit(\\n        Vault vault,\\n        uint256 underlyingAmount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        // Get the Vault's underlying token.\\n        ERC20 underlying = vault.UNDERLYING();\\n\\n        // Transfer in the provided amount of underlying tokens from the caller via permit.\\n        permitAndTransferFromCaller(underlying, underlyingAmount, deadline, v, r, s);\\n\\n        // Deposit and transfer the minted rvTokens back to the caller.\\n        depositIntoVaultForCaller(vault, underlying, underlyingAmount);\\n    }\\n\\n    /// @notice Deposits into a Vault, transferring in its underlying token from the caller via allowed permit.\\n    /// @param vault The Vault to deposit into.\\n    /// @param underlyingAmount The amount of underlying tokens to deposit into the Vault.\\n    /// @param nonce The callers's nonce, increases at each call to permit.\\n    /// @param expiry The timestamp at which the permit is no longer valid.\\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\\n    /// @dev Alternative to depositIntoVaultWithPermit for tokens using DAI's non-standard permit interface.\\n    function depositIntoVaultWithAllowedPermit(\\n        Vault vault,\\n        uint256 underlyingAmount,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        // Get the Vault's underlying token.\\n        ERC20 underlying = vault.UNDERLYING();\\n\\n        // Transfer in the provided amount of underlying tokens from the caller via allowed permit.\\n        allowedPermitAndTransferFromCaller(underlying, underlyingAmount, nonce, expiry, v, r, s);\\n\\n        // Deposit and transfer the minted rvTokens back to the caller.\\n        depositIntoVaultForCaller(vault, underlying, underlyingAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                            WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Withdraw ETH from a WETH compatible Vault.\\n    /// @param vault The WETH compatible Vault to withdraw from.\\n    /// @param underlyingAmount The amount of ETH to withdraw from the Vault.\\n    function withdrawETHFromVault(Vault vault, uint256 underlyingAmount) external {\\n        // Ensure the Vault's underlying is stored as WETH compatible.\\n        require(vault.underlyingIsWETH(), \\\"UNDERLYING_NOT_WETH\\\");\\n\\n        // Compute the amount of rvTokens equivalent to the underlying amount.\\n        // We know the Vault's base unit is 1e18 as it's required for underlyingIsWETH to be true.\\n        uint256 rvTokenAmount = underlyingAmount.fdiv(vault.exchangeRate(), 1e18);\\n\\n        // Transfer in the equivalent amount of rvTokens from the caller.\\n        ERC20(vault).safeTransferFrom(msg.sender, address(this), rvTokenAmount);\\n\\n        // Withdraw from the Vault.\\n        vault.withdraw(underlyingAmount);\\n\\n        // Unwrap the withdrawn amount of WETH and transfer it to the caller.\\n        unwrapAndTransfer(WETH(payable(address(vault.UNDERLYING()))), underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw ETH from a WETH compatible Vault.\\n    /// @param vault The WETH compatible Vault to withdraw from.\\n    /// @param underlyingAmount The amount of ETH to withdraw from the Vault.\\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\\n    function withdrawETHFromVaultWithPermit(\\n        Vault vault,\\n        uint256 underlyingAmount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        // Ensure the Vault's underlying is stored as WETH compatible.\\n        require(vault.underlyingIsWETH(), \\\"UNDERLYING_NOT_WETH\\\");\\n\\n        // Compute the amount of rvTokens equivalent to the underlying amount.\\n        // We know the Vault's base unit is 1e18 as it's required for underlyingIsWETH to be true.\\n        uint256 rvTokenAmount = underlyingAmount.fdiv(vault.exchangeRate(), 1e18);\\n\\n        // Transfer in the equivalent amount of rvTokens from the caller via permit.\\n        permitAndTransferFromCaller(vault, rvTokenAmount, deadline, v, r, s);\\n\\n        // Withdraw from the Vault.\\n        vault.withdraw(underlyingAmount);\\n\\n        // Unwrap the withdrawn amount of WETH and transfer it to the caller.\\n        unwrapAndTransfer(WETH(payable(address(vault.UNDERLYING()))), underlyingAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                              REDEEM LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Redeem ETH from a WETH compatible Vault.\\n    /// @param vault The WETH compatible Vault to redeem from.\\n    /// @param rvTokenAmount The amount of rvTokens to withdraw from the Vault.\\n    function redeemETHFromVault(Vault vault, uint256 rvTokenAmount) external {\\n        // Ensure the Vault's underlying is stored as WETH compatible.\\n        require(vault.underlyingIsWETH(), \\\"UNDERLYING_NOT_WETH\\\");\\n\\n        // Transfer in the provided amount of rvTokens from the caller.\\n        ERC20(vault).safeTransferFrom(msg.sender, address(this), rvTokenAmount);\\n\\n        // Redeem the rvTokens.\\n        vault.redeem(rvTokenAmount);\\n\\n        // Get the Vault's underlying as WETH.\\n        WETH weth = WETH(payable(address(vault.UNDERLYING())));\\n\\n        // Unwrap all our WETH and transfer it to the caller.\\n        unwrapAndTransfer(weth, weth.balanceOf(address(this)));\\n    }\\n\\n    /// @notice Redeem ETH from a WETH compatible Vault.\\n    /// @param vault The WETH compatible Vault to redeem from.\\n    /// @param rvTokenAmount The amount of rvTokens to withdraw from the Vault.\\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\\n    function redeemETHFromVaultWithPermit(\\n        Vault vault,\\n        uint256 rvTokenAmount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        // Ensure the Vault's underlying is stored as WETH compatible.\\n        require(vault.underlyingIsWETH(), \\\"UNDERLYING_NOT_WETH\\\");\\n\\n        // Transfer in the provided amount of rvTokens from the caller via permit.\\n        permitAndTransferFromCaller(vault, rvTokenAmount, deadline, v, r, s);\\n\\n        // Redeem the rvTokens.\\n        vault.redeem(rvTokenAmount);\\n\\n        // Get the Vault's underlying as WETH.\\n        WETH weth = WETH(payable(address(vault.UNDERLYING())));\\n\\n        // Unwrap all our WETH and transfer it to the caller.\\n        unwrapAndTransfer(weth, weth.balanceOf(address(this)));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          WETH UNWRAPPING LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Unwraps the provided amount of WETH and transfers it to the caller.\\n    /// @param weth The WETH contract to withdraw the amount from.\\n    /// @param amount The amount of WETH to unwrap into ETH and transfer.\\n    function unwrapAndTransfer(WETH weth, uint256 amount) internal {\\n        // Convert the WETH into ETH.\\n        weth.withdraw(amount);\\n\\n        // Transfer the unwrapped ETH to the caller.\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          VAULT DEPOSIT LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Approves tokens, deposits them into a Vault\\n    /// and transfers the minted rvTokens back to the caller.\\n    /// @param vault The Vault to deposit into.\\n    /// @param underlying The underlying token the Vault accepts.\\n    /// @param amount The minimum amount that must be approved.\\n    function depositIntoVaultForCaller(\\n        Vault vault,\\n        ERC20 underlying,\\n        uint256 amount\\n    ) internal {\\n        // Approve the underlying tokens to the Vault.\\n        underlying.safeApprove(address(vault), amount);\\n\\n        // Deposit the underlying tokens into the Vault.\\n        vault.deposit(amount);\\n\\n        // Transfer the newly minted rvTokens back to the caller.\\n        ERC20(vault).safeTransfer(msg.sender, vault.balanceOf(address(this)));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                              PERMIT LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Permits tokens from the caller and transfers them into the module.\\n    /// @param token The token to permit and transfer in.\\n    /// @param amount The amount of tokens to permit and transfer in.\\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\\n    function permitAndTransferFromCaller(\\n        ERC20 token,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        // Approve the tokens from the caller to the module via permit.\\n        token.permit(msg.sender, address(this), amount, deadline, v, r, s);\\n\\n        // Transfer the tokens from the caller to the module.\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    /// @dev Max permits tokens from the caller and transfers them into the module.\\n    /// @param token The token to permit and transfer in.\\n    /// @param amount The amount of tokens to permit and transfer in.\\n    /// @param nonce The callers's nonce, increases at each call to permit.\\n    /// @param expiry The timestamp at which the permit is no longer valid.\\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\\n    /// @dev Alternative to permitAndTransferFromCaller for tokens using DAI's non-standard permit interface.\\n    function allowedPermitAndTransferFromCaller(\\n        ERC20 token,\\n        uint256 amount,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        // Approve the tokens from the caller to the module via DAI's non-standard permit.\\n        AllowedPermit(address(token)).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\\n\\n        // Transfer the tokens from the caller to the module.\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          RECIEVE ETHER LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Required for the module to receive unwrapped ETH.\\n    receive() external payable {}\\n}\\n\"\n    },\n    \"srcBuild/interfaces/AllowedPermit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\n/// @notice Minimal interface for tokens using DAI's non-standard permit interface.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/external/IERC20PermitAllowed.sol)\\nabstract contract AllowedPermit is ERC20 {\\n    /// @param holder The address of the token owner.\\n    /// @param spender The address of the token spender.\\n    /// @param nonce The owner's nonce, increases at each call to permit.\\n    /// @param expiry The timestamp at which the permit is no longer valid.\\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0.\\n    /// @param v Must produce valid secp256k1 signature from the owner along with r and s.\\n    /// @param r Must produce valid secp256k1 signature from the owner along with v and s.\\n    /// @param s Must produce valid secp256k1 signature from the owner along with r and v.\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual;\\n}\\n\"\n    },\n    \"srcBuild/VaultFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {Bytes32AddressLib} from \\\"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\\\";\\n\\nimport {Vault} from \\\"./Vault.sol\\\";\\n\\n/// @title Rari Vault Factory\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Factory which enables deploying a Vault for any ERC20 token.\\ncontract VaultFactory is Auth {\\n    using Bytes32AddressLib for address;\\n    using Bytes32AddressLib for bytes32;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Creates a Vault factory.\\n    /// @param _owner The owner of the factory.\\n    /// @param _authority The Authority of the factory.\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          VAULT DEPLOYMENT LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a new Vault is deployed.\\n    /// @param vault The newly deployed Vault contract.\\n    /// @param underlying The underlying token the new Vault accepts.\\n    event VaultDeployed(Vault vault, ERC20 underlying);\\n\\n    /// @notice Deploys a new Vault which supports a specific underlying token.\\n    /// @dev This will revert if a Vault that accepts the same underlying token has already been deployed.\\n    /// @param underlying The ERC20 token that the Vault should accept.\\n    /// @return vault The newly deployed Vault contract which accepts the provided underlying token.\\n    function deployVault(ERC20 underlying) external returns (Vault vault) {\\n        // Use the CREATE2 opcode to deploy a new Vault contract.\\n        // This will revert if a Vault which accepts this underlying token has already\\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\\n        vault = new Vault{salt: address(underlying).fillLast12Bytes()}(underlying);\\n\\n        emit VaultDeployed(vault, underlying);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                            VAULT LOOKUP LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Computes a Vault's address from its accepted underlying token.\\n    /// @param underlying The ERC20 token that the Vault should accept.\\n    /// @return The address of a Vault which accepts the provided underlying token.\\n    /// @dev The Vault returned may not be deployed yet. Use isVaultDeployed to check.\\n    function getVaultFromUnderlying(ERC20 underlying) external view returns (Vault) {\\n        return\\n            Vault(\\n                payable(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            // Prefix:\\n                            bytes1(0xFF),\\n                            // Creator:\\n                            address(this),\\n                            // Salt:\\n                            address(underlying).fillLast12Bytes(),\\n                            // Bytecode hash:\\n                            keccak256(\\n                                abi.encodePacked(\\n                                    // Deployment bytecode:\\n                                    type(Vault).creationCode,\\n                                    // Constructor arguments:\\n                                    abi.encode(underlying)\\n                                )\\n                            )\\n                        )\\n                    ).fromLast20Bytes() // Convert the CREATE2 hash into an address.\\n                )\\n            );\\n    }\\n\\n    /// @notice Returns if a Vault at an address has already been deployed.\\n    /// @param vault The address of a Vault which may not have been deployed yet.\\n    /// @return A boolean indicating whether the Vault has been deployed already.\\n    /// @dev This function is useful to check the return values of getVaultFromUnderlying,\\n    /// as it does not check that the Vault addresses it computes have been deployed yet.\\n    function isVaultDeployed(Vault vault) external view returns (bool) {\\n        return address(vault).code.length > 0;\\n    }\\n}\\n\"\n    },\n    \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Library for converting between addresses and bytes32 values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\\nlibrary Bytes32AddressLib {\\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\\n        return bytes32(bytes20(addressValue));\\n    }\\n}\\n\"\n    },\n    \"srcBuild/modules/VaultInitializationModule.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nimport {Vault} from \\\"../Vault.sol\\\";\\nimport {VaultFactory} from \\\"../VaultFactory.sol\\\";\\n\\nimport {VaultConfigurationModule} from \\\"./VaultConfigurationModule.sol\\\";\\n\\n/// @title Rari Vault Initialization Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for initializing newly created Vaults.\\ncontract VaultInitializationModule is Auth {\\n    /// @notice Vault configuration module used to configure Vaults before initialization.\\n    VaultConfigurationModule public configModule;\\n\\n    /// @notice Creates a Vault initialization module.\\n    /// @param _configModule The Vault configuration module the\\n    /// module will use to configure Vaults before initialization.\\n    /// @param _owner The owner of the module.\\n    /// @param _authority The Authority of the module.\\n    constructor(\\n        VaultConfigurationModule _configModule,\\n        address _owner,\\n        Authority _authority\\n    ) Auth(_owner, _authority) {\\n        configModule = _configModule;\\n    }\\n\\n    /// @notice Emitted when the config module is updated.\\n    /// @param newConfigModule The new configuration module.\\n    event ConfigModuleUpdated(VaultConfigurationModule newConfigModule);\\n\\n    /// @notice Sets a new Vault configuration module.\\n    /// @param newConfigModule The Vault configuration module to set.\\n    function setConfigModule(VaultConfigurationModule newConfigModule) external requiresAuth {\\n        // Update the config module.\\n        configModule = newConfigModule;\\n\\n        emit ConfigModuleUpdated(newConfigModule);\\n    }\\n\\n    /// @notice Properly configures and initializes a newly deployed Vault.\\n    /// @dev This will revert if the Vault has already been initialized.\\n    /// @param vault The Vault to configure and initialize.\\n    function initializeVault(Vault vault) external {\\n        // Configure all key parameters.\\n        configModule.syncFeePercent(vault);\\n        configModule.syncHarvestDelay(vault);\\n        configModule.syncHarvestWindow(vault);\\n        configModule.syncTargetFloatPercent(vault);\\n\\n        // Open the Vault up for deposits.\\n        vault.initialize();\\n    }\\n}\\n\"\n    },\n    \"srcBuild/modules/VaultConfigurationModule.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nimport {Vault} from \\\"../Vault.sol\\\";\\n\\n/// @title Rari Vault Configuration Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for configuring Vault parameters.\\ncontract VaultConfigurationModule is Auth {\\n    /* //////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Creates a Vault configuration module.\\n    /// @param _owner The owner of the module.\\n    /// @param _authority The Authority of the module.\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  DEFAULT VAULT PARAMETER CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the default fee percentage is updated.\\n    /// @param newDefaultFeePercent The new default fee percentage.\\n    event DefaultFeePercentUpdated(uint256 newDefaultFeePercent);\\n\\n    /// @notice Emitted when the default harvest delay is updated.\\n    /// @param newDefaultHarvestDelay The new default harvest delay.\\n    event DefaultHarvestDelayUpdated(uint64 newDefaultHarvestDelay);\\n\\n    /// @notice Emitted when the default harvest window is updated.\\n    /// @param newDefaultHarvestWindow The new default harvest window.\\n    event DefaultHarvestWindowUpdated(uint128 newDefaultHarvestWindow);\\n\\n    /// @notice Emitted when the default target float percentage is updated.\\n    /// @param newDefaultTargetFloatPercent The new default target float percentage.\\n    event DefaultTargetFloatPercentUpdated(uint256 newDefaultTargetFloatPercent);\\n\\n    /// @notice The default fee percentage for Vaults.\\n    /// @dev See the documentation for the feePercentage\\n    /// variable in the Vault contract for more details.\\n    uint256 public defaultFeePercent;\\n\\n    /// @notice The default harvest delay for Vaults.\\n    /// @dev See the documentation for the harvestDelay\\n    /// variable in the Vault contract for more details.\\n    uint64 public defaultHarvestDelay;\\n\\n    /// @notice The default harvest window for Vaults.\\n    /// @dev See the documentation for the harvestWindow\\n    /// variable in the Vault contract for more details.\\n    uint128 public defaultHarvestWindow;\\n\\n    /// @notice The default target float percentage for Vaults.\\n    /// @dev See the documentation for the targetFloatPercent\\n    /// variable in the Vault contract for more details.\\n    uint256 public defaultTargetFloatPercent;\\n\\n    /// @notice Sets the default fee percentage for Vaults.\\n    /// @param newDefaultFeePercent The new default fee percentage to set.\\n    function setDefaultFeePercent(uint256 newDefaultFeePercent) external requiresAuth {\\n        // Update the default fee percentage.\\n        defaultFeePercent = newDefaultFeePercent;\\n\\n        emit DefaultFeePercentUpdated(newDefaultFeePercent);\\n    }\\n\\n    /// @notice Sets the default harvest delay for Vaults.\\n    /// @param newDefaultHarvestDelay The new default harvest delay to set.\\n    function setDefaultHarvestDelay(uint64 newDefaultHarvestDelay) external requiresAuth {\\n        // Update the default harvest delay.\\n        defaultHarvestDelay = newDefaultHarvestDelay;\\n\\n        emit DefaultHarvestDelayUpdated(newDefaultHarvestDelay);\\n    }\\n\\n    /// @notice Sets the default harvest window for Vaults.\\n    /// @param newDefaultHarvestWindow The new default harvest window to set.\\n    function setDefaultHarvestWindow(uint128 newDefaultHarvestWindow) external requiresAuth {\\n        // Update the default harvest window.\\n        defaultHarvestWindow = newDefaultHarvestWindow;\\n\\n        emit DefaultHarvestWindowUpdated(newDefaultHarvestWindow);\\n    }\\n\\n    /// @notice Sets the default target float percentage for Vaults.\\n    /// @param newDefaultTargetFloatPercent The new default target float percentage to set.\\n    function setDefaultTargetFloatPercent(uint256 newDefaultTargetFloatPercent) external requiresAuth {\\n        // Update the default target float percentage.\\n        defaultTargetFloatPercent = newDefaultTargetFloatPercent;\\n\\n        emit DefaultTargetFloatPercentUpdated(newDefaultTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  CUSTOM VAULT PARAMETER CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a Vault has its custom fee percentage set/updated.\\n    /// @param vault The Vault that had its custom fee percentage set/updated.\\n    /// @param newCustomFeePercent The new custom fee percentage for the Vault.\\n    event CustomFeePercentUpdated(Vault indexed vault, uint256 newCustomFeePercent);\\n\\n    /// @notice Emitted when a Vault has its custom harvest delay set/updated.\\n    /// @param vault The Vault that had its custom harvest delay set/updated.\\n    /// @param newCustomHarvestDelay The new custom harvest delay for the Vault.\\n    event CustomHarvestDelayUpdated(Vault indexed vault, uint256 newCustomHarvestDelay);\\n\\n    /// @notice Emitted when a Vault has its custom harvest window set/updated.\\n    /// @param vault The Vault that had its custom harvest window set/updated.\\n    /// @param newCustomHarvestWindow The new custom harvest window for the Vault.\\n    event CustomHarvestWindowUpdated(Vault indexed vault, uint256 newCustomHarvestWindow);\\n\\n    /// @notice Emitted when a Vault has its custom target float percentage set/updated.\\n    /// @param vault The Vault that had its custom target float percentage set/updated.\\n    /// @param newCustomTargetFloatPercent The new custom target float percentage for the Vault.\\n    event CustomTargetFloatPercentUpdated(Vault indexed vault, uint256 newCustomTargetFloatPercent);\\n\\n    /// @notice Maps Vaults to their custom fee percentage.\\n    /// @dev Will be 0 if there is no custom fee percentage for the Vault.\\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\\n    mapping(Vault => uint256) public getVaultCustomFeePercent;\\n\\n    /// @notice Maps Vaults to their custom harvest delay.\\n    /// @dev Will be 0 if there is no custom harvest delay for the Vault.\\n    /// @dev See the documentation for the harvestDelay variable in the Vault contract for more details.\\n    mapping(Vault => uint64) public getVaultCustomHarvestDelay;\\n\\n    /// @notice Maps Vaults to their custom harvest window.\\n    /// @dev Will be 0 if there is no custom harvest window for the Vault.\\n    /// @dev See the documentation for the harvestWindow variable in the Vault contract for more details.\\n    mapping(Vault => uint128) public getVaultCustomHarvestWindow;\\n\\n    /// @notice Maps Vaults to their custom target float percentage.\\n    /// @dev Will be 0 if there is no custom target float percentage for the Vault.\\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\\n    mapping(Vault => uint256) public getVaultCustomTargetFloatPercent;\\n\\n    /// @notice Sets the custom fee percentage for the Vault.\\n    /// @param vault The Vault to set the custom fee percentage for.\\n    /// @param customFeePercent The new custom fee percentage to set.\\n    function setVaultCustomFeePercent(Vault vault, uint256 customFeePercent) external requiresAuth {\\n        // Update the Vault's custom fee percentage.\\n        getVaultCustomFeePercent[vault] = customFeePercent;\\n\\n        emit CustomFeePercentUpdated(vault, customFeePercent);\\n    }\\n\\n    /// @notice Sets the custom harvest delay for the Vault.\\n    /// @param vault The Vault to set the custom harvest delay for.\\n    /// @param customHarvestDelay The new custom harvest delay to set.\\n    function setVaultCustomHarvestDelay(Vault vault, uint64 customHarvestDelay) external requiresAuth {\\n        // Update the Vault's custom harvest delay.\\n        getVaultCustomHarvestDelay[vault] = customHarvestDelay;\\n\\n        emit CustomHarvestDelayUpdated(vault, customHarvestDelay);\\n    }\\n\\n    /// @notice Sets the custom harvest window for the Vault.\\n    /// @param vault The Vault to set the custom harvest window for.\\n    /// @param customHarvestWindow The new custom harvest window to set.\\n    function setVaultCustomHarvestWindow(Vault vault, uint128 customHarvestWindow) external requiresAuth {\\n        // Update the Vault's custom harvest window.\\n        getVaultCustomHarvestWindow[vault] = customHarvestWindow;\\n\\n        emit CustomHarvestWindowUpdated(vault, customHarvestWindow);\\n    }\\n\\n    /// @notice Sets the custom target float percentage for the Vault.\\n    /// @param vault The Vault to set the custom target float percentage for.\\n    /// @param customTargetFloatPercent The new custom target float percentage to set.\\n    function setVaultCustomTargetFloatPercent(Vault vault, uint256 customTargetFloatPercent) external requiresAuth {\\n        // Update the Vault's custom target float percentage.\\n        getVaultCustomTargetFloatPercent[vault] = customTargetFloatPercent;\\n\\n        emit CustomTargetFloatPercentUpdated(vault, customTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       VAULT PARAMETER SYNC LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Syncs a Vault's fee percentage with either the Vault's custom fee\\n    /// percentage or the default fee percentage if a custom percentage is not set.\\n    /// @param vault The Vault to sync the fee percentage for.\\n    function syncFeePercent(Vault vault) external {\\n        // Get the Vault's custom fee percentage.\\n        uint256 customFeePercent = getVaultCustomFeePercent[vault];\\n\\n        // Determine what the new fee percentage should be for the Vault after the sync.\\n        uint256 newFeePercent = customFeePercent == 0 ? defaultFeePercent : customFeePercent;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.feePercent() != newFeePercent, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's fee percentage to the custom fee percentage\\n        // or the default fee percentage if a custom percentage isn't set.\\n        vault.setFeePercent(newFeePercent);\\n    }\\n\\n    /// @notice Syncs a Vault's harvest delay with either the Vault's custom\\n    /// harvest delay or the default harvest delay if a custom delay is not set.\\n    /// @param vault The Vault to sync the harvest delay for.\\n    function syncHarvestDelay(Vault vault) external {\\n        // Get the Vault's custom harvest delay.\\n        uint64 customHarvestDelay = getVaultCustomHarvestDelay[vault];\\n\\n        // Determine what the new harvest delay should be for the Vault after the sync.\\n        uint64 newHarvestDelay = customHarvestDelay == 0 ? defaultHarvestDelay : customHarvestDelay;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.harvestDelay() != newHarvestDelay, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's harvest delay to the custom harvest delay\\n        // or the default harvest delay if a custom delay isn't set.\\n        vault.setHarvestDelay(newHarvestDelay);\\n    }\\n\\n    /// @notice Syncs a Vault's harvest window with either the Vault's custom\\n    /// harvest window or the default harvest window if a custom window is not set.\\n    /// @param vault The Vault to sync the harvest window for.\\n    function syncHarvestWindow(Vault vault) external {\\n        // Get the Vault's custom harvest window.\\n        uint128 customHarvestWindow = getVaultCustomHarvestWindow[vault];\\n\\n        // Determine what the new harvest window should be for the Vault after the sync.\\n        uint128 newHarvestWindow = customHarvestWindow == 0 ? defaultHarvestWindow : customHarvestWindow;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.harvestWindow() != newHarvestWindow, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's harvest window to the custom harvest window\\n        // or the default harvest window if a custom window isn't set.\\n        vault.setHarvestWindow(newHarvestWindow);\\n    }\\n\\n    /// @notice Syncs a Vault's target float percentage with either the Vault's custom target\\n    /// float percentage or the default target float percentage if a custom percentage is not set.\\n    /// @param vault The Vault to sync the target float percentage for.\\n    function syncTargetFloatPercent(Vault vault) external {\\n        // Get the Vault's custom target float percentage.\\n        uint256 customTargetFloatPercent = getVaultCustomTargetFloatPercent[vault];\\n\\n        // Determine what the new target float percentage should be for the Vault after the sync.\\n        uint256 newTargetFloatPercent = customTargetFloatPercent == 0\\n            ? defaultTargetFloatPercent\\n            : customTargetFloatPercent;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.targetFloatPercent() != newTargetFloatPercent, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's target float percentage to the custom target float percentage\\n        // or the default target float percentage if a custom percentage isn't set.\\n        vault.setTargetFloatPercent(newTargetFloatPercent);\\n    }\\n}\\n\"\n    },\n    \"srcBuild/AphraToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\ncontract AphraToken is ERC20(\\\"Aphra Finance DAO\\\", \\\"APHRA\\\", 18) {\\n\\n\\n    error NotMinter();\\n    event MinterChanged(address newMinter, address minter);\\n\\n    address public minter;\\n    constructor(\\n    ) {\\n        minter = msg.sender;\\n        _mint(msg.sender, 0);\\n    }\\n\\n    function setMinter(address newMinter_) external {\\n        if (msg.sender != minter) revert NotMinter();\\n        minter = newMinter_;\\n        emit MinterChanged(newMinter_, minter);\\n    }\\n\\n    function mint(address account, uint amount) external returns (bool) {\\n        if (msg.sender != minter) revert NotMinter();\\n        _mint(account, amount);\\n        return true;\\n    }\\n}\\n\"\n    },\n    \"srcBuild/MultiRolesAuthority.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\\ncontract MultiRolesAuthority is Auth, Authority {\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\\n\\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\\n\\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\\n\\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                       CUSTOM TARGET AUTHORITY STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => Authority) public getTargetCustomAuthority;\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                            ROLE/USER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => bytes32) public getUserRoles;\\n\\n    mapping(bytes4 => bool) public isCapabilityPublic;\\n\\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\\n\\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\\n    }\\n\\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                          AUTHORIZATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) public view virtual override returns (bool) {\\n        Authority customAuthority = getTargetCustomAuthority[target];\\n\\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\\n\\n        return\\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\\n        getTargetCustomAuthority[target] = customAuthority;\\n\\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\\n        isCapabilityPublic[functionSig] = enabled;\\n\\n        emit PublicCapabilityUpdated(functionSig, enabled);\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                      USER ROLE ASSIGNMENT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setUserRole(\\n        address user,\\n        uint8 role,\\n        bool enabled\\n    ) public virtual requiresAuth {\\n        if (enabled) {\\n            getUserRoles[user] |= bytes32(1 << role);\\n        } else {\\n            getUserRoles[user] &= ~bytes32(1 << role);\\n        }\\n\\n        emit UserRoleUpdated(user, role, enabled);\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n                  ROLE CAPABILITY CONFIGURATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setRoleCapability(\\n        uint8 role,\\n        bytes4 functionSig,\\n        bool enabled\\n    ) public virtual requiresAuth {\\n        if (enabled) {\\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\\n        } else {\\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\\n        }\\n\\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\\n    }\\n}\\n\"\n    },\n    \"srcBuild/modules/VaultAuthorityModule.sol\": {\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\n/// @title Rari Vault Authority Module\\n/// @notice Module for managing access to secured Vault operations.\\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\\ncontract VaultAuthorityModule is Auth, Authority {\\n    /* //////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Creates a Vault configuration module.\\n    /// @param _owner The owner of the module.\\n    /// @param _authority The Authority of the module.\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       CUSTOM TARGET AUTHORITY STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Maps targets to a custom Authority to use for authorization.\\n    mapping(address => Authority) public getTargetCustomAuthority;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             USER ROLE STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Maps users to a bytes32 set of all the roles assigned to them.\\n    mapping(address => bytes32) public getUserRoles;\\n\\n    /// @notice Gets whether a user has a specific role.\\n    /// @param user The user to check for.\\n    /// @param role The role to check if the user has.\\n    /// @return A boolean indicating whether the user has the role.\\n    function doesUserHaveRole(address user, uint8 role) external view returns (bool) {\\n        unchecked {\\n            // Generate a mask for the role.\\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\\n\\n            // Check if the user has the role using the generated mask.\\n            return bytes32(0) != getUserRoles[user] & shifted;\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        ROLE CAPABILITY STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Maps function signatures to a set of all roles that can call the given function.\\n    mapping(bytes4 => bytes32) public getRoleCapabilities;\\n\\n    /// @notice Maps function signatures to a boolean indicating whether anyone can call the given function.\\n    mapping(bytes4 => bool) public isCapabilityPublic;\\n\\n    /// @notice Gets whether a role has a specific capability.\\n    /// @param role The role to check for.\\n    /// @param functionSig function to check the role is capable of calling.\\n    /// @return A boolean indicating whether the role has the capability.\\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) external view virtual returns (bool) {\\n        unchecked {\\n            // Generate a mask for the role.\\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\\n\\n            // Check if the role has the capability using the generated mask.\\n            return bytes32(0) != getRoleCapabilities[functionSig] & shifted;\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          AUTHORIZATION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Returns if a user can call a given target's function.\\n    /// @param user The user to check for.\\n    /// @param target The target the user is trying to call.\\n    /// @param functionSig The function signature the user is trying to call.\\n    /// @return A boolean indicating if the user can call the function on the target.\\n    /// @dev First checks whether the target has a custom Authority assigned to it, if so returns\\n    /// whether the custom Authority would allow the user to call the desired function on the target,\\n    /// otherwise returns whether the user is able to call the desired function on any target contract.\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view override returns (bool) {\\n        // Get the target's custom Authority. Will be address(0) if none.\\n        Authority customAuthority = getTargetCustomAuthority[target];\\n\\n        // If a custom Authority is set, return whether the Authority allows the user to call the function.\\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\\n\\n        // Return whether the user has an authorized role or the capability is publicly accessible.\\n        return bytes32(0) != getUserRoles[user] & getRoleCapabilities[functionSig] || isCapabilityPublic[functionSig];\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a custom Authority is set for a target.\\n    /// @param target The target who had a custom Authority set.\\n    /// @param authority The custom Authority set for the target.\\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\\n\\n    /// @notice Sets a custom Authority for a target.\\n    /// @param target The target to set a custom Authority for.\\n    /// @param customAuthority The custom Authority to set.\\n    function setTargetCustomAuthority(address target, Authority customAuthority) external requiresAuth {\\n        // Update the target's custom Authority.\\n        getTargetCustomAuthority[target] = customAuthority;\\n\\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  ROLE CAPABILITY CONFIGURATION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a role's capabilities are updated.\\n    /// @param role The role whose capabilities were updated.\\n    /// @param functionSig The function the role was enabled to call or not.\\n    /// @param enabled Whether the role is now able to call the function or not.\\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\\n\\n    /// @notice Sets a capability for a role.\\n    /// @param role The role to set a capability for.\\n    /// @param functionSig The function to enable the role to call or not.\\n    /// @param enabled Whether the role should be able to call the function or not.\\n    function setRoleCapability(\\n        uint8 role,\\n        bytes4 functionSig,\\n        bool enabled\\n    ) external requiresAuth {\\n        // Get the previous set of role capabilities.\\n        bytes32 lastCapabilities = getRoleCapabilities[functionSig];\\n\\n        unchecked {\\n            // Generate a mask for the role.\\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\\n\\n            // Update the role's capability set with the role mask.\\n            getRoleCapabilities[functionSig] = enabled ? lastCapabilities | shifted : lastCapabilities & ~shifted;\\n        }\\n\\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when whether a capability is public is updated.\\n    /// @param functionSig The function that was made public or not.\\n    /// @param enabled Whether the function is not publicly callable or not.\\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\\n\\n    /// @notice Sets whether a capability is public or not.\\n    /// @param functionSig The function make public or not.\\n    /// @param enabled Whether the function should be public or not.\\n    function setPublicCapability(bytes4 functionSig, bool enabled) external requiresAuth {\\n        // Update whether the capability is public.\\n        isCapabilityPublic[functionSig] = enabled;\\n\\n        emit PublicCapabilityUpdated(functionSig, enabled);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                      USER ROLE ASSIGNMENT LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a user's role is updated.\\n    /// @param user The user who had their role updated.\\n    /// @param role The role the user had assigned/removed.\\n    /// @param enabled Whether the user had the role assigned/removed.\\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\\n\\n    /// @notice Assigns a role to a user.\\n    /// @param user The user to assign a role to.\\n    /// @param role The role to assign to the user.\\n    /// @param enabled Whether the user should have the role or not.\\n    function setUserRole(\\n        address user,\\n        uint8 role,\\n        bool enabled\\n    ) external requiresAuth {\\n        // Get the previous set of roles.\\n        bytes32 lastRoles = getUserRoles[user];\\n\\n        unchecked {\\n            // Generate a mask for the role.\\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\\n\\n            // Update the user's role set with the role mask.\\n            getUserRoles[user] = enabled ? lastRoles | shifted : lastRoles & ~shifted;\\n        }\\n\\n        emit UserRoleUpdated(user, role, enabled);\\n    }\\n}\\n\"\n    },\n    \"srcBuild/Minter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\ninterface ve {\\n    function token() external view returns (address);\\n    function isUnlocked() external view returns (bool);\\n    function totalSupply() external view returns (uint);\\n    function create_lock_for(uint, uint, address) external returns (uint);\\n    function transferFrom(address, address, uint) external;\\n}\\n\\ninterface underlying {\\n    function approve(address spender, uint value) external returns (bool);\\n    function mint(address, uint) external;\\n    function setMinter(address) external;\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address) external view returns (uint);\\n    function transfer(address, uint) external returns (bool);\\n}\\n\\ninterface voter {\\n    function notifyRewardAmount(uint amount) external;\\n}\\n\\ninterface ve_dist {\\n    function checkpoint_token() external;\\n    function checkpoint_total_supply() external;\\n}\\n\\n// codifies the minting rules as per ve(3,3), abstracted from the token to support any token that allows minting\\n\\n//add safetransferlib\\ncontract Minter is Auth {\\n\\n    uint internal constant week = 86400 * 7; // allows minting once per week (reset every Thursday 00:00 UTC)\\n    uint internal emission = 98;\\n    uint internal tail_emission = 2;\\n    uint internal constant target_base = 100; // 2% per week target emission\\n    uint internal constant tail_base = 1000; // 0.2% per week target emission\\n    underlying public immutable _token;\\n    voter public immutable _voter;\\n    ve public immutable _ve;\\n    ve_dist public immutable _ve_dist;\\n    uint public weekly = 625_000e18;\\n    uint public active_period;\\n    uint internal constant lock = 86400 * 7 * 52 * 2; //2 year lock\\n\\n    address internal initializer;\\n    address internal airdrop;\\n\\n    event Mint(address indexed sender, uint weekly, uint circulating_supply, uint circulating_emission);\\n\\n    constructor(\\n        address GOVERNANCE_,\\n        address AUTHORITY_,\\n        address __voter, // the voting & distribution system\\n        address  __ve, // the veAPHRA system that will be locked into\\n        address __ve_dist // the distribution system that ensures users aren't diluted after unlock\\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_)) {\\n        initializer = msg.sender;\\n        _token = underlying(ve(__ve).token());\\n        _voter = voter(__voter);\\n        _ve = ve(__ve);\\n        _ve_dist = ve_dist(__ve_dist);\\n        active_period = (block.timestamp + (1 * week)) / week * week;\\n    }\\n\\n    //for guarded launch\\n    function migrateMinter(address newMinter_) external requiresAuth {\\n        _token.setMinter(newMinter_);\\n    }\\n\\n    function initialize(\\n        address[] memory initVeLocks,\\n        uint[] memory initVeAmounts,\\n        address[] memory initToken,\\n        uint[] memory initTokenAmounts,\\n        uint max // sum amounts / max = % ownership of top protocols, so if initial 20m is distributed, and target is 25% protocol ownership, then max - 4 x 20m = 80m\\n    ) external {\\n        //setup initial mint params here, lock team as ve nft's\\n        //setup fund team vesting locks\\n        require(initializer == msg.sender);\\n        _token.mint(address(this), max);\\n        _token.approve(address(_ve), type(uint).max);\\n\\n        for (uint i = 0; i < initVeLocks.length; i++) {\\n            _ve.create_lock_for(initVeAmounts[i], lock, initVeLocks[i]);\\n        }\\n\\n        for (uint i = 0; i < initToken.length; i++) {\\n            _token.transfer(initToken[i], initTokenAmounts[i]);\\n        }\\n\\n        //set to the last item in the initToken array as it is the airdrop and we want to exclude the airdrops balance\\n        // for supply emission calculations as it can only enter into ve when claimed\\n        airdrop = address(initToken[initToken.length - 1]);\\n        initializer = address(0);\\n        active_period = (block.timestamp + week) / week * week;\\n    }\\n\\n    function setEmission(uint newEmission_) external requiresAuth {\\n        emission = newEmission_;\\n    }\\n\\n    function setTailEmission(uint newTailEmission_) external requiresAuth {\\n        tail_emission = newTailEmission_;\\n    }\\n\\n    function setWeeklyRate(uint newWeeklyRate_) external requiresAuth {\\n        weekly = newWeeklyRate_;\\n    }\\n\\n    // calculate circulating supply as total token supply - locked supply\\n    function circulating_supply() public view returns (uint) {\\n        return _token.totalSupply() - _ve.totalSupply() - _token.balanceOf(airdrop) - _token.balanceOf(owner);\\n    }\\n\\n    // emission calculation is 2% of available supply to mint adjusted by circulating / total supply\\n    function calculate_emission() public view returns (uint) {\\n        return weekly * emission * circulating_supply() / target_base / _token.totalSupply();\\n    }\\n\\n    // weekly emission takes the max of calculated (aka target) emission versus circulating tail end emission\\n    function weekly_emission() public view returns (uint) {\\n        if(!ve(_ve).isUnlocked()) {\\n            return weekly;\\n        }\\n        return Math.max(calculate_emission(), circulating_emission());\\n    }\\n\\n    // calculates tail end (infinity) emissions as 0.2% of total supply\\n    function circulating_emission() public view returns (uint) {\\n        return circulating_supply() * tail_emission / tail_base;\\n    }\\n\\n    // calculate inflation and adjust ve balances accordingly\\n    function calculate_growth(uint _minted) public view returns (uint) {\\n        if(!ve(_ve).isUnlocked()) {\\n            return 0;\\n        }\\n        return _ve.totalSupply() * _minted / _token.totalSupply();\\n    }\\n\\n    // update period can only be called once per cycle (1 week)\\n    function update_period() external returns (uint) {\\n        uint _period = active_period;\\n        if (block.timestamp >= _period + week && initializer == address(0)) { // only trigger if new week\\n            _period = block.timestamp / week * week;\\n            active_period = _period;\\n            weekly = weekly_emission();\\n\\n            uint _growth = calculate_growth(weekly);\\n            uint _required = _growth + weekly;\\n            uint _balanceOf = _token.balanceOf(address(this));\\n            if (_balanceOf < _required) {\\n                _token.mint(address(this), _required-_balanceOf);\\n            }\\n\\n            require(_token.transfer(address(_ve_dist), _growth));\\n            _ve_dist.checkpoint_token(); // checkpoint token balance that was just minted in ve_dist\\n            _ve_dist.checkpoint_total_supply(); // checkpoint supply\\n\\n            _token.approve(address(_voter), weekly);\\n            _voter.notifyRewardAmount(weekly);\\n\\n            emit Mint(msg.sender, weekly, circulating_supply(), circulating_emission());\\n        }\\n        return _period;\\n    }\\n\\n}\\n\"\n    },\n    \"srcBuild/governance/veGovernor.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\npragma experimental ABIEncoderV2;\\n\\nimport {veAPHRA} from \\\"../veAPHRA.sol\\\";\\nimport {Timelock} from \\\"./Timelock.sol\\\";\\n\\ncontract veGovernor {\\n    /// @notice The name of this contract\\n    string public constant name = \\\"Aphra veGovernor\\\";\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    function quorumVotes() public pure returns (uint) {return 12_500_000e18;} // 12.5M = 12.5% of Aphra\\n\\n    /// @notice The number of votes required in order for a voter to become a proposer\\n    function proposalThreshold() public pure returns (uint) {return 2500e18;} // 2500 = 0.000025% of Aphra\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    function proposalMaxOperations() public pure returns (uint) {return 10;} // 10 actions\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\n    function votingDelay() public pure returns (uint) {return 1;} // 1 block\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    function votingPeriod() public pure returns (uint) {return 40320;} // ~1 days in blocks (assuming 15s blocks)\\n\\n    /// @notice The address of the APHRA Protocol Timelock\\n    Timelock public timelock;\\n\\n    /// @notice The address of the veAPHRA token\\n    veAPHRA public ve;\\n\\n    /// @notice The address of the veGovernor Guardian\\n    address public guardian;\\n\\n    /// @notice The total number of proposals\\n    uint public proposalCount;\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint id;\\n\\n        /// @notice Creator of the proposal\\n        uint badgeId;\\n\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint eta;\\n\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint[] values;\\n\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint startBlock;\\n\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint endBlock;\\n\\n        /// @notice Current number of votes in favor of this proposal\\n        uint forVotes;\\n\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint againstVotes;\\n\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping(uint => Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n\\n        /// @notice Whether or not the voter supports the proposal\\n        bool support;\\n\\n        /// @notice The number of votes the voter had, which were cast\\n        uint256 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping(uint => Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping(uint => uint) public latestProposalIds;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(uint id, uint badgeId, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    event VoteCast(uint badgeId, uint proposalId, bool support, uint votes);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint id);\\n\\n    /// @notice An event emitted when a proposal has been queued in the Timelock\\n    event ProposalQueued(uint id, uint eta);\\n\\n    /// @notice An event emitted when a proposal has been executed in the Timelock\\n    event ProposalExecuted(uint id);\\n\\n    constructor(Timelock timelock_, veAPHRA ve_, address guardian_) {\\n        timelock = timelock_;\\n        ve = ve_;\\n        guardian = guardian_;\\n    }\\n    function propose(uint badgeId_, address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\\n        require(ve.balanceOfNFTAt(badgeId_, (block.number - 1)) > proposalThreshold(), \\\"veGovernor::propose: proposer votes below proposal threshold\\\");\\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \\\"veGovernor::propose: proposal function information arity mismatch\\\");\\n        require(targets.length != 0, \\\"veGovernor::propose: must provide actions\\\");\\n        require(targets.length <= proposalMaxOperations(), \\\"veGovernor::propose: too many actions\\\");\\n\\n        uint latestProposalId = latestProposalIds[badgeId_];\\n        if (latestProposalId != 0) {\\n            ProposalState proposersLatestProposalState = state(latestProposalId);\\n            require(proposersLatestProposalState != ProposalState.Active, \\\"veGovernor::propose: one live proposal per proposer, found an already active proposal\\\");\\n            require(proposersLatestProposalState != ProposalState.Pending, \\\"veGovernor::propose: one live proposal per proposer, found an already pending proposal\\\");\\n        }\\n\\n        uint startBlock = (block.number + votingDelay());\\n        uint endBlock = (startBlock + votingPeriod());\\n\\n        Proposal storage newProposal = proposals[proposalCount++];\\n\\n\\n        newProposal.id = proposalCount;\\n        newProposal.badgeId = badgeId_;\\n        newProposal.eta = 0;\\n        newProposal.targets = targets;\\n        newProposal.values = values;\\n        newProposal.signatures = signatures;\\n        newProposal.calldatas = calldatas;\\n        newProposal.startBlock = startBlock;\\n        newProposal.endBlock = endBlock;\\n        newProposal.forVotes = 0;\\n        newProposal.againstVotes = 0;\\n        newProposal.canceled = false;\\n        newProposal.executed = false;\\n\\n        latestProposalIds[newProposal.badgeId] = newProposal.id;\\n\\n        emit ProposalCreated(newProposal.id, badgeId_, targets, values, signatures, calldatas, startBlock, endBlock, description);\\n        return newProposal.id;\\n    }\\n\\n    function queue(uint proposalId_) public {\\n        require(state(proposalId_) == ProposalState.Succeeded, \\\"veGovernor::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[proposalId_];\\n        uint eta = (block.timestamp + timelock.delay());\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId_, eta);\\n    }\\n\\n    function _queueOrRevert(address target_, uint value_, string memory signature_, bytes memory data_, uint eta_) internal {\\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target_, value_, signature_, data_, eta_))), \\\"veGovernor::_queueOrRevert: proposal action already queued at eta\\\");\\n        timelock.queueTransaction(target_, value_, signature_, data_, eta_);\\n    }\\n\\n    function execute(uint proposalId_) public payable {\\n        require(state(proposalId_) == ProposalState.Queued, \\\"veGovernor::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[proposalId_];\\n        proposal.executed = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.executeTransaction{value:proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(proposalId_);\\n    }\\n\\n    function cancel(uint proposalId_) public {\\n        ProposalState currentState = state(proposalId_);\\n        require(currentState != ProposalState.Executed, \\\"veGovernor::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[proposalId_];\\n        require(msg.sender == guardian || ve.balanceOfNFTAt(proposal.badgeId, (block.number - 1)) < proposalThreshold(), \\\"veGovernor::cancel: proposer above threshold\\\");\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(proposalId_);\\n    }\\n\\n    function getActions(uint proposalId_) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\\n        Proposal storage p = proposals[proposalId_];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    function getReceipt(uint proposalId_, uint badgeId_) public view returns (Receipt memory) {\\n        return proposals[proposalId_].receipts[badgeId_];\\n    }\\n\\n    function state(uint proposalId_) public view returns (ProposalState) {\\n        require(proposalCount >= proposalId_ && proposalId_ > 0, \\\"veGovernor::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[proposalId_];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number <= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number <= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp >= (proposal.eta + timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    function castVote(uint badgeId_, uint proposalId_, bool support_) public {\\n        require(msg.sender == ve.ownerOf(badgeId_));\\n        return _castVote(badgeId_, proposalId_, support_);\\n    }\\n\\n    function castVoteBySig(uint badgeId_, uint proposalId_, bool support_, uint8 v_, bytes32 r_, bytes32 s_) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, badgeId_, proposalId_, support_));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v_, r_, s_);\\n\\n        require(signatory == ve.ownerOf(badgeId_), \\\"veGovernor::castVoteBySig: invalid signature\\\");\\n\\n        return _castVote(badgeId_, proposalId_, support_);\\n    }\\n\\n    function _castVote(uint badgeId_, uint proposalId_, bool support_) internal {\\n        require(state(proposalId_) == ProposalState.Active, \\\"veGovernor::_castVote: voting is closed\\\");\\n        Proposal storage proposal = proposals[proposalId_];\\n        Receipt storage receipt = proposal.receipts[badgeId_];\\n        require(receipt.hasVoted == false, \\\"veGovernor::_castVote: badgeId already voted\\\");\\n        uint votes = ve.balanceOfNFTAt(badgeId_, proposal.startBlock);\\n\\n        if (support_) {\\n            proposal.forVotes = proposal.forVotes + votes;\\n        } else {\\n            proposal.againstVotes = proposal.againstVotes + votes;\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support_;\\n        receipt.votes = votes;\\n\\n        emit VoteCast(badgeId_, proposalId_, support_, votes);\\n    }\\n\\n    function __acceptAdmin() public {\\n        require(msg.sender == guardian, \\\"veGovernor::__acceptAdmin: sender must be gov guardian\\\");\\n        timelock.acceptAdmin();\\n    }\\n\\n    function __abdicate() public {\\n        require(msg.sender == guardian, \\\"veGovernor::__abdicate: sender must be gov guardian\\\");\\n        guardian = address(0);\\n    }\\n\\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin_, uint eta_) public {\\n        require(msg.sender == guardian, \\\"veGovernor::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.queueTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin_), eta_);\\n    }\\n\\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin_, uint eta_) public {\\n        require(msg.sender == guardian, \\\"veGovernor::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.executeTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin_), eta_);\\n    }\\n\\n    function getChainId() internal view returns (uint) {\\n        uint chainId;\\n        assembly {chainId := chainid()}\\n        return chainId;\\n    }\\n}\\n\"\n    },\n    \"srcBuild/governance/Timelock.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\ncontract Timelock {\\n\\n    event NewAdmin(address indexed newAdmin);\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\n    event NewDelay(uint indexed newDelay);\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\\n\\n    uint public constant GRACE_PERIOD = 14 days;\\n    uint public constant MINIMUM_DELAY = 2 days;\\n    uint public constant MAXIMUM_DELAY = 30 days;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    uint public delay;\\n\\n    mapping (bytes32 => bool) public queuedTransactions;\\n\\n\\n    constructor(address admin_, uint delay_) {\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n\\n        admin = admin_;\\n        delay = delay_;\\n    }\\n\\n    receive() external payable { }\\n\\n    function setDelay(uint delay_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n        delay = delay_;\\n\\n        emit NewDelay(delay);\\n    }\\n\\n    function acceptAdmin() public {\\n        require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n        admin = msg.sender;\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(admin);\\n    }\\n\\n    function setPendingAdmin(address pendingAdmin_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\n        pendingAdmin = pendingAdmin_;\\n\\n        emit NewPendingAdmin(pendingAdmin);\\n    }\\n\\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\\n        require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n        require(eta >= getBlockTimestamp() + delay, \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = true;\\n\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\n        return txHash;\\n    }\\n\\n    function cancelTransaction(address target_, uint value_, string memory signature_, bytes memory data_, uint eta_) public {\\n        require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target_, value_, signature_, data_, eta_));\\n        queuedTransactions[txHash] = false;\\n\\n        emit CancelTransaction(txHash, target_, value_, signature_, data_, eta_);\\n    }\\n\\n    function executeTransaction(address target_, uint value_, string memory signature_, bytes memory data_, uint eta_) public payable returns (bytes memory) {\\n        require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target_, value_, signature_, data_, eta_));\\n        require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\");\\n        require(getBlockTimestamp() >= eta_, \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\");\\n        require(getBlockTimestamp() <= eta_ + GRACE_PERIOD, \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n        queuedTransactions[txHash] = false;\\n\\n        bytes memory callData;\\n\\n        if (bytes(signature_).length == 0) {\\n            callData = data_;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature_))), data_);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target_.call{value: value_}(callData);\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(txHash, target_, value_, signature_, data_, eta_);\\n\\n        return returnData;\\n    }\\n\\n    function getBlockTimestamp() internal view returns (uint) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp;\\n    }\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 200\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
      "solcInputHash": "cef1625aef0f9721a6daca916ae4d020",
      "transactionHash": "0x1df1e2a903b3b413780af894c1bcc966255ee74f6fe5a322169b1a8b3df1ed64",
      "args": [
        "0x1594B6Fd7C346376E51C4Cf46525a9c57c5ea916",
        "0xf0ec4d75057a5e1ccb9ed400b1cec9738fae58e16abe211a02b37f36cb04f882",
        "0xf8fBff4918a9D96925Ef8695978fbA347df57276"
      ]
    },
    "decoded": {
      "from": "0x1594B6Fd7C346376E51C4Cf46525a9c57c5ea916",
      "gasPrice": "130000000000",
      "gasLimit": "648495",
      "to": null,
      "value": "0",
      "nonce": 44,
      "data": "0x60c060405234801561001057600080fd5b50604051610bb3380380610bb383398101604081905261002f916101de565b600080546001600160a01b0385166001600160a01b031991821681178355600180549092169091556040518592919033907f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76908490a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350506080829052600280546001600160a01b0319166001600160a01b03831690811790915560408051637e062a3560e11b8152905163fc0c546a916004808201926020929091908290030181865afa15801561011b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013f919061021a565b6001600160a01b0390811660a081905260405163095ea7b360e01b8152918316600483015260001960248301529063095ea7b3906044016020604051808303816000875af1158015610195573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b9919061023c565b5050505061025e565b80516001600160a01b03811681146101d957600080fd5b919050565b6000806000606084860312156101f357600080fd5b6101fc846101c2565b925060208401519150610211604085016101c2565b90509250925092565b60006020828403121561022c57600080fd5b610235826101c2565b9392505050565b60006020828403121561024e57600080fd5b8151801515811461023557600080fd5b60805160a0516109236102906000396000818161010a01526105d701526000818160bd015261032901526109236000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80637a9e5e4b116100665780637a9e5e4b146101775780638da5cb5b1461018a5780638dd598fb1461019d578063bf7e214f146101b0578063d4fc9e9b146101c357600080fd5b806313af4035146100a35780632eb4a7ab146100b85780633d13f874146100f25780634732977c1461010557806373b2e80e14610144575b600080fd5b6100b66100b1366004610796565b6101d6565b005b6100df7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100b66101003660046107ba565b610277565b61012c7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e9565b610167610152366004610796565b60036020526000908152604090205460ff1681565b60405190151581526020016100e9565b6100b6610185366004610796565b61045e565b60005461012c906001600160a01b031681565b60025461012c906001600160a01b031681565b60015461012c906001600160a01b031681565b6100b66101d1366004610796565b610548565b6101ec336000356001600160e01b03191661064a565b61022c5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b60448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6001600160a01b03841660009081526003602052604090205460ff16156102b157604051630c8d9eab60e31b815260040160405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006103548484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f000000000000000000000000000000000000000000000000000000000000000092508691506106f49050565b9050806103745760405163452c2df160e11b815260040160405180910390fd5b6001600160a01b0386811660008181526003602052604090819020805460ff19166001179055600254905163d4e54c3b60e01b8152600481018990526303c26700602482015260448101929092529091169063d4e54c3b906064016020604051808303816000875af11580156103ee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104129190610846565b50856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161044e91815260200190565b60405180910390a2505050505050565b6000546001600160a01b03163314806104f3575060015460405163b700961360e01b81526001600160a01b039091169063b7009613906104b290339030906001600160e01b0319600035169060040161085f565b602060405180830381865afa1580156104cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f3919061088c565b6104fc57600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b61055e336000356001600160e01b03191661064a565b6105995760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610223565b600280546001600160a01b0319166001600160a01b0383811691821790925560405163095ea7b360e01b8152600481019190915260001960248201527f00000000000000000000000000000000000000000000000000000000000000009091169063095ea7b3906044016020604051808303816000875af1158015610622573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610646919061088c565b5050565b6001546000906001600160a01b031680158015906106d4575060405163b700961360e01b81526001600160a01b0382169063b7009613906106939087903090889060040161085f565b602060405180830381865afa1580156106b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d4919061088c565b806106ec57506000546001600160a01b038581169116145b949350505050565b600082610701858461070a565b14949350505050565b600081815b845181101561077657600085828151811061072c5761072c6108ae565b602002602001015190508083116107525760008381526020829052604090209250610763565b600081815260208490526040902092505b508061076e816108c4565b91505061070f565b509392505050565b6001600160a01b038116811461079357600080fd5b50565b6000602082840312156107a857600080fd5b81356107b38161077e565b9392505050565b600080600080606085870312156107d057600080fd5b84356107db8161077e565b935060208501359250604085013567ffffffffffffffff808211156107ff57600080fd5b818701915087601f83011261081357600080fd5b81358181111561082257600080fd5b8860208260051b850101111561083757600080fd5b95989497505060200194505050565b60006020828403121561085857600080fd5b5051919050565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561089e57600080fd5b815180151581146107b357600080fd5b634e487b7160e01b600052603260045260246000fd5b60006000198214156108e657634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220a2441b2b59bbf334515989f62a464e9cd66f423ffbb277380b7e3fb1c1e8cdb764736f6c634300080b00330000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916f0ec4d75057a5e1ccb9ed400b1cec9738fae58e16abe211a02b37f36cb04f882000000000000000000000000f8fbff4918a9d96925ef8695978fba347df57276",
      "r": "0x6c647422f124eb500c8a0643ea0e02839db9564abf1cb0ec15b5244d63c1da76",
      "s": "0x5d2be07eebbe952f8c23c354cca5fcc3987981801100ac0ffd545aa86429933e",
      "v": 38,
      "chainId": 1
    }
  }
}