{
  "address": "0x20AC64C9C6f38F9B2911f3E4668aD8A0A89D2965",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ERC20",
          "name": "UNDERLYING_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "GOVERNANCE_",
          "type": "address"
        },
        {
          "internalType": "contract Authority",
          "name": "AUTHORITY_",
          "type": "address"
        },
        {
          "internalType": "contract IRewards",
          "name": "REWARDS_",
          "type": "address"
        },
        {
          "internalType": "contract Gauge",
          "name": "GAUGE_",
          "type": "address"
        },
        {
          "internalType": "contract Bribe",
          "name": "BRIBE_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "AuthorityUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "payment",
          "type": "uint256"
        }
      ],
      "name": "BribePaid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "DevWithdraw",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnerUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BRIBE",
      "outputs": [
        {
          "internalType": "contract Bribe",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DOMAIN_SEPARATOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GAUGE",
      "outputs": [
        {
          "internalType": "contract Gauge",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PERMIT_TYPEHASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REWARDS",
      "outputs": [
        {
          "internalType": "contract IRewards",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__emergencyExit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "authority",
      "outputs": [
        {
          "internalType": "contract Authority",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "balanceOfUnderlying",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bribeRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bribeRateBase",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ERC20",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "emergencyWithdrawalToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gaugeRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gaugeRateBase",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isCEther",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "mint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "nonces",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "permit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "redeemUnderlying",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "setAuthority",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newGaugeRateBase_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newBribeRateBase_",
          "type": "uint256"
        }
      ],
      "name": "setBaseRates",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Gauge",
          "name": "newGauge_",
          "type": "address"
        },
        {
          "internalType": "contract Bribe",
          "name": "newBribe_",
          "type": "address"
        }
      ],
      "name": "setGaugeBribe",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "setOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newGaugeRate_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newBribeRate_",
          "type": "uint256"
        }
      ],
      "name": "setRates",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "underlying",
      "outputs": [
        {
          "internalType": "contract ERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x9c426eb697ae0a6108a2d6f36be19d408323126ad591a6df458025854855655f",
  "receipt": {
    "to": null,
    "from": "0x1594B6Fd7C346376E51C4Cf46525a9c57c5ea916",
    "contractAddress": "0x20AC64C9C6f38F9B2911f3E4668aD8A0A89D2965",
    "transactionIndex": 129,
    "gasUsed": "2055377",
    "logsBloom": "0x00000000000000000100000000000000000000880000000000000000000000100000000000000000000010000000000000100000000000000000000000200004000000400080000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000080000000000000000000400000000020000000000001020000000000002000000040000000000000000000000000000000000000000000000000000000000000000000000000001000000000000080080400000000000010000000012000020000000000040000000000000000000800000020000000",
    "blockHash": "0x6dab55e33cfc6e65574ed55d7d5563f503aef0002ff602be75528275852c5ae0",
    "transactionHash": "0x9c426eb697ae0a6108a2d6f36be19d408323126ad591a6df458025854855655f",
    "logs": [
      {
        "transactionIndex": 129,
        "blockNumber": 14314030,
        "transactionHash": "0x9c426eb697ae0a6108a2d6f36be19d408323126ad591a6df458025854855655f",
        "address": "0x20AC64C9C6f38F9B2911f3E4668aD8A0A89D2965",
        "topics": [
          "0x8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916",
          "0x0000000000000000000000004d03fb78bda67a04f1bd6fde5024759d8ce8d866"
        ],
        "data": "0x",
        "logIndex": 164,
        "blockHash": "0x6dab55e33cfc6e65574ed55d7d5563f503aef0002ff602be75528275852c5ae0"
      },
      {
        "transactionIndex": 129,
        "blockNumber": 14314030,
        "transactionHash": "0x9c426eb697ae0a6108a2d6f36be19d408323126ad591a6df458025854855655f",
        "address": "0x20AC64C9C6f38F9B2911f3E4668aD8A0A89D2965",
        "topics": [
          "0xa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b76389980198",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916",
          "0x000000000000000000000000cbb46b017e8d785c107e97c56135894b3ead599c"
        ],
        "data": "0x",
        "logIndex": 165,
        "blockHash": "0x6dab55e33cfc6e65574ed55d7d5563f503aef0002ff602be75528275852c5ae0"
      },
      {
        "transactionIndex": 129,
        "blockNumber": 14314030,
        "transactionHash": "0x9c426eb697ae0a6108a2d6f36be19d408323126ad591a6df458025854855655f",
        "address": "0x7abD51BbA7f9F6Ae87aC77e1eA1C5783adA56e5c",
        "topics": [
          "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925",
          "0x00000000000000000000000020ac64c9c6f38f9b2911f3e4668ad8a0a89d2965",
          "0x0000000000000000000000002413e4594aade7513ab6dc43209d4c312cc35121"
        ],
        "data": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "logIndex": 166,
        "blockHash": "0x6dab55e33cfc6e65574ed55d7d5563f503aef0002ff602be75528275852c5ae0"
      }
    ],
    "blockNumber": 14314030,
    "cumulativeGasUsed": "10590831",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x7abD51BbA7f9F6Ae87aC77e1eA1C5783adA56e5c",
    "0x4d03Fb78BdA67a04f1bD6fDE5024759D8Ce8D866",
    "0xcbb46b017e8d785C107e97c56135894b3eAD599C",
    "0x2413e4594aadE7513AB6Dc43209D4C312cC35121",
    "0xEA7aD26d1B722518F7a9Af4E75eFAF8DfD042034",
    "0xA4d1aD4325eF52b76495d52B79402e91961931d5"
  ],
  "numDeployments": 1,
  "solcInputHash": "4d09adc899edeff0cfd6e0df664f4472",
  "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"UNDERLYING_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"GOVERNANCE_\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"AUTHORITY_\",\"type\":\"address\"},{\"internalType\":\"contract IRewards\",\"name\":\"REWARDS_\",\"type\":\"address\"},{\"internalType\":\"contract Gauge\",\"name\":\"GAUGE_\",\"type\":\"address\"},{\"internalType\":\"contract Bribe\",\"name\":\"BRIBE_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"BribePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"DevWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BRIBE\",\"outputs\":[{\"internalType\":\"contract Bribe\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAUGE\",\"outputs\":[{\"internalType\":\"contract Gauge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS\",\"outputs\":[{\"internalType\":\"contract IRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__emergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribeRateBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"emergencyWithdrawalToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeRateBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCEther\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGaugeRateBase_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBribeRateBase_\",\"type\":\"uint256\"}],\"name\":\"setBaseRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Gauge\",\"name\":\"newGauge_\",\"type\":\"address\"},{\"internalType\":\"contract Bribe\",\"name\":\"newBribe_\",\"type\":\"address\"}],\"name\":\"setGaugeBribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGaugeRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBribeRate_\",\"type\":\"uint256\"}],\"name\":\"setRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"balanceOfUnderlying(address)\":{\"details\":\"May mutate the state of the strategy by accruing interest.\",\"params\":{\"user\":\"The user to get the underlying balance of.\"},\"returns\":{\"_0\":\"The user's strategy balance in underlying tokens.\"}},\"isCEther()\":{\"details\":\"Only present in Fuse cTokens, not Compound cTokens.\",\"returns\":{\"_0\":\"True if the strategy accepts ETH, false otherwise.\"}},\"mint(uint256)\":{\"params\":{\"amount\":\"The amount of underlying tokens to deposit.\"},\"returns\":{\"_0\":\"An error code, or 0 if the deposit was successful.\"}},\"redeemUnderlying(uint256)\":{\"params\":{\"amount\":\"The amount of underlying tokens to withdraw.\"},\"returns\":{\"_0\":\"An error code, or 0 if the withdrawal was successful.\"}},\"underlying()\":{\"returns\":{\"_0\":\"The underlying ERC20 token the strategy accepts.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"balanceOfUnderlying(address)\":{\"notice\":\"Returns a user's strategy balance in underlying tokens.\"},\"isCEther()\":{\"notice\":\"Returns whether the strategy accepts ETH or an ERC20.\"},\"mint(uint256)\":{\"notice\":\"Deposit a specific amount of underlying tokens into the strategy.\"},\"redeemUnderlying(uint256)\":{\"notice\":\"Withdraws a specific amount of underlying tokens from the strategy.\"},\"underlying()\":{\"notice\":\"Returns the underlying ERC20 token the strategy accepts.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"srcBuild/strategies/USDV3CRVRewardStrategy.sol\":\"USDV3CRVRewardStrategy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@rari-capital/solmate/src/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x45a3dedcffe229eb4393a1ac5233da3d332cddae4cf97fc44602614329c1f70a\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x698cdbf614109fafc2bf00057b60715fa3aba9dad447c42f4f8b749ae16ce84f\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/WETH.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\",\"keccak256\":\"0xd36c6fffd35b32b984b9130ce988fd7fc02f3b004fde160e583131212b0d655f\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x <= type(uint248).max);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x <= type(uint96).max);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x <= type(uint64).max);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max);\\n\\n        y = uint32(x);\\n    }\\n}\\n\",\"keccak256\":\"0x4d6a75e263a7366389540e0f9065923f50b7fb8f171f99163a81fe93e4cf24a9\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcc39d0f5693925ea1e8c517f7cc24211a9899c83a57e62d806180cdb056b6b75\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/Bribe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\ninterface erc20 {\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function balanceOf(address) external view returns (uint);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n}\\n\\ninterface ve {\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function ownerOf(uint) external view returns (address);\\n}\\n\\ninterface IVoter {\\n    function _ve() external view returns (address);\\n}\\n\\n// Bribes pay out rewards for a given pool based on the votes that were received from the user (goes hand in hand with BaseV1Gauges.vote())\\ncontract Bribe {\\n\\n    address public immutable factory; // only factory can modify balances (since it only happens on vote())\\n    address public immutable _ve;\\n\\n    uint public constant DURATION = 7 days; // rewards are released over 7 days\\n    uint public constant PRECISION = 10 ** 18;\\n\\n    // default snx staking contract implementation\\n    mapping(address => uint) public rewardRate;\\n    mapping(address => uint) public periodFinish;\\n    mapping(address => uint) public lastUpdateTime;\\n    mapping(address => uint) public rewardPerTokenStored;\\n\\n    mapping(address => mapping(uint => uint)) public lastEarn;\\n    mapping(address => mapping(uint => uint)) public userRewardPerTokenStored;\\n\\n    address[] public rewards;\\n    mapping(address => bool) public isReward;\\n\\n    uint public totalSupply;\\n    mapping(uint => uint) public balanceOf;\\n\\n    /// @notice A checkpoint for marking balance\\n    struct Checkpoint {\\n        uint timestamp;\\n        uint balanceOf;\\n    }\\n\\n    /// @notice A checkpoint for marking reward rate\\n    struct RewardPerTokenCheckpoint {\\n        uint timestamp;\\n        uint rewardPerToken;\\n    }\\n\\n    /// @notice A checkpoint for marking supply\\n    struct SupplyCheckpoint {\\n        uint timestamp;\\n        uint supply;\\n    }\\n\\n    /// @notice A record of balance checkpoints for each account, by index\\n    mapping (uint => mapping (uint => Checkpoint)) public checkpoints;\\n    /// @notice The number of checkpoints for each account\\n    mapping (uint => uint) public numCheckpoints;\\n    /// @notice A record of balance checkpoints for each token, by index\\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\\n    /// @notice The number of checkpoints\\n    uint public supplyNumCheckpoints;\\n    /// @notice A record of balance checkpoints for each token, by index\\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\\n    /// @notice The number of checkpoints for each token\\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\\n\\n    event Deposit(address indexed from, uint tokenId, uint amount);\\n    event Withdraw(address indexed from, uint tokenId, uint amount);\\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\\n\\n    constructor(address _factory) {\\n        factory = _factory;\\n        _ve = IVoter(_factory)._ve();\\n    }\\n\\n    // simple re-entrancy check\\n    uint internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    /**\\n    * @notice Determine the prior balance for an account as of a block number\\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n    * @param tokenId The token of the NFT to check\\n    * @param timestamp The timestamp to get the balance at\\n    * @return The balance the account had as of the given block\\n    */\\n    function getPriorBalanceIndex(uint tokenId, uint timestamp) public view returns (uint) {\\n        uint nCheckpoints = numCheckpoints[tokenId];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[tokenId][nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[tokenId][0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint lower = 0;\\n        uint upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[tokenId][center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\\n        uint nCheckpoints = supplyNumCheckpoints;\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (supplyCheckpoints[0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint lower = 0;\\n        uint upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\\n        if (nCheckpoints == 0) {\\n            return (0,0);\\n        }\\n\\n        // First check most recent balance\\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\\n            return (0,0);\\n        }\\n\\n        uint lower = 0;\\n        uint upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\\n            if (cp.timestamp == timestamp) {\\n                return (cp.rewardPerToken, cp.timestamp);\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\\n    }\\n\\n    function _writeCheckpoint(uint tokenId, uint balance) internal {\\n        uint _timestamp = block.timestamp;\\n        uint _nCheckPoints = numCheckpoints[tokenId];\\n\\n        if (_nCheckPoints > 0 && checkpoints[tokenId][_nCheckPoints - 1].timestamp == _timestamp) {\\n            checkpoints[tokenId][_nCheckPoints - 1].balanceOf = balance;\\n        } else {\\n            checkpoints[tokenId][_nCheckPoints] = Checkpoint(_timestamp, balance);\\n            numCheckpoints[tokenId] = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\\n\\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\\n        } else {\\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function _writeSupplyCheckpoint() internal {\\n        uint _nCheckPoints = supplyNumCheckpoints;\\n        uint _timestamp = block.timestamp;\\n\\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\\n            supplyCheckpoints[_nCheckPoints - 1].supply = totalSupply;\\n        } else {\\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, totalSupply);\\n            supplyNumCheckpoints = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function rewardsListLength() external view returns (uint) {\\n        return rewards.length;\\n    }\\n\\n    // returns the last time the reward was modified or periodFinish if the reward has ended\\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\\n        return Math.min(block.timestamp, periodFinish[token]);\\n    }\\n\\n    // allows a user to claim rewards for a given token\\n    function getReward(uint tokenId, address[] memory tokens) external lock  {\\n        require(ve(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        for (uint i = 0; i < tokens.length; i++) {\\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\\n\\n            uint _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            userRewardPerTokenStored[tokens[i]][tokenId] = rewardPerTokenStored[tokens[i]];\\n            if (_reward > 0) _safeTransfer(tokens[i], msg.sender, _reward);\\n\\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\\n        }\\n    }\\n\\n    // used by BaseV1Voter to allow batched reward claims\\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external lock  {\\n        require(msg.sender == factory);\\n        address _owner = ve(_ve).ownerOf(tokenId);\\n        for (uint i = 0; i < tokens.length; i++) {\\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\\n\\n            uint _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            userRewardPerTokenStored[tokens[i]][tokenId] = rewardPerTokenStored[tokens[i]];\\n            if (_reward > 0) _safeTransfer(tokens[i], _owner, _reward);\\n\\n            emit ClaimRewards(_owner, tokens[i], _reward);\\n        }\\n    }\\n\\n    function rewardPerToken(address token) public view returns (uint) {\\n        if (totalSupply == 0) {\\n            return rewardPerTokenStored[token];\\n        }\\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / totalSupply);\\n    }\\n\\n    function batchRewardPerToken(address token, uint maxRuns) external {\\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\\n    }\\n\\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\\n        uint _startTimestamp = lastUpdateTime[token];\\n        uint reward = rewardPerTokenStored[token];\\n\\n        if (supplyNumCheckpoints == 0) {\\n            return (reward, _startTimestamp);\\n        }\\n\\n        if (rewardRate[token] == 0) {\\n            return (reward, block.timestamp);\\n        }\\n\\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\\n\\n        for (uint i = _startIndex; i < _endIndex; i++) {\\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\\n            if (sp0.supply > 0) {\\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\\n                (uint _reward, uint endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\\n                reward += _reward;\\n                _writeRewardPerTokenCheckpoint(token, reward, endTime);\\n                _startTimestamp = endTime;\\n            }\\n        }\\n\\n        return (reward, _startTimestamp);\\n    }\\n\\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\\n        uint endTime = Math.max(timestamp1, startTimestamp);\\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\\n    }\\n\\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\\n        uint _startTimestamp = lastUpdateTime[token];\\n        uint reward = rewardPerTokenStored[token];\\n\\n        if (supplyNumCheckpoints == 0) {\\n            return (reward, _startTimestamp);\\n        }\\n\\n        if (rewardRate[token] == 0) {\\n            return (reward, block.timestamp);\\n        }\\n\\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\\n        uint _endIndex = supplyNumCheckpoints-1;\\n\\n        if (_endIndex - _startIndex > 1) {\\n            for (uint i = _startIndex; i < _endIndex-1; i++) {\\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\\n                if (sp0.supply > 0) {\\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\\n                    reward += _reward;\\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\\n                    _startTimestamp = _endTime;\\n                }\\n            }\\n        }\\n\\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\\n        if (sp.supply > 0) {\\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\\n            reward += _reward;\\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\\n            _startTimestamp = block.timestamp;\\n        }\\n\\n        return (reward, _startTimestamp);\\n    }\\n\\n    function earned(address token, uint tokenId) public view returns (uint) {\\n        uint _startTimestamp = Math.max(lastEarn[token][tokenId], rewardPerTokenCheckpoints[token][0].timestamp);\\n        if (numCheckpoints[tokenId] == 0) {\\n            return 0;\\n        }\\n\\n        uint _startIndex = getPriorBalanceIndex(tokenId, _startTimestamp);\\n        uint _endIndex = numCheckpoints[tokenId]-1;\\n\\n        uint reward = 0;\\n\\n        if (_endIndex - _startIndex > 1) {\\n            for (uint i = _startIndex; i < _endIndex-1; i++) {\\n                Checkpoint memory cp0 = checkpoints[tokenId][i];\\n                Checkpoint memory cp1 = checkpoints[tokenId][i+1];\\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\\n                reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\\n            }\\n        }\\n\\n        Checkpoint memory cp = checkpoints[tokenId][_endIndex];\\n        (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\\n        reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][tokenId])) / PRECISION;\\n\\n        return reward;\\n    }\\n\\n    // This is an external function, but internal notation is used since it can only be called \\\"internally\\\" from BaseV1Gauges\\n    function _deposit(uint amount, uint tokenId) external {\\n        require(msg.sender == factory);\\n        totalSupply += amount;\\n        balanceOf[tokenId] += amount;\\n\\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\\n        _writeSupplyCheckpoint();\\n\\n        emit Deposit(msg.sender, tokenId, amount);\\n    }\\n\\n    function _withdraw(uint amount, uint tokenId) external {\\n        require(msg.sender == factory);\\n        totalSupply -= amount;\\n        balanceOf[tokenId] -= amount;\\n\\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\\n        _writeSupplyCheckpoint();\\n\\n        emit Withdraw(msg.sender, tokenId, amount);\\n    }\\n\\n    function left(address token) external view returns (uint) {\\n        if (block.timestamp >= periodFinish[token]) return 0;\\n        uint _remaining = periodFinish[token] - block.timestamp;\\n        return _remaining * rewardRate[token];\\n    }\\n\\n    // used to notify a gauge/bribe of a given reward, this can create griefing attacks by extending rewards\\n    function notifyRewardAmount(address token, uint amount) external lock {\\n        require(amount > 0);\\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, block.timestamp);\\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\\n\\n        if (block.timestamp >= periodFinish[token]) {\\n            _safeTransferFrom(token, msg.sender, address(this), amount);\\n            rewardRate[token] = amount / DURATION;\\n        } else {\\n            uint _remaining = periodFinish[token] - block.timestamp;\\n            uint _left = _remaining * rewardRate[token];\\n            require(amount > _left);\\n            _safeTransferFrom(token, msg.sender, address(this), amount);\\n            rewardRate[token] = (amount + _left) / DURATION;\\n        }\\n        require(rewardRate[token] > 0);\\n        uint balance = erc20(token).balanceOf(address(this));\\n        require(rewardRate[token] <= balance / DURATION, \\\"Provided reward too high\\\");\\n        periodFinish[token] = block.timestamp + DURATION;\\n        if (!isReward[token]) {\\n            isReward[token] = true;\\n            rewards.push(token);\\n        }\\n\\n        emit NotifyReward(msg.sender, token, amount);\\n    }\\n\\n    function _safeTransfer(address token, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\\ncontract BribeFactory {\\n    address public last_gauge;\\n\\n    function createBribe() external returns (address) {\\n        last_gauge = address(new Bribe(msg.sender));\\n        return last_gauge;\\n    }\\n}\\n\",\"keccak256\":\"0x243a737fe93e76690ff5ecba01d16b343e8cd78674d5f866a4ba1a408f863c15\",\"license\":\"MIT\"},\"srcBuild/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /* ///////////////////////////////////////////////////////////////\\n    SIMPLIFIED FIXED POINT OPERATIONS\\n    ////////////////////////////////////////////////////////////// */\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n        // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n        // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\\n                revert(0, 0)\\n            }\\n\\n        // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // First, divide z - 1 by the denominator and add 1.\\n        // Then multiply it by 0 if z is zero, or 1 otherwise.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                // 0 ** 0 = 1\\n                    z := denominator\\n                }\\n                default {\\n                // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                // If n is even, store denominator in z for now.\\n                    z := denominator\\n                }\\n                default {\\n                // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, denominator)\\n\\n                for {\\n                // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                // Revert immediately if x ** 2 would overflow.\\n                // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Set x to scaled xxRound.\\n                    x := div(xxRound, denominator)\\n\\n                // If n is even:\\n                    if mod(n, 2) {\\n                    // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                    // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                        // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                    // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                    // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                    // Return properly scaled zxRound.\\n                        z := div(zxRound, denominator)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n        // Start off with z at 1.\\n            z := 1\\n\\n        // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n        // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z)\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z)\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z)\\n            }\\n            if iszero(lt(y, 0x8)) {\\n            // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n        // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n        // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n        // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1484f097a7d98e687f22bf68cc3a58077230c075675c1d3b08439a2b402c0808\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/Gauge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\ninterface erc20 {\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function balanceOf(address) external view returns (uint);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    function approve(address spender, uint value) external returns (bool);\\n}\\n\\ninterface ve {\\n    function token() external view returns (address);\\n    function balanceOfNFT(uint) external view returns (uint);\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function isUnlocked() external view returns (bool);\\n    function locked__end(uint) external view returns (uint);\\n    function create_lock_for(uint, uint, address) external returns (uint);\\n    function deposit_for(uint, uint) external;\\n    function ownerOf(uint) external view returns (address);\\n    function transferFrom(address, address, uint) external;\\n}\\n\\ninterface IBribe {\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function left(address token) external view returns (uint);\\n}\\n\\ninterface Voter {\\n    function attachTokenToGauge(uint _tokenId, address account) external;\\n    function detachTokenFromGauge(uint _tokenId, address account) external;\\n    function emitDeposit(uint _tokenId, address account, uint amount) external;\\n    function emitWithdraw(uint _tokenId, address account, uint amount) external;\\n    function distribute(address _gauge) external;\\n}\\n\\n// Gauges are used to incentivize pools, they emit reward tokens over 7 days for staked LP tokens\\ncontract Gauge {\\n\\n    address public immutable stake; // the asset token that needs to be staked for rewards\\n    address public immutable _ve; // the ve token used for gauges\\n    address public immutable bribe;\\n    address public immutable voter;\\n\\n    bool internal depositsOpen;\\n    uint public derivedSupply;\\n    mapping(address => uint) public derivedBalances;\\n\\n    uint internal constant DURATION = 7 days; // rewards are released over 7 days\\n    uint internal constant PRECISION = 10 ** 18;\\n\\n    // default snx staking contract implementation\\n    mapping(address => uint) public rewardRate;\\n    mapping(address => uint) public periodFinish;\\n    mapping(address => uint) public lastUpdateTime;\\n    mapping(address => uint) public rewardPerTokenStored;\\n\\n    mapping(address => mapping(address => uint)) public lastEarn;\\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\\n\\n    mapping(address => uint) public tokenIds;\\n\\n    uint public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n\\n    address[] public rewards;\\n    mapping(address => bool) public isReward;\\n\\n    /// @notice A checkpoint for marking balance\\n    struct Checkpoint {\\n        uint timestamp;\\n        uint balanceOf;\\n    }\\n\\n    /// @notice A checkpoint for marking reward rate\\n    struct RewardPerTokenCheckpoint {\\n        uint timestamp;\\n        uint rewardPerToken;\\n    }\\n\\n    /// @notice A checkpoint for marking supply\\n    struct SupplyCheckpoint {\\n        uint timestamp;\\n        uint supply;\\n    }\\n\\n    /// @notice A record of balance checkpoints for each account, by index\\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint) public numCheckpoints;\\n    /// @notice A record of balance checkpoints for each token, by index\\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\\n    /// @notice The number of checkpoints\\n    uint public supplyNumCheckpoints;\\n    /// @notice A record of balance checkpoints for each token, by index\\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\\n    /// @notice The number of checkpoints for each token\\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\\n\\n    event Deposit(address indexed from, uint tokenId, uint amount);\\n    event Withdraw(address indexed from, uint tokenId, uint amount);\\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\\n\\n    constructor(address _stake, address _bribe, address __ve, address _voter) {\\n        stake = _stake;\\n        bribe = _bribe;\\n        _ve = __ve;\\n        voter = _voter;\\n        depositsOpen = true;\\n        _safeApprove(ve(__ve).token(), __ve, type(uint).max);\\n    }\\n\\n    modifier whenDepositsOpen() {\\n        require(depositsOpen, \\\"This gauge is not open for deposits\\\");\\n        _;\\n    }\\n\\n    function stopDeposits() external {\\n        require(msg.sender == voter, \\\"must be from voter\\\");\\n        depositsOpen = false;\\n    }\\n\\n    function openDeposits() external {\\n        require(msg.sender == voter, \\\"must be from voter\\\");\\n        depositsOpen = true;\\n    }\\n\\n    function isDepositsOpen() external view returns (bool) {\\n        return depositsOpen;\\n    }\\n\\n    // simple re-entrancy check\\n    uint internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    /**\\n    * @notice Determine the prior balance for an account as of a block number\\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n    * @param account The address of the account to check\\n    * @param timestamp The timestamp to get the balance at\\n    * @return The balance the account had as of the given block\\n    */\\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\\n        uint nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint lower = 0;\\n        uint upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\\n        uint nCheckpoints = supplyNumCheckpoints;\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (supplyCheckpoints[0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint lower = 0;\\n        uint upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\\n        if (nCheckpoints == 0) {\\n            return (0,0);\\n        }\\n\\n        // First check most recent balance\\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\\n            return (0,0);\\n        }\\n\\n        uint lower = 0;\\n        uint upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\\n            if (cp.timestamp == timestamp) {\\n                return (cp.rewardPerToken, cp.timestamp);\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\\n    }\\n\\n    function _writeCheckpoint(address account, uint balance) internal {\\n        uint _timestamp = block.timestamp;\\n        uint _nCheckPoints = numCheckpoints[account];\\n\\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\\n        } else {\\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance);\\n            numCheckpoints[account] = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\\n\\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\\n        } else {\\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function _writeSupplyCheckpoint() internal {\\n        uint _nCheckPoints = supplyNumCheckpoints;\\n        uint _timestamp = block.timestamp;\\n\\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\\n        } else {\\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\\n            supplyNumCheckpoints = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function rewardsListLength() external view returns (uint) {\\n        return rewards.length;\\n    }\\n\\n    // returns the last time the reward was modified or periodFinish if the reward has ended\\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\\n        return Math.min(block.timestamp, periodFinish[token]);\\n    }\\n\\n    function getReward(address account, address[] memory tokens) external lock {\\n        require(msg.sender == account || msg.sender == voter);\\n        _unlocked = 1;\\n        Voter(voter).distribute(address(this));\\n        _unlocked = 2;\\n\\n        for (uint i = 0; i < tokens.length; i++) {\\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\\n\\n            uint _reward = earned(tokens[i], account);\\n            lastEarn[tokens[i]][account] = block.timestamp;\\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\\n            if (_reward > 0) {\\n                //setup gauges to send you veAPHRA while token is unlocked\\n              if (ve(_ve).isUnlocked()) {\\n                  _safeTransfer(tokens[i], account, _reward);\\n              } else {\\n                  uint tokenId = tokenIds[msg.sender];\\n\\n                  if (tokenId == 0 || block.timestamp > ve(_ve).locked__end(tokenId)) {\\n\\n                      //set initial lock for 8 weeks\\n                      tokenIds[msg.sender] = ve(_ve).create_lock_for(_reward, DURATION * 8, msg.sender);\\n                  } else {\\n                      ve(_ve).deposit_for(tokenId, _reward);\\n                  }\\n              }\\n            }\\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\\n        }\\n\\n        uint _derivedBalance = derivedBalances[account];\\n        derivedSupply -= _derivedBalance;\\n        _derivedBalance = derivedBalance(account);\\n        derivedBalances[account] = _derivedBalance;\\n        derivedSupply += _derivedBalance;\\n\\n        _writeCheckpoint(account, derivedBalances[account]);\\n        _writeSupplyCheckpoint();\\n    }\\n\\n    function rewardPerToken(address token) public view returns (uint) {\\n        if (derivedSupply == 0) {\\n            return rewardPerTokenStored[token];\\n        }\\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\\n    }\\n\\n    function derivedBalance(address account) public view returns (uint) {\\n        uint _tokenId = tokenIds[account];\\n        uint _balance = balanceOf[account];\\n        uint _derived = _balance * 40 / 100;\\n        uint _adjusted = 0;\\n        uint _supply = erc20(_ve).totalSupply();\\n        //only activate boosts on ve unlock\\n        if (account == ve(_ve).ownerOf(_tokenId) && _supply > 0 && ve(_ve).isUnlocked()) {\\n            _adjusted = ve(_ve).balanceOfNFT(_tokenId);\\n            _adjusted = (totalSupply * _adjusted / _supply) * 60 / 100;\\n        }\\n        return Math.min((_derived + _adjusted), _balance);\\n    }\\n\\n    function batchRewardPerToken(address token, uint maxRuns) external {\\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\\n    }\\n\\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\\n        uint _startTimestamp = lastUpdateTime[token];\\n        uint reward = rewardPerTokenStored[token];\\n\\n        if (supplyNumCheckpoints == 0) {\\n            return (reward, _startTimestamp);\\n        }\\n\\n        if (rewardRate[token] == 0) {\\n            return (reward, block.timestamp);\\n        }\\n\\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\\n\\n        for (uint i = _startIndex; i < _endIndex; i++) {\\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\\n            if (sp0.supply > 0) {\\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\\n                reward += _reward;\\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\\n                _startTimestamp = _endTime;\\n            }\\n        }\\n\\n        return (reward, _startTimestamp);\\n    }\\n\\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\\n        uint endTime = Math.max(timestamp1, startTimestamp);\\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\\n    }\\n\\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\\n        uint _startTimestamp = lastUpdateTime[token];\\n        uint reward = rewardPerTokenStored[token];\\n\\n        if (supplyNumCheckpoints == 0) {\\n            return (reward, _startTimestamp);\\n        }\\n\\n        if (rewardRate[token] == 0) {\\n            return (reward, block.timestamp);\\n        }\\n\\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\\n        uint _endIndex = supplyNumCheckpoints-1;\\n\\n        if (_endIndex - _startIndex > 1) {\\n            for (uint i = _startIndex; i < _endIndex-1; i++) {\\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\\n                if (sp0.supply > 0) {\\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\\n                    reward += _reward;\\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\\n                    _startTimestamp = _endTime;\\n                }\\n            }\\n        }\\n\\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\\n        if (sp.supply > 0) {\\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\\n            reward += _reward;\\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\\n            _startTimestamp = block.timestamp;\\n        }\\n\\n        return (reward, _startTimestamp);\\n    }\\n\\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\\n    function earned(address token, address account) public view returns (uint) {\\n        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);\\n        if (numCheckpoints[account] == 0) {\\n            return 0;\\n        }\\n\\n        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);\\n        uint _endIndex = numCheckpoints[account]-1;\\n\\n        uint reward = 0;\\n\\n        if (_endIndex - _startIndex > 1) {\\n            for (uint i = _startIndex; i < _endIndex-1; i++) {\\n                Checkpoint memory cp0 = checkpoints[account][i];\\n                Checkpoint memory cp1 = checkpoints[account][i+1];\\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\\n                reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\\n            }\\n        }\\n\\n        Checkpoint memory cp = checkpoints[account][_endIndex];\\n        (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\\n        reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\\n\\n        return reward;\\n    }\\n\\n    function depositAll(uint tokenId) external {\\n        deposit(erc20(stake).balanceOf(msg.sender), tokenId);\\n    }\\n\\n    function deposit(uint amount, uint tokenId) public whenDepositsOpen lock {\\n        require(amount > 0);\\n\\n        _safeTransferFrom(stake, msg.sender, address(this), amount);\\n        totalSupply += amount;\\n        balanceOf[msg.sender] += amount;\\n\\n        if (tokenId > 0) {\\n            require(ve(_ve).ownerOf(tokenId) == msg.sender);\\n            if (tokenIds[msg.sender] == 0) {\\n                tokenIds[msg.sender] = tokenId;\\n                Voter(voter).attachTokenToGauge(tokenId, msg.sender);\\n            }\\n            require(tokenIds[msg.sender] == tokenId);\\n        } else {\\n            tokenId = tokenIds[msg.sender];\\n        }\\n\\n        uint _derivedBalance = derivedBalances[msg.sender];\\n        derivedSupply -= _derivedBalance;\\n        _derivedBalance = derivedBalance(msg.sender);\\n        derivedBalances[msg.sender] = _derivedBalance;\\n        derivedSupply += _derivedBalance;\\n\\n        _writeCheckpoint(msg.sender, _derivedBalance);\\n        _writeSupplyCheckpoint();\\n\\n        Voter(voter).emitDeposit(tokenId, msg.sender, amount);\\n        emit Deposit(msg.sender, tokenId, amount);\\n    }\\n\\n    function withdrawAll() external {\\n        withdraw(balanceOf[msg.sender]);\\n    }\\n\\n    function withdraw(uint amount) public {\\n        uint tokenId = 0;\\n        if (amount == balanceOf[msg.sender]) {\\n            tokenId = tokenIds[msg.sender];\\n        }\\n        withdrawToken(amount, tokenId);\\n    }\\n\\n    function withdrawToken(uint amount, uint tokenId) public lock {\\n        totalSupply -= amount;\\n        balanceOf[msg.sender] -= amount;\\n        _safeTransfer(stake, msg.sender, amount);\\n\\n        if (tokenId > 0) {\\n            require(tokenId == tokenIds[msg.sender]);\\n            tokenIds[msg.sender] = 0;\\n            Voter(voter).detachTokenFromGauge(tokenId, msg.sender);\\n        } else {\\n            tokenId = tokenIds[msg.sender];\\n        }\\n\\n        uint _derivedBalance = derivedBalances[msg.sender];\\n        derivedSupply -= _derivedBalance;\\n        _derivedBalance = derivedBalance(msg.sender);\\n        derivedBalances[msg.sender] = _derivedBalance;\\n        derivedSupply += _derivedBalance;\\n\\n        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);\\n        _writeSupplyCheckpoint();\\n\\n        Voter(voter).emitWithdraw(tokenId, msg.sender, amount);\\n        emit Withdraw(msg.sender, tokenId, amount);\\n    }\\n\\n    function left(address token) external view returns (uint) {\\n        if (block.timestamp >= periodFinish[token]) return 0;\\n        uint _remaining = periodFinish[token] - block.timestamp;\\n        return _remaining * rewardRate[token];\\n    }\\n\\n    function notifyRewardAmount(address token, uint amount) external lock {\\n        require(token != stake);\\n        require(amount > 0);\\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, block.timestamp);\\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\\n\\n        if (block.timestamp >= periodFinish[token]) {\\n            _safeTransferFrom(token, msg.sender, address(this), amount);\\n            rewardRate[token] = amount / DURATION;\\n        } else {\\n            uint _remaining = periodFinish[token] - block.timestamp;\\n            uint _left = _remaining * rewardRate[token];\\n            require(amount > _left);\\n            _safeTransferFrom(token, msg.sender, address(this), amount);\\n            rewardRate[token] = (amount + _left) / DURATION;\\n        }\\n        require(rewardRate[token] > 0);\\n        uint balance = erc20(token).balanceOf(address(this));\\n        require(rewardRate[token] <= balance / DURATION, \\\"Provided reward too high\\\");\\n        periodFinish[token] = block.timestamp + DURATION;\\n        if (!isReward[token]) {\\n            isReward[token] = true;\\n            rewards.push(token);\\n        }\\n\\n        emit NotifyReward(msg.sender, token, amount);\\n    }\\n\\n    function _safeTransfer(address token, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeApprove(address token, address spender, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(erc20.approve.selector, spender, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\\ncontract GaugeFactory {\\n    address public last_gauge;\\n\\n    function createGauge(address _asset, address _bribe, address _ve) external returns (address) {\\n        last_gauge = address(new Gauge(_asset, _bribe, _ve, msg.sender));\\n        return last_gauge;\\n    }\\n\\n    function createGaugeSingle(address _asset, address _bribe, address _ve, address _voter) external returns (address) {\\n        last_gauge = address(new Gauge(_asset, _bribe, _ve, _voter));\\n        return last_gauge;\\n    }\\n}\\n\",\"keccak256\":\"0x70f7dfdf31bf6067a18867aef8294174d8c26039a224e2da97cb358eab318ffc\",\"license\":\"MIT\"},\"srcBuild/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {WETH} from \\\"@rari-capital/solmate/src/tokens/WETH.sol\\\";\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeCastLib} from \\\"@rari-capital/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./FixedPointMathLib.sol\\\";\\n\\nimport {Strategy, ERC20Strategy, ETHStrategy} from \\\"./interfaces/Strategy.sol\\\";\\n\\n/// @title Aphra Vault (avToken)\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Flexible, minimalist, and gas-optimized yield\\n/// aggregator for earning interest on any ERC20 token.\\n/// @notice changes from original are to rename Rari -> Aphra tokens and any usage of rvToken => avToken\\ncontract Vault is ERC20, Auth {\\n    using SafeCastLib for uint256;\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The maximum number of elements allowed on the withdrawal stack.\\n    /// @dev Needed to prevent denial of service attacks by queue operators.\\n    uint256 internal constant MAX_WITHDRAWAL_STACK_SIZE = 32;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                IMMUTABLES\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The underlying token the Vault accepts.\\n    ERC20 public immutable UNDERLYING;\\n\\n    /// @notice The base unit of the underlying token and hence avToken.\\n    /// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\\n    uint256 internal immutable BASE_UNIT;\\n\\n    /// @notice Creates a new Vault that accepts a specific underlying token.\\n    /// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\\n    constructor(ERC20 _UNDERLYING)\\n        ERC20(\\n            // ex:Aphra Vader Vault\\n            string(abi.encodePacked(\\\"Aphra \\\", _UNDERLYING.name(), \\\" Vault\\\")),\\n            // ex: avVader\\n            string(abi.encodePacked(\\\"av\\\", _UNDERLYING.symbol())),\\n            // ex: 18\\n            _UNDERLYING.decimals()\\n        )\\n        Auth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\\n    {\\n        UNDERLYING = _UNDERLYING;\\n\\n        BASE_UNIT = 10**decimals;\\n\\n        // Prevent minting of avTokens until\\n        // the initialize function is called.\\n        totalSupply = type(uint256).max;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                           FEE CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The percentage of profit recognized each harvest to reserve as fees.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public feePercent;\\n\\n    /// @notice Emitted when the fee percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newFeePercent The new fee percentage.\\n    event FeePercentUpdated(address indexed user, uint256 newFeePercent);\\n\\n    /// @notice Sets a new fee percentage.\\n    /// @param newFeePercent The new fee percentage.\\n    function setFeePercent(uint256 newFeePercent) external requiresAuth {\\n        // A fee percentage over 100% doesn't make sense.\\n        require(newFeePercent <= 1e18, \\\"FEE_TOO_HIGH\\\");\\n\\n        // Update the fee percentage.\\n        feePercent = newFeePercent;\\n\\n        emit FeePercentUpdated(msg.sender, newFeePercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        HARVEST CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the harvest window is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestWindow The new harvest window.\\n    event HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\\n\\n    /// @notice Emitted when the harvest delay is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The new harvest delay.\\n    event HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The scheduled updated harvest delay.\\n    event HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice The period in seconds during which multiple harvests can occur\\n    /// regardless if they are taking place before the harvest delay has elapsed.\\n    /// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\\n    uint128 public harvestWindow;\\n\\n    /// @notice The period in seconds over which locked profit is unlocked.\\n    /// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\\n    uint64 public harvestDelay;\\n\\n    /// @notice The value that will replace harvestDelay next harvest.\\n    /// @dev In the case that the next delay is 0, no update will be applied.\\n    uint64 public nextHarvestDelay;\\n\\n    /// @notice Sets a new harvest window.\\n    /// @param newHarvestWindow The new harvest window.\\n    /// @dev The Vault's harvestDelay must already be set before calling.\\n    function setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\\n        // A harvest window longer than the harvest delay doesn't make sense.\\n        require(newHarvestWindow <= harvestDelay, \\\"WINDOW_TOO_LONG\\\");\\n\\n        // Update the harvest window.\\n        harvestWindow = newHarvestWindow;\\n\\n        emit HarvestWindowUpdated(msg.sender, newHarvestWindow);\\n    }\\n\\n    /// @notice Sets a new harvest delay.\\n    /// @param newHarvestDelay The new harvest delay to set.\\n    /// @dev If the current harvest delay is 0, meaning it has not\\n    /// been set before, it will be updated immediately, otherwise\\n    /// it will be scheduled to take effect after the next harvest.\\n    function setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\\n        // A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\\n        require(newHarvestDelay != 0, \\\"DELAY_CANNOT_BE_ZERO\\\");\\n\\n        // A harvest delay longer than 1 year doesn't make sense.\\n        require(newHarvestDelay <= 365 days, \\\"DELAY_TOO_LONG\\\");\\n\\n        // If the harvest delay is 0, meaning it has not been set before:\\n        if (harvestDelay == 0) {\\n            // We'll apply the update immediately.\\n            harvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        } else {\\n            // We'll apply the update next harvest.\\n            nextHarvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       TARGET FLOAT CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The desired percentage of the Vault's holdings to keep as float.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public targetFloatPercent;\\n\\n    /// @notice Emitted when the target float percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    event TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\\n\\n    /// @notice Set a new target float percentage.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    function setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\\n        // A target float percentage over 100% doesn't make sense.\\n        require(newTargetFloatPercent <= 1e18, \\\"TARGET_TOO_HIGH\\\");\\n\\n        // Update the target float percentage.\\n        targetFloatPercent = newTargetFloatPercent;\\n\\n        emit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                   UNDERLYING IS WETH CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Whether the Vault should treat the underlying token as WETH compatible.\\n    /// @dev If enabled the Vault will allow trusting strategies that accept Ether.\\n    bool public underlyingIsWETH;\\n\\n    /// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\\n    event UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\\n\\n    /// @notice Sets whether the Vault treats the underlying as WETH.\\n    /// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\\n    /// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\\n    function setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\\n        // Ensure the underlying token's decimals match ETH if is WETH being set to true.\\n        require(!newUnderlyingIsWETH || UNDERLYING.decimals() == 18, \\\"WRONG_DECIMALS\\\");\\n\\n        // Update whether the Vault treats the underlying as WETH.\\n        underlyingIsWETH = newUnderlyingIsWETH;\\n\\n        emit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          STRATEGY STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\\n    /// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\\n    uint256 public totalStrategyHoldings;\\n\\n    /// @dev Packed struct of strategy data.\\n    /// @param trusted Whether the strategy is trusted.\\n    /// @param balance The amount of underlying tokens held in the strategy.\\n    struct StrategyData {\\n        // Used to determine if the Vault will operate on a strategy.\\n        bool trusted;\\n        // Used to determine profit and loss during harvests of the strategy.\\n        uint248 balance;\\n    }\\n\\n    /// @notice Maps strategies to data the Vault holds on them.\\n    mapping(Strategy => StrategyData) public getStrategyData;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\\n    /// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\\n    uint64 public lastHarvestWindowStart;\\n\\n    /// @notice A timestamp representing when the most recent harvest occurred.\\n    uint64 public lastHarvest;\\n\\n    /// @notice The amount of locked profit at the end of the last harvest.\\n    uint128 public maxLockedProfit;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        WITHDRAWAL STACK STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice An ordered array of strategies representing the withdrawal stack.\\n    /// @dev The stack is processed in descending order, meaning the last index will be withdrawn from first.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\\n    /// withdrawal time, not validated upfront, meaning the stack may not reflect the \\\"true\\\" set used for withdrawals.\\n    Strategy[] public withdrawalStack;\\n\\n    /// @notice Gets the full withdrawal stack.\\n    /// @return An ordered array of strategies representing the withdrawal stack.\\n    /// @dev This is provided because Solidity converts public arrays into index getters,\\n    /// but we need a way to allow external contracts and users to access the whole array.\\n    function getWithdrawalStack() external view returns (Strategy[] memory) {\\n        return withdrawalStack;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful deposit.\\n    /// @param user The address that deposited into the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event Deposit(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after a successful withdrawal.\\n    /// @param user The address that withdrew from the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event Withdraw(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of the underlying token to deposit.\\n    function deposit(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and mint them.\\n        _mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Deposit(msg.sender, underlyingAmount);\\n\\n        // Transfer in underlying tokens from the user.\\n        // This will revert if the user does not have the amount specified.\\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of underlying tokens to withdraw.\\n    function withdraw(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and burn them.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @notice Redeem a specific amount of avTokens for underlying tokens.\\n    /// @param avTokenAmount The amount of avTokens to redeem for underlying tokens.\\n    function redeem(uint256 avTokenAmount) external {\\n        // Determine the equivalent amount of underlying tokens.\\n        uint256 underlyingAmount = avTokenAmount.fmul(exchangeRate(), BASE_UNIT);\\n\\n        // Burn the provided amount of avTokens.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, avTokenAmount);\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\\n    /// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\\n    /// @param recipient The user to transfer the underlying tokens to.\\n    /// @param underlyingAmount The amount of underlying tokens to transfer.\\n    function transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\\n        // Get the Vault's floating balance.\\n        uint256 float = totalFloat();\\n\\n        // If the amount is greater than the float, withdraw from strategies.\\n        if (underlyingAmount > float) {\\n            // Compute the amount needed to reach our target float percentage.\\n            uint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(targetFloatPercent, 1e18);\\n\\n            // Compute the bare minimum amount we need for this withdrawal.\\n            uint256 floatMissingForWithdrawal = underlyingAmount - float;\\n\\n            // Pull enough to cover the withdrawal and reach our target float percentage.\\n            pullFromWithdrawalStack(floatMissingForWithdrawal + floatMissingForTarget);\\n        }\\n\\n        // Transfer the provided amount of underlying tokens.\\n        UNDERLYING.safeTransfer(recipient, underlyingAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        VAULT ACCOUNTING LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Returns a user's Vault balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Vault balance in underlying tokens.\\n    function balanceOfUnderlying(address user) external view returns (uint256) {\\n        return balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens an avToken can be redeemed for.\\n    /// @return The amount of underlying tokens an avToken can be redeemed for.\\n    function exchangeRate() public view returns (uint256) {\\n        // Get the total supply of avTokens.\\n        uint256 avTokenSupply = totalSupply;\\n\\n        // If there are no avTokens in circulation, return an exchange rate of 1:1.\\n        if (avTokenSupply == 0) return BASE_UNIT;\\n\\n        // Calculate the exchange rate by dividing the total holdings by the avToken supply.\\n        return totalHoldings().fdiv(avTokenSupply, BASE_UNIT);\\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds.\\n    /// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\\n    function totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\\n        unchecked {\\n            // Cannot underflow as locked profit can't exceed total strategy holdings.\\n            totalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\\n        }\\n\\n        // Include our floating balance in the total.\\n        totalUnderlyingHeld += totalFloat();\\n    }\\n\\n    /// @notice Calculates the current amount of locked profit.\\n    /// @return The current amount of locked profit.\\n    function lockedProfit() public view returns (uint256) {\\n        // Get the last harvest and harvest delay.\\n        uint256 previousHarvest = lastHarvest;\\n        uint256 harvestInterval = harvestDelay;\\n\\n        unchecked {\\n            // If the harvest delay has passed, there is no locked profit.\\n            // Cannot overflow on human timescales since harvestInterval is capped.\\n            if (block.timestamp >= previousHarvest + harvestInterval) return 0;\\n\\n            // Get the maximum amount we could return.\\n            uint256 maximumLockedProfit = maxLockedProfit;\\n\\n            // Compute how much profit remains locked based on the last harvest and harvest delay.\\n            // It's impossible for the previous harvest to be in the future, so this will never underflow.\\n            return maximumLockedProfit - (maximumLockedProfit * (block.timestamp - previousHarvest)) / harvestInterval;\\n        }\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens that idly sit in the Vault.\\n    /// @return The amount of underlying tokens that sit idly in the Vault.\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful harvest.\\n    /// @param user The authorized user who triggered the harvest.\\n    /// @param strategies The trusted strategies that were harvested.\\n    event Harvest(address indexed user, Strategy[] strategies);\\n\\n    /// @notice Harvest a set of trusted strategies.\\n    /// @param strategies The trusted strategies to harvest.\\n    /// @dev Will always revert if called outside of an active\\n    /// harvest window or before the harvest delay has passed.\\n    function harvest(Strategy[] calldata strategies) external requiresAuth {\\n        // If this is the first harvest after the last window:\\n        if (block.timestamp >= lastHarvest + harvestDelay) {\\n            // Set the harvest window's start timestamp.\\n            // Cannot overflow 64 bits on human timescales.\\n            lastHarvestWindowStart = uint64(block.timestamp);\\n        } else {\\n            // We know this harvest is not the first in the window so we need to ensure it's within it.\\n            require(block.timestamp <= lastHarvestWindowStart + harvestWindow, \\\"BAD_HARVEST_TIME\\\");\\n        }\\n\\n        // Get the Vault's current total strategy holdings.\\n        uint256 oldTotalStrategyHoldings = totalStrategyHoldings;\\n\\n        // Used to store the total profit accrued by the strategies.\\n        uint256 totalProfitAccrued;\\n\\n        // Used to store the new total strategy holdings after harvesting.\\n        uint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\\n\\n        // Will revert if any of the specified strategies are untrusted.\\n        for (uint256 i = 0; i < strategies.length; i++) {\\n            // Get the strategy at the current index.\\n            Strategy strategy = strategies[i];\\n\\n            // If an untrusted strategy could be harvested a malicious user could use\\n            // a fake strategy that over-reports holdings to manipulate the exchange rate.\\n            require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n            // Get the strategy's previous and current balance.\\n            uint256 balanceLastHarvest = getStrategyData[strategy].balance;\\n            uint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\\n\\n            // Update the strategy's stored balance. Cast overflow is unrealistic.\\n            getStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\\n\\n            // Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\\n            // We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\\n            newTotalStrategyHoldings = newTotalStrategyHoldings + balanceThisHarvest - balanceLastHarvest;\\n\\n            unchecked {\\n                // Update the total profit accrued while counting losses as zero profit.\\n                // Cannot overflow as we already increased total holdings without reverting.\\n                totalProfitAccrued += balanceThisHarvest > balanceLastHarvest\\n                    ? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\\n                    : 0; // If the strategy registered a net loss we don't have any new profit.\\n            }\\n        }\\n\\n        // Compute fees as the fee percent multiplied by the profit.\\n        uint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\\n\\n        // If we accrued any fees, mint an equivalent amount of avTokens.\\n        // Authorized users can claim the newly minted avTokens via claimFees.\\n        _mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        // Update max unlocked profit based on any remaining locked profit plus new profit.\\n        maxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\\n\\n        // Set strategy holdings to our new total.\\n        totalStrategyHoldings = newTotalStrategyHoldings;\\n\\n        // Update the last harvest timestamp.\\n        // Cannot overflow on human timescales.\\n        lastHarvest = uint64(block.timestamp);\\n\\n        emit Harvest(msg.sender, strategies);\\n\\n        // Get the next harvest delay.\\n        uint64 newHarvestDelay = nextHarvestDelay;\\n\\n        // If the next harvest delay is not 0:\\n        if (newHarvestDelay != 0) {\\n            // Update the harvest delay.\\n            harvestDelay = newHarvestDelay;\\n\\n            // Reset the next harvest delay.\\n            nextHarvestDelay = 0;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    STRATEGY DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after the Vault deposits into a strategy contract.\\n    /// @param user The authorized user who triggered the deposit.\\n    /// @param strategy The strategy that was deposited into.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event StrategyDeposit(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after the Vault withdraws funds from a strategy contract.\\n    /// @param user The authorized user who triggered the withdrawal.\\n    /// @param strategy The strategy that was withdrawn from.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event StrategyWithdrawal(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of float into a trusted strategy.\\n    /// @param strategy The trusted strategy to deposit into.\\n    /// @param underlyingAmount The amount of underlying tokens in float to deposit.\\n    function depositIntoStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be deposited into.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Increase totalStrategyHoldings to account for the deposit.\\n        totalStrategyHoldings += underlyingAmount;\\n\\n        unchecked {\\n            // Without this the next harvest would count the deposit as profit.\\n            // Cannot overflow as the balance of one strategy can't exceed the sum of all.\\n            getStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\\n        }\\n\\n        emit StrategyDeposit(msg.sender, strategy, underlyingAmount);\\n\\n        // We need to deposit differently if the strategy takes ETH.\\n        if (strategy.isCEther()) {\\n            // Unwrap the right amount of WETH.\\n            WETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\\n\\n            // Deposit into the strategy and assume it will revert on error.\\n            ETHStrategy(address(strategy)).mint{value: underlyingAmount}();\\n        } else {\\n            // Approve underlyingAmount to the strategy so we can deposit.\\n            UNDERLYING.safeApprove(address(strategy), underlyingAmount);\\n\\n            // Deposit into the strategy and revert if it returns an error code.\\n            require(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \\\"MINT_FAILED\\\");\\n        }\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a strategy.\\n    /// @param strategy The strategy to withdraw from.\\n    /// @param underlyingAmount  The amount of underlying tokens to withdraw.\\n    /// @dev Withdrawing from a strategy will not remove it from the withdrawal stack.\\n    function withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be withdrawn from.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Without this the next harvest would count the withdrawal as a loss.\\n        getStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the withdrawal.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        emit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\\n\\n        // Withdraw from the strategy and revert if it returns an error code.\\n        require(strategy.redeemUnderlying(underlyingAmount) == 0, \\\"REDEEM_FAILED\\\");\\n\\n        // Wrap the withdrawn Ether into WETH if necessary.\\n        if (strategy.isCEther()) WETH(payable(address(UNDERLYING))).deposit{value: underlyingAmount}();\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                      STRATEGY TRUST/DISTRUST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is set to trusted.\\n    /// @param user The authorized user who trusted the strategy.\\n    /// @param strategy The strategy that became trusted.\\n    event StrategyTrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Emitted when a strategy is set to untrusted.\\n    /// @param user The authorized user who untrusted the strategy.\\n    /// @param strategy The strategy that became untrusted.\\n    event StrategyDistrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Stores a strategy as trusted, enabling it to be harvested.\\n    /// @param strategy The strategy to make trusted.\\n    function trustStrategy(Strategy strategy) external requiresAuth {\\n        // Ensure the strategy accepts the correct underlying token.\\n        // If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\\n        require(\\n            strategy.isCEther() ? underlyingIsWETH : ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\\n            \\\"WRONG_UNDERLYING\\\"\\n        );\\n\\n        // Store the strategy as trusted.\\n        getStrategyData[strategy].trusted = true;\\n\\n        emit StrategyTrusted(msg.sender, strategy);\\n    }\\n\\n    /// @notice Stores a strategy as untrusted, disabling it from being harvested.\\n    /// @param strategy The strategy to make untrusted.\\n    function distrustStrategy(Strategy strategy) external requiresAuth {\\n        // Store the strategy as untrusted.\\n        getStrategyData[strategy].trusted = false;\\n\\n        emit StrategyDistrusted(msg.sender, strategy);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         WITHDRAWAL STACK LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is pushed to the withdrawal stack.\\n    /// @param user The authorized user who triggered the push.\\n    /// @param pushedStrategy The strategy pushed to the withdrawal stack.\\n    event WithdrawalStackPushed(address indexed user, Strategy indexed pushedStrategy);\\n\\n    /// @notice Emitted when a strategy is popped from the withdrawal stack.\\n    /// @param user The authorized user who triggered the pop.\\n    /// @param poppedStrategy The strategy popped from the withdrawal stack.\\n    event WithdrawalStackPopped(address indexed user, Strategy indexed poppedStrategy);\\n\\n    /// @notice Emitted when the withdrawal stack is updated.\\n    /// @param user The authorized user who triggered the set.\\n    /// @param replacedWithdrawalStack The new withdrawal stack.\\n    event WithdrawalStackSet(address indexed user, Strategy[] replacedWithdrawalStack);\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack that was replaced.\\n    /// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\\n    event WithdrawalStackIndexReplaced(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed replacementStrategy\\n    );\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced with the tip.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack replaced by the tip.\\n    /// @param previousTipStrategy The previous tip of the stack that replaced the strategy.\\n    event WithdrawalStackIndexReplacedWithTip(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed previousTipStrategy\\n    );\\n\\n    /// @notice Emitted when the strategies at two indexes are swapped.\\n    /// @param user The authorized user who triggered the swap.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    /// @param newStrategy1 The strategy (previously at index2) that replaced index1.\\n    /// @param newStrategy2 The strategy (previously at index1) that replaced index2.\\n    event WithdrawalStackIndexesSwapped(\\n        address indexed user,\\n        uint256 index1,\\n        uint256 index2,\\n        Strategy indexed newStrategy1,\\n        Strategy indexed newStrategy2\\n    );\\n\\n    /// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal stack.\\n    /// @param underlyingAmount The amount of underlying tokens to pull into float.\\n    /// @dev Automatically removes depleted strategies from the withdrawal stack.\\n    function pullFromWithdrawalStack(uint256 underlyingAmount) internal {\\n        // We will update this variable as we pull from strategies.\\n        uint256 amountLeftToPull = underlyingAmount;\\n\\n        // We'll start at the tip of the stack and traverse backwards.\\n        uint256 currentIndex = withdrawalStack.length - 1;\\n\\n        // Iterate in reverse so we pull from the stack in a \\\"last in, first out\\\" manner.\\n        // Will revert due to underflow if we empty the stack before pulling the desired amount.\\n        for (; ; currentIndex--) {\\n            // Get the strategy at the current stack index.\\n            Strategy strategy = withdrawalStack[currentIndex];\\n\\n            // Get the balance of the strategy before we withdraw from it.\\n            uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n            // If the strategy is currently untrusted or was already depleted:\\n            if (!getStrategyData[strategy].trusted || strategyBalance == 0) {\\n                // Remove it from the stack.\\n                withdrawalStack.pop();\\n\\n                emit WithdrawalStackPopped(msg.sender, strategy);\\n\\n                // Move onto the next strategy.\\n                continue;\\n            }\\n\\n            // We want to pull as much as we can from the strategy, but no more than we need.\\n            uint256 amountToPull = strategyBalance > amountLeftToPull ? amountLeftToPull : strategyBalance;\\n\\n            unchecked {\\n                // Compute the balance of the strategy that will remain after we withdraw.\\n                // Cannot underflow as we cap the amount to pull at the strategy's balance.\\n                uint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\\n\\n                // Without this the next harvest would count the withdrawal as a loss.\\n                getStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\\n\\n                // Adjust our goal based on how much we can pull from the strategy.\\n                // Cannot underflow as we cap the amount to pull at the amount left to pull.\\n                amountLeftToPull -= amountToPull;\\n\\n                emit StrategyWithdrawal(msg.sender, strategy, amountToPull);\\n\\n                // Withdraw from the strategy and revert if returns an error code.\\n                require(strategy.redeemUnderlying(amountToPull) == 0, \\\"REDEEM_FAILED\\\");\\n\\n                // If we fully depleted the strategy:\\n                if (strategyBalanceAfterWithdrawal == 0) {\\n                    // Remove it from the stack.\\n                    withdrawalStack.pop();\\n\\n                    emit WithdrawalStackPopped(msg.sender, strategy);\\n                }\\n            }\\n\\n            // If we've pulled all we need, exit the loop.\\n            if (amountLeftToPull == 0) break;\\n        }\\n\\n        unchecked {\\n            // Account for the withdrawals done in the loop above.\\n            // Cannot underflow as the balances of some strategies cannot exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        // Cache the Vault's balance of ETH.\\n        uint256 ethBalance = address(this).balance;\\n\\n        // If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\\n        if (ethBalance != 0 && underlyingIsWETH) WETH(payable(address(UNDERLYING))).deposit{value: ethBalance}();\\n    }\\n\\n    /// @notice Pushes a single strategy to front of the withdrawal stack.\\n    /// @param strategy The strategy to be inserted at the front of the withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function pushToWithdrawalStack(Strategy strategy) external requiresAuth {\\n        // Ensure pushing the strategy will not cause the stack exceed its limit.\\n        require(withdrawalStack.length < MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_FULL\\\");\\n\\n        // Push the strategy to the front of the stack.\\n        withdrawalStack.push(strategy);\\n\\n        emit WithdrawalStackPushed(msg.sender, strategy);\\n    }\\n\\n    /// @notice Removes the strategy at the tip of the withdrawal stack.\\n    /// @dev Be careful, another authorized user could push a different strategy\\n    /// than expected to the stack while a popFromWithdrawalStack transaction is pending.\\n    function popFromWithdrawalStack() external requiresAuth {\\n        // Get the (soon to be) popped strategy.\\n        Strategy poppedStrategy = withdrawalStack[withdrawalStack.length - 1];\\n\\n        // Pop the first strategy in the stack.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackPopped(msg.sender, poppedStrategy);\\n    }\\n\\n    /// @notice Sets a new withdrawal stack.\\n    /// @param newStack The new withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function setWithdrawalStack(Strategy[] calldata newStack) external requiresAuth {\\n        // Ensure the new stack is not larger than the maximum stack size.\\n        require(newStack.length <= MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_TOO_BIG\\\");\\n\\n        // Replace the withdrawal stack.\\n        withdrawalStack = newStack;\\n\\n        emit WithdrawalStackSet(msg.sender, newStack);\\n    }\\n\\n    /// @notice Replaces an index in the withdrawal stack with another strategy.\\n    /// @param index The index in the stack to replace.\\n    /// @param replacementStrategy The strategy to override the index with.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function replaceWithdrawalStackIndex(uint256 index, Strategy replacementStrategy) external requiresAuth {\\n        // Get the (soon to be) replaced strategy.\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Update the index with the replacement strategy.\\n        withdrawalStack[index] = replacementStrategy;\\n\\n        emit WithdrawalStackIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\\n    }\\n\\n    /// @notice Moves the strategy at the tip of the stack to the specified index and pop the tip off the stack.\\n    /// @param index The index of the strategy in the withdrawal stack to replace with the tip.\\n    function replaceWithdrawalStackIndexWithTip(uint256 index) external requiresAuth {\\n        // Get the (soon to be) previous tip and strategy we will replace at the index.\\n        Strategy previousTipStrategy = withdrawalStack[withdrawalStack.length - 1];\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Replace the index specified with the tip of the stack.\\n        withdrawalStack[index] = previousTipStrategy;\\n\\n        // Remove the now duplicated tip from the array.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackIndexReplacedWithTip(msg.sender, index, replacedStrategy, previousTipStrategy);\\n    }\\n\\n    /// @notice Swaps two indexes in the withdrawal stack.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    function swapWithdrawalStackIndexes(uint256 index1, uint256 index2) external requiresAuth {\\n        // Get the (soon to be) new strategies at each index.\\n        Strategy newStrategy2 = withdrawalStack[index1];\\n        Strategy newStrategy1 = withdrawalStack[index2];\\n\\n        // Swap the strategies at both indexes.\\n        withdrawalStack[index1] = newStrategy1;\\n        withdrawalStack[index2] = newStrategy2;\\n\\n        emit WithdrawalStackIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         SEIZE STRATEGY LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a strategy is seized.\\n    /// @param user The authorized user who triggered the seize.\\n    /// @param strategy The strategy that was seized.\\n    event StrategySeized(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Seizes a strategy.\\n    /// @param strategy The strategy to seize.\\n    /// @dev Intended for use in emergencies or other extraneous situations where the\\n    /// strategy requires interaction outside of the Vault's standard operating procedures.\\n    function seizeStrategy(Strategy strategy) external requiresAuth {\\n        // Get the strategy's last reported balance of underlying tokens.\\n        uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n        // If the strategy's balance exceeds the Vault's current\\n        // holdings, instantly unlock any remaining locked profit.\\n        if (strategyBalance > totalHoldings()) maxLockedProfit = 0;\\n\\n        // Set the strategy's balance to 0.\\n        getStrategyData[strategy].balance = 0;\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the seize.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= strategyBalance;\\n        }\\n\\n        emit StrategySeized(msg.sender, strategy);\\n\\n        // Transfer all of the strategy's tokens to the caller.\\n        ERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             FEE CLAIM LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after fees are claimed.\\n    /// @param user The authorized user who claimed the fees.\\n    /// @param avTokenAmount The amount of avTokens that were claimed.\\n    event FeesClaimed(address indexed user, uint256 avTokenAmount);\\n\\n    /// @notice Claims fees accrued from harvests.\\n    /// @param avTokenAmount The amount of avTokens to claim.\\n    /// @dev Accrued fees are measured as avTokens held by the Vault.\\n    function claimFees(uint256 avTokenAmount) external requiresAuth {\\n        emit FeesClaimed(msg.sender, avTokenAmount);\\n\\n        // Transfer the provided amount of avTokens to the caller.\\n        ERC20(this).safeTransfer(msg.sender, avTokenAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    INITIALIZATION AND DESTRUCTION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the Vault is initialized.\\n    /// @param user The authorized user who triggered the initialization.\\n    event Initialized(address indexed user);\\n\\n    /// @notice Whether the Vault has been initialized yet.\\n    /// @dev Can go from false to true, never from true to false.\\n    bool public isInitialized;\\n\\n    /// @notice Initializes the Vault, enabling it to receive deposits.\\n    /// @dev All critical parameters must already be set before calling.\\n    function initialize() external requiresAuth {\\n        // Ensure the Vault has not already been initialized.\\n        require(!isInitialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n        // Mark the Vault as initialized.\\n        isInitialized = true;\\n\\n        // Open for deposits.\\n        totalSupply = 0;\\n\\n        emit Initialized(msg.sender);\\n    }\\n\\n    /// @notice Self destructs a Vault, enabling it to be redeployed.\\n    /// @dev Caller will receive any ETH held as float in the Vault.\\n    function destroy() external requiresAuth {\\n        selfdestruct(payable(msg.sender));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          RECIEVE ETHER LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Required for the Vault to receive unwrapped ETH.\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x0b08c071927137a2a94db57508bdc86a33e0fd7bf782e277de50fe0a99ffc6d2\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/interfaces/Strategy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\n/// @dev Designed for out of the box compatibility with Fuse cTokens.\\n/// @dev Like cTokens, strategies must be transferrable ERC20s.\\nabstract contract Strategy is ERC20 {\\n    /// @notice Returns whether the strategy accepts ETH or an ERC20.\\n    /// @return True if the strategy accepts ETH, false otherwise.\\n    /// @dev Only present in Fuse cTokens, not Compound cTokens.\\n    function isCEther() external view virtual returns (bool);\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the strategy.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external virtual returns (uint256);\\n\\n    /// @notice Returns a user's strategy balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's strategy balance in underlying tokens.\\n    /// @dev May mutate the state of the strategy by accruing interest.\\n    function balanceOfUnderlying(address user) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\\n/// @dev Designed for out of the box compatibility with Fuse cERC20s.\\nabstract contract ERC20Strategy is Strategy {\\n    /// @notice Returns the underlying ERC20 token the strategy accepts.\\n    /// @return The underlying ERC20 token the strategy accepts.\\n    function underlying() external view virtual returns (ERC20);\\n\\n    /// @notice Deposit a specific amount of underlying tokens into the strategy.\\n    /// @param amount The amount of underlying tokens to deposit.\\n    /// @return An error code, or 0 if the deposit was successful.\\n    function mint(uint256 amount) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ETH.\\n/// @dev Designed for out of the box compatibility with Fuse cEther.\\nabstract contract ETHStrategy is Strategy {\\n    /// @notice Deposit a specific amount of ETH into the strategy.\\n    /// @dev The amount of ETH is specified via msg.value. Reverts on error.\\n    function mint() external payable virtual;\\n}\\n\",\"keccak256\":\"0x74641e7bf81f3a8ebbe797d58fd5e7db325ba9999a4e905a2e61f68614dfb50d\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/strategies/StrategyBaseV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../FixedPointMathLib.sol\\\";\\nimport {ERC20Strategy} from \\\"../interfaces/Strategy.sol\\\";\\nimport {Bribe} from \\\"../Bribe.sol\\\";\\nimport {Gauge} from \\\"../Gauge.sol\\\";\\n\\nabstract contract StrategyBaseV1 is Auth, ERC20, ERC20Strategy {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    Bribe public BRIBE;\\n    Gauge public GAUGE;\\n\\n    uint public bribeRate = 0;\\n    uint public bribeRateBase = 100;\\n\\n    uint public gaugeRate = 0;\\n    uint public gaugeRateBase = 100;\\n\\n    event DevWithdraw(address token, address to);\\n    event BribePaid(uint payment);\\n\\n    function setGaugeBribe(Gauge newGauge_, Bribe newBribe_) external requiresAuth {\\n        GAUGE = newGauge_;\\n        BRIBE = newBribe_;\\n    }\\n\\n    function setRates(uint newGaugeRate_, uint newBribeRate_) external requiresAuth {\\n        gaugeRate = newGaugeRate_;\\n        bribeRate = newBribeRate_;\\n    }\\n\\n    function setBaseRates(uint newGaugeRateBase_, uint newBribeRateBase_) external requiresAuth {\\n        gaugeRateBase = newGaugeRateBase_;\\n        bribeRateBase = newBribeRateBase_;\\n    }\\n\\n\\n    function _payBribe(ERC20 bribeToken, uint profit) internal returns (uint bAmount){\\n        if (profit == uint(0) || bribeRateBase == uint(0) || bribeRate == uint(0)) return uint(0);\\n        bAmount = profit * bribeRate / bribeRateBase;\\n        bribeToken.safeApprove(address(BRIBE), bAmount);\\n        BRIBE.notifyRewardAmount(address(bribeToken), bAmount);\\n    }\\n\\n    function _payGauge(ERC20 rewardToken, uint profit) internal returns (uint rAmount){\\n        if (profit == uint(0) || gaugeRateBase == uint(0) || gaugeRate == uint(0)) return uint(0);\\n        rAmount = profit * gaugeRate / gaugeRateBase;\\n        rewardToken.safeApprove(address(GAUGE), rAmount);\\n        GAUGE.notifyRewardAmount(address(rewardToken), rAmount);\\n    }\\n\\n    function __emergencyExit() virtual external requiresAuth {}\\n\\n    //requires governance to do this, in the event assets are stuck in the contract\\n    function emergencyWithdrawalToken(ERC20 token) virtual external requiresAuth {\\n        //send the tokens to the Vault's Owner so they can be given back to the depositors as\\n        //something has gone wrong with the strategy\\n        token.safeTransfer(owner, token.balanceOf(address(this)));\\n        emit DevWithdraw(address(token), owner);\\n    }\\n\\n}\\n\",\"keccak256\":\"0x142fd3dd7ece0241eba99e607338cf15e4d1b40bbb2e2aaebb61e59d71c30533\",\"license\":\"MIT\"},\"srcBuild/strategies/USDV3CRVRewardStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../FixedPointMathLib.sol\\\";\\nimport {ERC20Strategy} from \\\"../interfaces/Strategy.sol\\\";\\nimport {Vault} from \\\"../Vault.sol\\\";\\n\\ninterface IRewards {\\n    function rewardsToken() external view returns (address);\\n    function exit() external;\\n    function getReward() external;\\n    function stake(uint256 amount) external;\\n    function withdraw(uint256 amount) external;\\n    function earned(address director) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address director) external view returns (uint256);\\n}\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n}\\n\\nimport {Gauge, Bribe, StrategyBaseV1} from \\\"./StrategyBaseV1.sol\\\";\\n\\ncontract USDV3CRVRewardStrategy is StrategyBaseV1 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    IRewards public immutable REWARDS;\\n\\n    constructor(\\n        ERC20 UNDERLYING_,\\n        address GOVERNANCE_,\\n        Authority AUTHORITY_,\\n        IRewards REWARDS_,\\n        Gauge GAUGE_,\\n        Bribe BRIBE_\\n    ) Auth(GOVERNANCE_, AUTHORITY_)\\n    ERC20(\\\"USDV3CRVRewardStrategy\\\", \\\"aUSDV3CRVRewardStrategy\\\", 18) {\\n        UNDERLYING = UNDERLYING_; //vader\\n        BASE_UNIT = 10e18;\\n        REWARDS = REWARDS_;\\n        BRIBE = BRIBE_;\\n        GAUGE = GAUGE_;\\n        UNDERLYING.safeApprove(address(REWARDS_), type(uint256).max);\\n        bribeRate = 10; //10% to bribe\\n        gaugeRate = 10; //10% to gauge\\n    }\\n\\n    function isCEther() external pure override returns (bool) {\\n        return false;\\n    }\\n\\n    function underlying() external view override returns (ERC20) {\\n        return UNDERLYING;\\n    }\\n\\n    function mint(uint256 amount) external requiresAuth override returns (uint256) {\\n        _mint(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), amount);\\n        _stakeUnderlying(UNDERLYING.balanceOf(address(this)));\\n        return 0;\\n    }\\n\\n    function redeemUnderlying(uint256 amount) external override returns (uint256) {\\n        _burn(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\\n\\n        if (UNDERLYING.balanceOf(address(this)) < amount) {\\n            uint leaveAmount = amount - UNDERLYING.balanceOf(address(this));\\n            _unstakeUnderlying(leaveAmount);\\n        }\\n        UNDERLYING.safeTransfer(msg.sender, amount);\\n\\n        return 0;\\n    }\\n\\n    function balanceOfUnderlying(address user) external view override returns (uint256) {\\n        return balanceOf[user].fmul(_exchangeRate(), BASE_UNIT);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                            INTERNAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    ERC20 internal immutable UNDERLYING;\\n\\n    uint256 internal immutable BASE_UNIT;\\n\\n    function _stakeUnderlying(uint amount) internal {\\n        REWARDS.stake(amount);\\n    }\\n\\n    function _unstakeUnderlying(uint amount) internal {\\n        REWARDS.withdraw(amount);\\n    }\\n\\n    function _computeStakedUnderlying() internal view returns (uint256) {\\n        return REWARDS.balanceOf(address(this));\\n    }\\n\\n    function _exchangeRate() internal view returns (uint256) {\\n        uint256 cTokenSupply = totalSupply;\\n\\n        if (cTokenSupply == 0) return BASE_UNIT;\\n        uint underlyingBalance;\\n        uint stakedBalance = _computeStakedUnderlying();\\n    unchecked {\\n        underlyingBalance = UNDERLYING.balanceOf(address(this)) + stakedBalance;\\n    }\\n        return underlyingBalance.fdiv(cTokenSupply, BASE_UNIT);\\n    }\\n\\n    function hit() external {\\n        //get rewards\\n        REWARDS.getReward();\\n\\n        ERC20 rewardToken = ERC20(REWARDS.rewardsToken());\\n\\n        uint harvest = rewardToken.balanceOf(address(this));\\n        uint bribePayment = _payBribe(rewardToken, harvest);\\n        uint gaugePayment = _payGauge(rewardToken, harvest);\\n        //calc treasuryDeposit\\n        uint treasuryDeposit = harvest - bribePayment - gaugePayment;\\n        //transfer to owner(treasury)\\n        rewardToken.transfer(owner, treasuryDeposit);\\n    }\\n\\n    function __emergencyExit() external override requiresAuth {\\n        REWARDS.getReward();\\n        _unstakeUnderlying(_computeStakedUnderlying());\\n    }\\n}\\n\",\"keccak256\":\"0x5a5465ea9452c5620657e03f519c230770a102ef6f7ce3e6ae72ef6ab0ef6574\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101406040526000600a556064600b556000600c556064600d553480156200002657600080fd5b50604051620025a5380380620025a583398101604081905262000049916200043b565b604080518082018252601681527f555344563343525652657761726453747261746567790000000000000000000060208083019190915282518084018452601781527f615553445633435256526577617264537472617465677900000000000000000091810191909152600080546001600160a01b03199081166001600160a01b038b8116918217845560018054909316908b16179091559351929391926012928a928a9233917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d7691a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350508251620001609060029060208601906200037c565b508151620001769060039060208501906200037c565b5060ff81166080524660a0526200018c6200020e565b60c0525050506001600160a01b03868116610100819052678ac7230489e800006101205284821660e052600880546001600160a01b0319908116858516179091556009805490911692851692909217909155620001f99084600019620002aa602090811b6200133517901c565b5050600a808055600c5550620005b092505050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60026040516200024291906200050c565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b600060405163095ea7b360e01b81526001600160a01b03841660048201528260248201526000806044836000895af19150620002e890508162000330565b6200032a5760405162461bcd60e51b815260206004820152600e60248201526d1054141493d59157d1905253115160921b604482015260640160405180910390fd5b50505050565b60003d826200034357806000803e806000fd5b80602081146200035e57801562000370576000925062000375565b816000803e6000511515925062000375565b600192505b5050919050565b8280546200038a90620004cf565b90600052602060002090601f016020900481019282620003ae5760008555620003f9565b82601f10620003c957805160ff1916838001178555620003f9565b82800160010185558215620003f9579182015b82811115620003f9578251825591602001919060010190620003dc565b50620004079291506200040b565b5090565b5b808211156200040757600081556001016200040c565b6001600160a01b03811681146200043857600080fd5b50565b60008060008060008060c087890312156200045557600080fd5b8651620004628162000422565b6020880151909650620004758162000422565b6040880151909550620004888162000422565b60608801519094506200049b8162000422565b6080880151909350620004ae8162000422565b60a0880151909250620004c18162000422565b809150509295509295509295565b600181811c90821680620004e457607f821691505b602082108114156200050657634e487b7160e01b600052602260045260246000fd5b50919050565b600080835481600182811c9150808316806200052957607f831692505b60208084108214156200054a57634e487b7160e01b86526022600452602486fd5b8180156200056157600181146200057357620005a2565b60ff19861689528489019650620005a2565b60008a81526020902060005b868110156200059a5781548b8201529085019083016200057f565b505084890196505b509498975050505050505050565b60805160a05160c05160e0516101005161012051611f3c6200066960003960008181610bb501528181610cd8015281816116df01526117a601526000818161035d01528181610d1801528181610da901528181610e4001528181610f8801528181610fc9015261173101526000818161049b015281816108db0152818161095001528181610ea30152818161188f0152818161190f0152611a7701526000610b6a01526000610b35015260006102f00152611f3c6000f3fe608060405234801561001057600080fd5b50600436106102115760003560e01c80637a9e5e4b11610125578063ac6af280116100ad578063c0034e0c1161007c578063c0034e0c14610496578063d505accf146104bd578063dc9e9d0c146104d0578063dd62ed3e146104e3578063fb4db8f81461050e57600080fd5b8063ac6af28014610460578063ac784ddc14610473578063b4c4f89d1461047a578063bf7e214f1461048357600080fd5b80638da5cb5b116100f45780638da5cb5b14610417578063907434f61461042a57806395d89b4114610432578063a0712d681461043a578063a9059cbb1461044d57600080fd5b80637a9e5e4b146103c85780637ecebe00146103db578063852a12e3146103fb57806385fe43231461040e57600080fd5b806330adf81f116101a85780633af9e669116101775780633af9e6691461033f5780636b306520146103525780636f307dc31461035b57806370a08231146103955780637651b1e6146103b557600080fd5b806330adf81f146102c4578063313ce567146102eb57806334e0d14d146103245780633644e5151461033757600080fd5b806318160ddd116101e457806318160ddd1461027f5780631937daf31461029657806323b872dd146102a95780632ae3594a146102bc57600080fd5b8063019ae0751461021657806306fdde031461022b578063095ea7b31461024957806313af40351461026c575b600080fd5b610229610224366004611b0d565b610517565b005b610233610621565b6040516102409190611b31565b60405180910390f35b61025c610257366004611b86565b6106af565b6040519015158152602001610240565b61022961027a366004611b0d565b61071c565b61028860045481565b604051908152602001610240565b6102296102a4366004611bb2565b610799565b61025c6102b7366004611beb565b6107f9565b6102296108d9565b6102887f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c981565b6103127f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610240565b610229610332366004611c2c565b610af4565b610288610b31565b61028861034d366004611b0d565b610b8c565b610288600c5481565b7f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b039091168152602001610240565b6102886103a3366004611b0d565b60056020526000908152604090205481565b60095461037d906001600160a01b031681565b6102296103d6366004611b0d565b610bd9565b6102886103e9366004611b0d565b60076020526000908152604090205481565b610288610409366004611c4e565b610cc3565b610288600d5481565b60005461037d906001600160a01b031681565b610229610e6f565b610233610f26565b610288610448366004611c4e565b610f33565b61025c61045b366004611b86565b611041565b61022961046e366004611c2c565b6110a7565b600061025c565b610288600a5481565b60015461037d906001600160a01b031681565b61037d7f000000000000000000000000000000000000000000000000000000000000000081565b6102296104cb366004611c67565b6110e4565b60085461037d906001600160a01b031681565b6102886104f1366004611bb2565b600660209081526000928352604080842090915290825290205481565b610288600b5481565b61052d336000356001600160e01b0319166113b3565b6105525760405162461bcd60e51b815260040161054990611cde565b60405180910390fd5b6000546040516370a0823160e01b81523060048201526105d7916001600160a01b0390811691908416906370a0823190602401602060405180830381865afa1580156105a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105c69190611d04565b6001600160a01b038416919061145d565b600054604080516001600160a01b03808516825290921660208301527fdca40dd6e1f9a4a0c6d9da138be5e2ee4c39d27af85b9876ad34c8d5d8747954910160405180910390a150565b6002805461062e90611d1d565b80601f016020809104026020016040519081016040528092919081815260200182805461065a90611d1d565b80156106a75780601f1061067c576101008083540402835291602001916106a7565b820191906000526020600020905b81548152906001019060200180831161068a57829003601f168201915b505050505081565b3360008181526006602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259061070a9086815260200190565b60405180910390a35060015b92915050565b610732336000356001600160e01b0319166113b3565b61074e5760405162461bcd60e51b815260040161054990611cde565b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6107af336000356001600160e01b0319166113b3565b6107cb5760405162461bcd60e51b815260040161054990611cde565b600980546001600160a01b039384166001600160a01b03199182161790915560088054929093169116179055565b6001600160a01b03831660009081526006602090815260408083203384529091528120546000198114610855576108308382611d6e565b6001600160a01b03861660009081526006602090815260408083203384529091529020555b6001600160a01b0385166000908152600560205260408120805485929061087d908490611d6e565b90915550506001600160a01b0380851660008181526005602052604090819020805487019055519091871690600080516020611ee7833981519152906108c69087815260200190565b60405180910390a3506001949350505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633d18b9126040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561093457600080fd5b505af1158015610948573d6000803e3d6000fd5b5050505060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d1af0c7d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d09190611d85565b6040516370a0823160e01b81523060048201529091506000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610a1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a3e9190611d04565b90506000610a4c83836114d6565b90506000610a5a84846115a1565b9050600081610a698486611d6e565b610a739190611d6e565b60005460405163a9059cbb60e01b81526001600160a01b0391821660048201526024810183905291925086169063a9059cbb906044016020604051808303816000875af1158015610ac8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aec9190611da2565b505050505050565b610b0a336000356001600160e01b0319166113b3565b610b265760405162461bcd60e51b815260040161054990611cde565b600d91909155600b55565b60007f00000000000000000000000000000000000000000000000000000000000000004614610b6757610b62611638565b905090565b507f000000000000000000000000000000000000000000000000000000000000000090565b6000610716610b996116d2565b6001600160a01b038416600090815260056020526040902054907f00000000000000000000000000000000000000000000000000000000000000006117d2565b6000546001600160a01b0316331480610c6e575060015460405163b700961360e01b81526001600160a01b039091169063b700961390610c2d90339030906001600160e01b03196000351690600401611dc4565b602060405180830381865afa158015610c4a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c6e9190611da2565b610c7757600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6000610d0133610cfc610cd46116d2565b85907f00000000000000000000000000000000000000000000000000000000000000006117ed565b61180f565b6040516370a0823160e01b815230600482015282907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015610d67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d8b9190611d04565b1015610e33576040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015610df8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e1c9190611d04565b610e269084611d6e565b9050610e3181611879565b505b610e676001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016338461145d565b506000919050565b610e85336000356001600160e01b0319166113b3565b610ea15760405162461bcd60e51b815260040161054990611cde565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633d18b9126040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610efc57600080fd5b505af1158015610f10573d6000803e3d6000fd5b50505050610f24610f1f6118f7565b611879565b565b6003805461062e90611d1d565b6000610f4b336000356001600160e01b0319166113b3565b610f675760405162461bcd60e51b815260040161054990611cde565b610f7b33610f76610cd46116d2565b611982565b610fb06001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163330856119d4565b6040516370a0823160e01b8152306004820152610e67907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015611018573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061103c9190611d04565b611a61565b33600090815260056020526040812080548391908390611062908490611d6e565b90915550506001600160a01b03831660008181526005602052604090819020805485019055513390600080516020611ee78339815191529061070a9086815260200190565b6110bd336000356001600160e01b0319166113b3565b6110d95760405162461bcd60e51b815260040161054990611cde565b600c91909155600a55565b428410156111345760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f455850495245440000000000000000006044820152606401610549565b600061113e610b31565b6001600160a01b0389811660008181526007602090815260409182902080546001810190915582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98184015280840194909452938c166060840152608083018b905260a083019390935260c08083018a90528151808403909101815260e08301909152805192019190912061190160f01b6101008301526101028201929092526101228101919091526101420160408051601f198184030181528282528051602091820120600080855291840180845281905260ff88169284019290925260608301869052608083018590529092509060019060a0016020604051602081039080840390855afa158015611257573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381161580159061128d5750886001600160a01b0316816001600160a01b0316145b6112ca5760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610549565b6001600160a01b0390811660009081526006602090815260408083208b8516808552908352928190208a905551898152919350918a16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a350505050505050565b600060405163095ea7b360e01b81526001600160a01b03841660048201528260248201526000806044836000895af191505061137081611aae565b6113ad5760405162461bcd60e51b815260206004820152600e60248201526d1054141493d59157d1905253115160921b6044820152606401610549565b50505050565b6001546000906001600160a01b0316801580159061143d575060405163b700961360e01b81526001600160a01b0382169063b7009613906113fc90879030908890600401611dc4565b602060405180830381865afa158015611419573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061143d9190611da2565b8061145557506000546001600160a01b038581169116145b949350505050565b600060405163a9059cbb60e01b81526001600160a01b03841660048201528260248201526000806044836000895af191505061149881611aae565b6113ad5760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610549565b60008115806114e55750600b54155b806114f05750600a54155b156114fd57506000610716565b600b54600a5461150d9084611df1565b6115179190611e10565b600854909150611534906001600160a01b03858116911683611335565b60085460405163b66503cf60e01b81526001600160a01b038581166004830152602482018490529091169063b66503cf906044015b600060405180830381600087803b15801561158357600080fd5b505af1158015611597573d6000803e3d6000fd5b5050505092915050565b60008115806115b05750600d54155b806115bb5750600c54155b156115c857506000610716565b600d54600c546115d89084611df1565b6115e29190611e10565b6009549091506115ff906001600160a01b03858116911683611335565b60095460405163b66503cf60e01b81526001600160a01b038581166004830152602482018490529091169063b66503cf90604401611569565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f600260405161166a9190611e32565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b60045460009080611704577f000000000000000000000000000000000000000000000000000000000000000091505090565b60008061170f6118f7565b6040516370a0823160e01b815230600482015290915081906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401602060405180830381865afa158015611778573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061179c9190611d04565b0191506117ca82847f00000000000000000000000000000000000000000000000000000000000000006117ed565b935050505090565b82820283158482048414176117e657600080fd5b0492915050565b82810282151584158583048414171661180557600080fd5b9190910492915050565b6001600160a01b03821660009081526005602052604081208054839290611837908490611d6e565b90915550506004805482900390556040518181526000906001600160a01b03841690600080516020611ee7833981519152906020015b60405180910390a35050565b604051632e1a7d4d60e01b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690632e1a7d4d906024015b600060405180830381600087803b1580156118dc57600080fd5b505af11580156118f0573d6000803e3d6000fd5b5050505050565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561195e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b629190611d04565b80600460008282546119949190611ece565b90915550506001600160a01b038216600081815260056020908152604080832080548601905551848152600080516020611ee7833981519152910161186d565b60006040516323b872dd60e01b81526001600160a01b03851660048201526001600160a01b038416602482015282604482015260008060648360008a5af1915050611a1e81611aae565b6118f05760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610549565b60405163534a7e1d60e11b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063a694fc3a906024016118c2565b60003d82611ac057806000803e806000fd5b8060208114611ad8578015611ae95760009250611aee565b816000803e60005115159250611aee565b600192505b5050919050565b6001600160a01b0381168114611b0a57600080fd5b50565b600060208284031215611b1f57600080fd5b8135611b2a81611af5565b9392505050565b600060208083528351808285015260005b81811015611b5e57858101830151858201604001528201611b42565b81811115611b70576000604083870101525b50601f01601f1916929092016040019392505050565b60008060408385031215611b9957600080fd5b8235611ba481611af5565b946020939093013593505050565b60008060408385031215611bc557600080fd5b8235611bd081611af5565b91506020830135611be081611af5565b809150509250929050565b600080600060608486031215611c0057600080fd5b8335611c0b81611af5565b92506020840135611c1b81611af5565b929592945050506040919091013590565b60008060408385031215611c3f57600080fd5b50508035926020909101359150565b600060208284031215611c6057600080fd5b5035919050565b600080600080600080600060e0888a031215611c8257600080fd5b8735611c8d81611af5565b96506020880135611c9d81611af5565b95506040880135945060608801359350608088013560ff81168114611cc157600080fd5b9699959850939692959460a0840135945060c09093013592915050565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b600060208284031215611d1657600080fd5b5051919050565b600181811c90821680611d3157607f821691505b60208210811415611d5257634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b600082821015611d8057611d80611d58565b500390565b600060208284031215611d9757600080fd5b8151611b2a81611af5565b600060208284031215611db457600080fd5b81518015158114611b2a57600080fd5b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b6000816000190483118215151615611e0b57611e0b611d58565b500290565b600082611e2d57634e487b7160e01b600052601260045260246000fd5b500490565b600080835481600182811c915080831680611e4e57607f831692505b6020808410821415611e6e57634e487b7160e01b86526022600452602486fd5b818015611e825760018114611e9357611ec0565b60ff19861689528489019650611ec0565b60008a81526020902060005b86811015611eb85781548b820152908501908301611e9f565b505084890196505b509498975050505050505050565b60008219821115611ee157611ee1611d58565b50019056feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220b7532a753b94db7be081f974b1bd3acb3043802052b89fe6cda520947412654d64736f6c634300080b0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102115760003560e01c80637a9e5e4b11610125578063ac6af280116100ad578063c0034e0c1161007c578063c0034e0c14610496578063d505accf146104bd578063dc9e9d0c146104d0578063dd62ed3e146104e3578063fb4db8f81461050e57600080fd5b8063ac6af28014610460578063ac784ddc14610473578063b4c4f89d1461047a578063bf7e214f1461048357600080fd5b80638da5cb5b116100f45780638da5cb5b14610417578063907434f61461042a57806395d89b4114610432578063a0712d681461043a578063a9059cbb1461044d57600080fd5b80637a9e5e4b146103c85780637ecebe00146103db578063852a12e3146103fb57806385fe43231461040e57600080fd5b806330adf81f116101a85780633af9e669116101775780633af9e6691461033f5780636b306520146103525780636f307dc31461035b57806370a08231146103955780637651b1e6146103b557600080fd5b806330adf81f146102c4578063313ce567146102eb57806334e0d14d146103245780633644e5151461033757600080fd5b806318160ddd116101e457806318160ddd1461027f5780631937daf31461029657806323b872dd146102a95780632ae3594a146102bc57600080fd5b8063019ae0751461021657806306fdde031461022b578063095ea7b31461024957806313af40351461026c575b600080fd5b610229610224366004611b0d565b610517565b005b610233610621565b6040516102409190611b31565b60405180910390f35b61025c610257366004611b86565b6106af565b6040519015158152602001610240565b61022961027a366004611b0d565b61071c565b61028860045481565b604051908152602001610240565b6102296102a4366004611bb2565b610799565b61025c6102b7366004611beb565b6107f9565b6102296108d9565b6102887f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c981565b6103127f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610240565b610229610332366004611c2c565b610af4565b610288610b31565b61028861034d366004611b0d565b610b8c565b610288600c5481565b7f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b039091168152602001610240565b6102886103a3366004611b0d565b60056020526000908152604090205481565b60095461037d906001600160a01b031681565b6102296103d6366004611b0d565b610bd9565b6102886103e9366004611b0d565b60076020526000908152604090205481565b610288610409366004611c4e565b610cc3565b610288600d5481565b60005461037d906001600160a01b031681565b610229610e6f565b610233610f26565b610288610448366004611c4e565b610f33565b61025c61045b366004611b86565b611041565b61022961046e366004611c2c565b6110a7565b600061025c565b610288600a5481565b60015461037d906001600160a01b031681565b61037d7f000000000000000000000000000000000000000000000000000000000000000081565b6102296104cb366004611c67565b6110e4565b60085461037d906001600160a01b031681565b6102886104f1366004611bb2565b600660209081526000928352604080842090915290825290205481565b610288600b5481565b61052d336000356001600160e01b0319166113b3565b6105525760405162461bcd60e51b815260040161054990611cde565b60405180910390fd5b6000546040516370a0823160e01b81523060048201526105d7916001600160a01b0390811691908416906370a0823190602401602060405180830381865afa1580156105a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105c69190611d04565b6001600160a01b038416919061145d565b600054604080516001600160a01b03808516825290921660208301527fdca40dd6e1f9a4a0c6d9da138be5e2ee4c39d27af85b9876ad34c8d5d8747954910160405180910390a150565b6002805461062e90611d1d565b80601f016020809104026020016040519081016040528092919081815260200182805461065a90611d1d565b80156106a75780601f1061067c576101008083540402835291602001916106a7565b820191906000526020600020905b81548152906001019060200180831161068a57829003601f168201915b505050505081565b3360008181526006602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259061070a9086815260200190565b60405180910390a35060015b92915050565b610732336000356001600160e01b0319166113b3565b61074e5760405162461bcd60e51b815260040161054990611cde565b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6107af336000356001600160e01b0319166113b3565b6107cb5760405162461bcd60e51b815260040161054990611cde565b600980546001600160a01b039384166001600160a01b03199182161790915560088054929093169116179055565b6001600160a01b03831660009081526006602090815260408083203384529091528120546000198114610855576108308382611d6e565b6001600160a01b03861660009081526006602090815260408083203384529091529020555b6001600160a01b0385166000908152600560205260408120805485929061087d908490611d6e565b90915550506001600160a01b0380851660008181526005602052604090819020805487019055519091871690600080516020611ee7833981519152906108c69087815260200190565b60405180910390a3506001949350505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633d18b9126040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561093457600080fd5b505af1158015610948573d6000803e3d6000fd5b5050505060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d1af0c7d6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d09190611d85565b6040516370a0823160e01b81523060048201529091506000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610a1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a3e9190611d04565b90506000610a4c83836114d6565b90506000610a5a84846115a1565b9050600081610a698486611d6e565b610a739190611d6e565b60005460405163a9059cbb60e01b81526001600160a01b0391821660048201526024810183905291925086169063a9059cbb906044016020604051808303816000875af1158015610ac8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aec9190611da2565b505050505050565b610b0a336000356001600160e01b0319166113b3565b610b265760405162461bcd60e51b815260040161054990611cde565b600d91909155600b55565b60007f00000000000000000000000000000000000000000000000000000000000000004614610b6757610b62611638565b905090565b507f000000000000000000000000000000000000000000000000000000000000000090565b6000610716610b996116d2565b6001600160a01b038416600090815260056020526040902054907f00000000000000000000000000000000000000000000000000000000000000006117d2565b6000546001600160a01b0316331480610c6e575060015460405163b700961360e01b81526001600160a01b039091169063b700961390610c2d90339030906001600160e01b03196000351690600401611dc4565b602060405180830381865afa158015610c4a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c6e9190611da2565b610c7757600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6000610d0133610cfc610cd46116d2565b85907f00000000000000000000000000000000000000000000000000000000000000006117ed565b61180f565b6040516370a0823160e01b815230600482015282907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015610d67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d8b9190611d04565b1015610e33576040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015610df8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e1c9190611d04565b610e269084611d6e565b9050610e3181611879565b505b610e676001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016338461145d565b506000919050565b610e85336000356001600160e01b0319166113b3565b610ea15760405162461bcd60e51b815260040161054990611cde565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633d18b9126040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610efc57600080fd5b505af1158015610f10573d6000803e3d6000fd5b50505050610f24610f1f6118f7565b611879565b565b6003805461062e90611d1d565b6000610f4b336000356001600160e01b0319166113b3565b610f675760405162461bcd60e51b815260040161054990611cde565b610f7b33610f76610cd46116d2565b611982565b610fb06001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163330856119d4565b6040516370a0823160e01b8152306004820152610e67907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa158015611018573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061103c9190611d04565b611a61565b33600090815260056020526040812080548391908390611062908490611d6e565b90915550506001600160a01b03831660008181526005602052604090819020805485019055513390600080516020611ee78339815191529061070a9086815260200190565b6110bd336000356001600160e01b0319166113b3565b6110d95760405162461bcd60e51b815260040161054990611cde565b600c91909155600a55565b428410156111345760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f455850495245440000000000000000006044820152606401610549565b600061113e610b31565b6001600160a01b0389811660008181526007602090815260409182902080546001810190915582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98184015280840194909452938c166060840152608083018b905260a083019390935260c08083018a90528151808403909101815260e08301909152805192019190912061190160f01b6101008301526101028201929092526101228101919091526101420160408051601f198184030181528282528051602091820120600080855291840180845281905260ff88169284019290925260608301869052608083018590529092509060019060a0016020604051602081039080840390855afa158015611257573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381161580159061128d5750886001600160a01b0316816001600160a01b0316145b6112ca5760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610549565b6001600160a01b0390811660009081526006602090815260408083208b8516808552908352928190208a905551898152919350918a16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a350505050505050565b600060405163095ea7b360e01b81526001600160a01b03841660048201528260248201526000806044836000895af191505061137081611aae565b6113ad5760405162461bcd60e51b815260206004820152600e60248201526d1054141493d59157d1905253115160921b6044820152606401610549565b50505050565b6001546000906001600160a01b0316801580159061143d575060405163b700961360e01b81526001600160a01b0382169063b7009613906113fc90879030908890600401611dc4565b602060405180830381865afa158015611419573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061143d9190611da2565b8061145557506000546001600160a01b038581169116145b949350505050565b600060405163a9059cbb60e01b81526001600160a01b03841660048201528260248201526000806044836000895af191505061149881611aae565b6113ad5760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610549565b60008115806114e55750600b54155b806114f05750600a54155b156114fd57506000610716565b600b54600a5461150d9084611df1565b6115179190611e10565b600854909150611534906001600160a01b03858116911683611335565b60085460405163b66503cf60e01b81526001600160a01b038581166004830152602482018490529091169063b66503cf906044015b600060405180830381600087803b15801561158357600080fd5b505af1158015611597573d6000803e3d6000fd5b5050505092915050565b60008115806115b05750600d54155b806115bb5750600c54155b156115c857506000610716565b600d54600c546115d89084611df1565b6115e29190611e10565b6009549091506115ff906001600160a01b03858116911683611335565b60095460405163b66503cf60e01b81526001600160a01b038581166004830152602482018490529091169063b66503cf90604401611569565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f600260405161166a9190611e32565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b60045460009080611704577f000000000000000000000000000000000000000000000000000000000000000091505090565b60008061170f6118f7565b6040516370a0823160e01b815230600482015290915081906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a0823190602401602060405180830381865afa158015611778573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061179c9190611d04565b0191506117ca82847f00000000000000000000000000000000000000000000000000000000000000006117ed565b935050505090565b82820283158482048414176117e657600080fd5b0492915050565b82810282151584158583048414171661180557600080fd5b9190910492915050565b6001600160a01b03821660009081526005602052604081208054839290611837908490611d6e565b90915550506004805482900390556040518181526000906001600160a01b03841690600080516020611ee7833981519152906020015b60405180910390a35050565b604051632e1a7d4d60e01b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690632e1a7d4d906024015b600060405180830381600087803b1580156118dc57600080fd5b505af11580156118f0573d6000803e3d6000fd5b5050505050565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa15801561195e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b629190611d04565b80600460008282546119949190611ece565b90915550506001600160a01b038216600081815260056020908152604080832080548601905551848152600080516020611ee7833981519152910161186d565b60006040516323b872dd60e01b81526001600160a01b03851660048201526001600160a01b038416602482015282604482015260008060648360008a5af1915050611a1e81611aae565b6118f05760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610549565b60405163534a7e1d60e11b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063a694fc3a906024016118c2565b60003d82611ac057806000803e806000fd5b8060208114611ad8578015611ae95760009250611aee565b816000803e60005115159250611aee565b600192505b5050919050565b6001600160a01b0381168114611b0a57600080fd5b50565b600060208284031215611b1f57600080fd5b8135611b2a81611af5565b9392505050565b600060208083528351808285015260005b81811015611b5e57858101830151858201604001528201611b42565b81811115611b70576000604083870101525b50601f01601f1916929092016040019392505050565b60008060408385031215611b9957600080fd5b8235611ba481611af5565b946020939093013593505050565b60008060408385031215611bc557600080fd5b8235611bd081611af5565b91506020830135611be081611af5565b809150509250929050565b600080600060608486031215611c0057600080fd5b8335611c0b81611af5565b92506020840135611c1b81611af5565b929592945050506040919091013590565b60008060408385031215611c3f57600080fd5b50508035926020909101359150565b600060208284031215611c6057600080fd5b5035919050565b600080600080600080600060e0888a031215611c8257600080fd5b8735611c8d81611af5565b96506020880135611c9d81611af5565b95506040880135945060608801359350608088013560ff81168114611cc157600080fd5b9699959850939692959460a0840135945060c09093013592915050565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b600060208284031215611d1657600080fd5b5051919050565b600181811c90821680611d3157607f821691505b60208210811415611d5257634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b600082821015611d8057611d80611d58565b500390565b600060208284031215611d9757600080fd5b8151611b2a81611af5565b600060208284031215611db457600080fd5b81518015158114611b2a57600080fd5b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b6000816000190483118215151615611e0b57611e0b611d58565b500290565b600082611e2d57634e487b7160e01b600052601260045260246000fd5b500490565b600080835481600182811c915080831680611e4e57607f831692505b6020808410821415611e6e57634e487b7160e01b86526022600452602486fd5b818015611e825760018114611e9357611ec0565b60ff19861689528489019650611ec0565b60008a81526020902060005b86811015611eb85781548b820152908501908301611e9f565b505084890196505b509498975050505050505050565b60008219821115611ee157611ee1611d58565b50019056feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220b7532a753b94db7be081f974b1bd3acb3043802052b89fe6cda520947412654d64736f6c634300080b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "balanceOfUnderlying(address)": {
        "details": "May mutate the state of the strategy by accruing interest.",
        "params": {
          "user": "The user to get the underlying balance of."
        },
        "returns": {
          "_0": "The user's strategy balance in underlying tokens."
        }
      },
      "isCEther()": {
        "details": "Only present in Fuse cTokens, not Compound cTokens.",
        "returns": {
          "_0": "True if the strategy accepts ETH, false otherwise."
        }
      },
      "mint(uint256)": {
        "params": {
          "amount": "The amount of underlying tokens to deposit."
        },
        "returns": {
          "_0": "An error code, or 0 if the deposit was successful."
        }
      },
      "redeemUnderlying(uint256)": {
        "params": {
          "amount": "The amount of underlying tokens to withdraw."
        },
        "returns": {
          "_0": "An error code, or 0 if the withdrawal was successful."
        }
      },
      "underlying()": {
        "returns": {
          "_0": "The underlying ERC20 token the strategy accepts."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "balanceOfUnderlying(address)": {
        "notice": "Returns a user's strategy balance in underlying tokens."
      },
      "isCEther()": {
        "notice": "Returns whether the strategy accepts ETH or an ERC20."
      },
      "mint(uint256)": {
        "notice": "Deposit a specific amount of underlying tokens into the strategy."
      },
      "redeemUnderlying(uint256)": {
        "notice": "Withdraws a specific amount of underlying tokens from the strategy."
      },
      "underlying()": {
        "notice": "Returns the underlying ERC20 token the strategy accepts."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 17,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 20,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "authority",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Authority)171"
      },
      {
        "astId": 192,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "name",
        "offset": 0,
        "slot": "2",
        "type": "t_string_storage"
      },
      {
        "astId": 194,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "symbol",
        "offset": 0,
        "slot": "3",
        "type": "t_string_storage"
      },
      {
        "astId": 198,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "totalSupply",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 202,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "balanceOf",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 208,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "allowance",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 221,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "nonces",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 15629,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "BRIBE",
        "offset": 0,
        "slot": "8",
        "type": "t_contract(Bribe)3327"
      },
      {
        "astId": 15632,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "GAUGE",
        "offset": 0,
        "slot": "9",
        "type": "t_contract(Gauge)6155"
      },
      {
        "astId": 15635,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "bribeRate",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      },
      {
        "astId": 15638,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "bribeRateBase",
        "offset": 0,
        "slot": "11",
        "type": "t_uint256"
      },
      {
        "astId": 15641,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "gaugeRate",
        "offset": 0,
        "slot": "12",
        "type": "t_uint256"
      },
      {
        "astId": 15644,
        "contract": "srcBuild/strategies/USDV3CRVRewardStrategy.sol:USDV3CRVRewardStrategy",
        "label": "gaugeRateBase",
        "offset": 0,
        "slot": "13",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(Authority)171": {
        "encoding": "inplace",
        "label": "contract Authority",
        "numberOfBytes": "20"
      },
      "t_contract(Bribe)3327": {
        "encoding": "inplace",
        "label": "contract Bribe",
        "numberOfBytes": "20"
      },
      "t_contract(Gauge)6155": {
        "encoding": "inplace",
        "label": "contract Gauge",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}