{
  "address": "0xF1a8a05099F27CcF1b10718c89b8E557335CE4a4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract VaultConfigurationModule",
          "name": "_configModule",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "contract Authority",
          "name": "_authority",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "AuthorityUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract VaultConfigurationModule",
          "name": "newConfigModule",
          "type": "address"
        }
      ],
      "name": "ConfigModuleUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnerUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "authority",
      "outputs": [
        {
          "internalType": "contract Authority",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "configModule",
      "outputs": [
        {
          "internalType": "contract VaultConfigurationModule",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "initializeVault",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "setAuthority",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract VaultConfigurationModule",
          "name": "newConfigModule",
          "type": "address"
        }
      ],
      "name": "setConfigModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "setOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6045fed8f8cd701cfa3d379c07cd222c000ee05de24540e6606e7cb34f578e38",
  "receipt": {
    "to": null,
    "from": "0x1594B6Fd7C346376E51C4Cf46525a9c57c5ea916",
    "contractAddress": "0xF1a8a05099F27CcF1b10718c89b8E557335CE4a4",
    "transactionIndex": 118,
    "gasUsed": "492290",
    "logsBloom": "0x00200000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000000000000004000000400080000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000040000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080080000000000000000000000010000020000000000040000000000000000000000000000000000",
    "blockHash": "0xd97092061d1bab9dfce895ebca19fc2e6d3844c67aed84c62638671aa7371474",
    "transactionHash": "0x6045fed8f8cd701cfa3d379c07cd222c000ee05de24540e6606e7cb34f578e38",
    "logs": [
      {
        "transactionIndex": 118,
        "blockNumber": 14225833,
        "transactionHash": "0x6045fed8f8cd701cfa3d379c07cd222c000ee05de24540e6606e7cb34f578e38",
        "address": "0xF1a8a05099F27CcF1b10718c89b8E557335CE4a4",
        "topics": [
          "0x8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d76",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916"
        ],
        "data": "0x",
        "logIndex": 175,
        "blockHash": "0xd97092061d1bab9dfce895ebca19fc2e6d3844c67aed84c62638671aa7371474"
      },
      {
        "transactionIndex": 118,
        "blockNumber": 14225833,
        "transactionHash": "0x6045fed8f8cd701cfa3d379c07cd222c000ee05de24540e6606e7cb34f578e38",
        "address": "0xF1a8a05099F27CcF1b10718c89b8E557335CE4a4",
        "topics": [
          "0xa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b76389980198",
          "0x0000000000000000000000001594b6fd7c346376e51c4cf46525a9c57c5ea916",
          "0x000000000000000000000000cbb46b017e8d785c107e97c56135894b3ead599c"
        ],
        "data": "0x",
        "logIndex": 176,
        "blockHash": "0xd97092061d1bab9dfce895ebca19fc2e6d3844c67aed84c62638671aa7371474"
      }
    ],
    "blockNumber": 14225833,
    "cumulativeGasUsed": "14742625",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x77a903733d36A8bAF751b00F376ca75201ab0D1d",
    "0x1594B6Fd7C346376E51C4Cf46525a9c57c5ea916",
    "0xcbb46b017e8d785C107e97c56135894b3eAD599C"
  ],
  "numDeployments": 1,
  "solcInputHash": "edd68036c391002ae2af5111886505d2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"_configModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"newConfigModule\",\"type\":\"address\"}],\"name\":\"ConfigModuleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configModule\",\"outputs\":[{\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"initializeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"newConfigModule\",\"type\":\"address\"}],\"name\":\"setConfigModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Transmissions11 and JetJadeja\",\"events\":{\"ConfigModuleUpdated(address)\":{\"params\":{\"newConfigModule\":\"The new configuration module.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_authority\":\"The Authority of the module.\",\"_configModule\":\"The Vault configuration module the module will use to configure Vaults before initialization.\",\"_owner\":\"The owner of the module.\"}},\"initializeVault(address)\":{\"details\":\"This will revert if the Vault has already been initialized.\",\"params\":{\"vault\":\"The Vault to configure and initialize.\"}},\"setConfigModule(address)\":{\"params\":{\"newConfigModule\":\"The Vault configuration module to set.\"}}},\"title\":\"Rari Vault Initialization Module\",\"version\":1},\"userdoc\":{\"events\":{\"ConfigModuleUpdated(address)\":{\"notice\":\"Emitted when the config module is updated.\"}},\"kind\":\"user\",\"methods\":{\"configModule()\":{\"notice\":\"Vault configuration module used to configure Vaults before initialization.\"},\"constructor\":{\"notice\":\"Creates a Vault initialization module.\"},\"initializeVault(address)\":{\"notice\":\"Properly configures and initializes a newly deployed Vault.\"},\"setConfigModule(address)\":{\"notice\":\"Sets a new Vault configuration module.\"}},\"notice\":\"Module for initializing newly created Vaults.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"srcBuild/modules/VaultInitializationModule.sol\":\"VaultInitializationModule\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@rari-capital/solmate/src/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x45a3dedcffe229eb4393a1ac5233da3d332cddae4cf97fc44602614329c1f70a\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x698cdbf614109fafc2bf00057b60715fa3aba9dad447c42f4f8b749ae16ce84f\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/tokens/WETH.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\",\"keccak256\":\"0xd36c6fffd35b32b984b9130ce988fd7fc02f3b004fde160e583131212b0d655f\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Library for converting between addresses and bytes32 values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\\nlibrary Bytes32AddressLib {\\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\\n        return bytes32(bytes20(addressValue));\\n    }\\n}\\n\",\"keccak256\":\"0x2afc1acba8a77555e061420cab585a5bd4f030c3ad0ac3e0066dbb55e3a8adff\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x <= type(uint248).max);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x <= type(uint96).max);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x <= type(uint64).max);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max);\\n\\n        y = uint32(x);\\n    }\\n}\\n\",\"keccak256\":\"0x4d6a75e263a7366389540e0f9065923f50b7fb8f171f99163a81fe93e4cf24a9\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcc39d0f5693925ea1e8c517f7cc24211a9899c83a57e62d806180cdb056b6b75\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /* ///////////////////////////////////////////////////////////////\\n    SIMPLIFIED FIXED POINT OPERATIONS\\n    ////////////////////////////////////////////////////////////// */\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD);\\n        // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y);\\n        // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n        // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n        // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\\n                revert(0, 0)\\n            }\\n\\n        // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n        // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n        // First, divide z - 1 by the denominator and add 1.\\n        // Then multiply it by 0 if z is zero, or 1 otherwise.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                // 0 ** 0 = 1\\n                    z := denominator\\n                }\\n                default {\\n                // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                // If n is even, store denominator in z for now.\\n                    z := denominator\\n                }\\n                default {\\n                // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, denominator)\\n\\n                for {\\n                // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                // Revert immediately if x ** 2 would overflow.\\n                // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                // Set x to scaled xxRound.\\n                    x := div(xxRound, denominator)\\n\\n                // If n is even:\\n                    if mod(n, 2) {\\n                    // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                    // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                        // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                    // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                    // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                    // Return properly scaled zxRound.\\n                        z := div(zxRound, denominator)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /* ///////////////////////////////////////////////////////////////\\n    GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n        // Start off with z at 1.\\n            z := 1\\n\\n        // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n        // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z)\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z)\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z)\\n            }\\n            if iszero(lt(y, 0x8)) {\\n            // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n        // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n        // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n        // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1484f097a7d98e687f22bf68cc3a58077230c075675c1d3b08439a2b402c0808\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {WETH} from \\\"@rari-capital/solmate/src/tokens/WETH.sol\\\";\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeCastLib} from \\\"@rari-capital/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./FixedPointMathLib.sol\\\"; //added fdiv and fmul TODO: looking at new rari/next code perhaps we're moving to a new library\\n\\nimport {Strategy, ERC20Strategy, ETHStrategy} from \\\"./interfaces/Strategy.sol\\\";\\n\\n/// @title Aphra Vault (avToken)\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Flexible, minimalist, and gas-optimized yield\\n/// aggregator for earning interest on any ERC20 token.\\n/// @notice changes from original are to rename Rari -> Aphra tokens and any usage of rvToken => avToken\\ncontract Vault is ERC20, Auth {\\n    using SafeCastLib for uint256;\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The maximum number of elements allowed on the withdrawal stack.\\n    /// @dev Needed to prevent denial of service attacks by queue operators.\\n    uint256 internal constant MAX_WITHDRAWAL_STACK_SIZE = 32;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                                IMMUTABLES\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The underlying token the Vault accepts.\\n    ERC20 public immutable UNDERLYING;\\n\\n    /// @notice The base unit of the underlying token and hence avToken.\\n    /// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\\n    uint256 internal immutable BASE_UNIT;\\n\\n    /// @notice Creates a new Vault that accepts a specific underlying token.\\n    /// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\\n    constructor(ERC20 _UNDERLYING)\\n        ERC20(\\n            // ex: Rari Dai Stablecoin Vault\\n            string(abi.encodePacked(\\\"Aphra \\\", _UNDERLYING.name(), \\\" Vault\\\")),\\n            // ex: rvDAI\\n            string(abi.encodePacked(\\\"av\\\", _UNDERLYING.symbol())),\\n            // ex: 18\\n            _UNDERLYING.decimals()\\n        )\\n        Auth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\\n    {\\n        UNDERLYING = _UNDERLYING;\\n\\n        BASE_UNIT = 10**decimals;\\n\\n        // Prevent minting of avTokens until\\n        // the initialize function is called.\\n        totalSupply = type(uint256).max;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                           FEE CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The percentage of profit recognized each harvest to reserve as fees.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public feePercent;\\n\\n    /// @notice Emitted when the fee percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newFeePercent The new fee percentage.\\n    event FeePercentUpdated(address indexed user, uint256 newFeePercent);\\n\\n    /// @notice Sets a new fee percentage.\\n    /// @param newFeePercent The new fee percentage.\\n    function setFeePercent(uint256 newFeePercent) external requiresAuth {\\n        // A fee percentage over 100% doesn't make sense.\\n        require(newFeePercent <= 1e18, \\\"FEE_TOO_HIGH\\\");\\n\\n        // Update the fee percentage.\\n        feePercent = newFeePercent;\\n\\n        emit FeePercentUpdated(msg.sender, newFeePercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        HARVEST CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the harvest window is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestWindow The new harvest window.\\n    event HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\\n\\n    /// @notice Emitted when the harvest delay is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The new harvest delay.\\n    event HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newHarvestDelay The scheduled updated harvest delay.\\n    event HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\\n\\n    /// @notice The period in seconds during which multiple harvests can occur\\n    /// regardless if they are taking place before the harvest delay has elapsed.\\n    /// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\\n    uint128 public harvestWindow;\\n\\n    /// @notice The period in seconds over which locked profit is unlocked.\\n    /// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\\n    uint64 public harvestDelay;\\n\\n    /// @notice The value that will replace harvestDelay next harvest.\\n    /// @dev In the case that the next delay is 0, no update will be applied.\\n    uint64 public nextHarvestDelay;\\n\\n    /// @notice Sets a new harvest window.\\n    /// @param newHarvestWindow The new harvest window.\\n    /// @dev The Vault's harvestDelay must already be set before calling.\\n    function setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\\n        // A harvest window longer than the harvest delay doesn't make sense.\\n        require(newHarvestWindow <= harvestDelay, \\\"WINDOW_TOO_LONG\\\");\\n\\n        // Update the harvest window.\\n        harvestWindow = newHarvestWindow;\\n\\n        emit HarvestWindowUpdated(msg.sender, newHarvestWindow);\\n    }\\n\\n    /// @notice Sets a new harvest delay.\\n    /// @param newHarvestDelay The new harvest delay to set.\\n    /// @dev If the current harvest delay is 0, meaning it has not\\n    /// been set before, it will be updated immediately, otherwise\\n    /// it will be scheduled to take effect after the next harvest.\\n    function setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\\n        // A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\\n        require(newHarvestDelay != 0, \\\"DELAY_CANNOT_BE_ZERO\\\");\\n\\n        // A harvest delay longer than 1 year doesn't make sense.\\n        require(newHarvestDelay <= 365 days, \\\"DELAY_TOO_LONG\\\");\\n\\n        // If the harvest delay is 0, meaning it has not been set before:\\n        if (harvestDelay == 0) {\\n            // We'll apply the update immediately.\\n            harvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        } else {\\n            // We'll apply the update next harvest.\\n            nextHarvestDelay = newHarvestDelay;\\n\\n            emit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       TARGET FLOAT CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The desired percentage of the Vault's holdings to keep as float.\\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n    uint256 public targetFloatPercent;\\n\\n    /// @notice Emitted when the target float percentage is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    event TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\\n\\n    /// @notice Set a new target float percentage.\\n    /// @param newTargetFloatPercent The new target float percentage.\\n    function setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\\n        // A target float percentage over 100% doesn't make sense.\\n        require(newTargetFloatPercent <= 1e18, \\\"TARGET_TOO_HIGH\\\");\\n\\n        // Update the target float percentage.\\n        targetFloatPercent = newTargetFloatPercent;\\n\\n        emit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                   UNDERLYING IS WETH CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Whether the Vault should treat the underlying token as WETH compatible.\\n    /// @dev If enabled the Vault will allow trusting strategies that accept Ether.\\n    bool public underlyingIsWETH;\\n\\n    /// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\\n    /// @param user The authorized user who triggered the update.\\n    /// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\\n    event UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\\n\\n    /// @notice Sets whether the Vault treats the underlying as WETH.\\n    /// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\\n    /// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\\n    function setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\\n        // Ensure the underlying token's decimals match ETH if is WETH being set to true.\\n        require(!newUnderlyingIsWETH || UNDERLYING.decimals() == 18, \\\"WRONG_DECIMALS\\\");\\n\\n        // Update whether the Vault treats the underlying as WETH.\\n        underlyingIsWETH = newUnderlyingIsWETH;\\n\\n        emit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          STRATEGY STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\\n    /// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\\n    uint256 public totalStrategyHoldings;\\n\\n    /// @dev Packed struct of strategy data.\\n    /// @param trusted Whether the strategy is trusted.\\n    /// @param balance The amount of underlying tokens held in the strategy.\\n    struct StrategyData {\\n        // Used to determine if the Vault will operate on a strategy.\\n        bool trusted;\\n        // Used to determine profit and loss during harvests of the strategy.\\n        uint248 balance;\\n    }\\n\\n    /// @notice Maps strategies to data the Vault holds on them.\\n    mapping(Strategy => StrategyData) public getStrategyData;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\\n    /// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\\n    uint64 public lastHarvestWindowStart;\\n\\n    /// @notice A timestamp representing when the most recent harvest occurred.\\n    uint64 public lastHarvest;\\n\\n    /// @notice The amount of locked profit at the end of the last harvest.\\n    uint128 public maxLockedProfit;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        WITHDRAWAL STACK STORAGE\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice An ordered array of strategies representing the withdrawal stack.\\n    /// @dev The stack is processed in descending order, meaning the last index will be withdrawn from first.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\\n    /// withdrawal time, not validated upfront, meaning the stack may not reflect the \\\"true\\\" set used for withdrawals.\\n    Strategy[] public withdrawalStack;\\n\\n    /// @notice Gets the full withdrawal stack.\\n    /// @return An ordered array of strategies representing the withdrawal stack.\\n    /// @dev This is provided because Solidity converts public arrays into index getters,\\n    /// but we need a way to allow external contracts and users to access the whole array.\\n    function getWithdrawalStack() external view returns (Strategy[] memory) {\\n        return withdrawalStack;\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful deposit.\\n    /// @param user The address that deposited into the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event Deposit(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after a successful withdrawal.\\n    /// @param user The address that withdrew from the Vault.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event Withdraw(address indexed user, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of the underlying token to deposit.\\n    function deposit(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and mint them.\\n        _mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Deposit(msg.sender, underlyingAmount);\\n\\n        // Transfer in underlying tokens from the user.\\n        // This will revert if the user does not have the amount specified.\\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens.\\n    /// @param underlyingAmount The amount of underlying tokens to withdraw.\\n    function withdraw(uint256 underlyingAmount) external {\\n        // Determine the equivalent amount of avTokens and burn them.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @notice Redeem a specific amount of avTokens for underlying tokens.\\n    /// @param avTokenAmount The amount of avTokens to redeem for underlying tokens.\\n    function redeem(uint256 avTokenAmount) external {\\n        // Determine the equivalent amount of underlying tokens.\\n        uint256 underlyingAmount = avTokenAmount.fmul(exchangeRate(), BASE_UNIT);\\n\\n        // Burn the provided amount of avTokens.\\n        // This will revert if the user does not have enough avTokens.\\n        _burn(msg.sender, avTokenAmount);\\n\\n        emit Withdraw(msg.sender, underlyingAmount);\\n\\n        // Withdraw from strategies if needed and transfer.\\n        transferUnderlyingTo(msg.sender, underlyingAmount);\\n    }\\n\\n    /// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\\n    /// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\\n    /// @param recipient The user to transfer the underlying tokens to.\\n    /// @param underlyingAmount The amount of underlying tokens to transfer.\\n    function transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\\n        // Get the Vault's floating balance.\\n        uint256 float = totalFloat();\\n\\n        // If the amount is greater than the float, withdraw from strategies.\\n        if (underlyingAmount > float) {\\n            // Compute the amount needed to reach our target float percentage.\\n            uint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(targetFloatPercent, 1e18);\\n\\n            // Compute the bare minimum amount we need for this withdrawal.\\n            uint256 floatMissingForWithdrawal = underlyingAmount - float;\\n\\n            // Pull enough to cover the withdrawal and reach our target float percentage.\\n            pullFromWithdrawalStack(floatMissingForWithdrawal + floatMissingForTarget);\\n        }\\n\\n        // Transfer the provided amount of underlying tokens.\\n        UNDERLYING.safeTransfer(recipient, underlyingAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                        VAULT ACCOUNTING LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Returns a user's Vault balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Vault balance in underlying tokens.\\n    function balanceOfUnderlying(address user) external view returns (uint256) {\\n        return balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens an avToken can be redeemed for.\\n    /// @return The amount of underlying tokens an avToken can be redeemed for.\\n    function exchangeRate() public view returns (uint256) {\\n        // Get the total supply of avTokens.\\n        uint256 avTokenSupply = totalSupply;\\n\\n        // If there are no avTokens in circulation, return an exchange rate of 1:1.\\n        if (avTokenSupply == 0) return BASE_UNIT;\\n\\n        // Calculate the exchange rate by dividing the total holdings by the avToken supply.\\n        return totalHoldings().fdiv(avTokenSupply, BASE_UNIT);\\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds.\\n    /// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\\n    function totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\\n        unchecked {\\n            // Cannot underflow as locked profit can't exceed total strategy holdings.\\n            totalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\\n        }\\n\\n        // Include our floating balance in the total.\\n        totalUnderlyingHeld += totalFloat();\\n    }\\n\\n    /// @notice Calculates the current amount of locked profit.\\n    /// @return The current amount of locked profit.\\n    function lockedProfit() public view returns (uint256) {\\n        // Get the last harvest and harvest delay.\\n        uint256 previousHarvest = lastHarvest;\\n        uint256 harvestInterval = harvestDelay;\\n\\n        unchecked {\\n            // If the harvest delay has passed, there is no locked profit.\\n            // Cannot overflow on human timescales since harvestInterval is capped.\\n            if (block.timestamp >= previousHarvest + harvestInterval) return 0;\\n\\n            // Get the maximum amount we could return.\\n            uint256 maximumLockedProfit = maxLockedProfit;\\n\\n            // Compute how much profit remains locked based on the last harvest and harvest delay.\\n            // It's impossible for the previous harvest to be in the future, so this will never underflow.\\n            return maximumLockedProfit - (maximumLockedProfit * (block.timestamp - previousHarvest)) / harvestInterval;\\n        }\\n    }\\n\\n    /// @notice Returns the amount of underlying tokens that idly sit in the Vault.\\n    /// @return The amount of underlying tokens that sit idly in the Vault.\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             HARVEST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a successful harvest.\\n    /// @param user The authorized user who triggered the harvest.\\n    /// @param strategies The trusted strategies that were harvested.\\n    event Harvest(address indexed user, Strategy[] strategies);\\n\\n    /// @notice Harvest a set of trusted strategies.\\n    /// @param strategies The trusted strategies to harvest.\\n    /// @dev Will always revert if called outside of an active\\n    /// harvest window or before the harvest delay has passed.\\n    function harvest(Strategy[] calldata strategies) external requiresAuth {\\n        // If this is the first harvest after the last window:\\n        if (block.timestamp >= lastHarvest + harvestDelay) {\\n            // Set the harvest window's start timestamp.\\n            // Cannot overflow 64 bits on human timescales.\\n            lastHarvestWindowStart = uint64(block.timestamp);\\n        } else {\\n            // We know this harvest is not the first in the window so we need to ensure it's within it.\\n            require(block.timestamp <= lastHarvestWindowStart + harvestWindow, \\\"BAD_HARVEST_TIME\\\");\\n        }\\n\\n        // Get the Vault's current total strategy holdings.\\n        uint256 oldTotalStrategyHoldings = totalStrategyHoldings;\\n\\n        // Used to store the total profit accrued by the strategies.\\n        uint256 totalProfitAccrued;\\n\\n        // Used to store the new total strategy holdings after harvesting.\\n        uint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\\n\\n        // Will revert if any of the specified strategies are untrusted.\\n        for (uint256 i = 0; i < strategies.length; i++) {\\n            // Get the strategy at the current index.\\n            Strategy strategy = strategies[i];\\n\\n            // If an untrusted strategy could be harvested a malicious user could use\\n            // a fake strategy that over-reports holdings to manipulate the exchange rate.\\n            require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n            // Get the strategy's previous and current balance.\\n            uint256 balanceLastHarvest = getStrategyData[strategy].balance;\\n            uint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\\n\\n            // Update the strategy's stored balance. Cast overflow is unrealistic.\\n            getStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\\n\\n            // Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\\n            // We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\\n            newTotalStrategyHoldings = newTotalStrategyHoldings + balanceThisHarvest - balanceLastHarvest;\\n\\n            unchecked {\\n                // Update the total profit accrued while counting losses as zero profit.\\n                // Cannot overflow as we already increased total holdings without reverting.\\n                totalProfitAccrued += balanceThisHarvest > balanceLastHarvest\\n                    ? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\\n                    : 0; // If the strategy registered a net loss we don't have any new profit.\\n            }\\n        }\\n\\n        // Compute fees as the fee percent multiplied by the profit.\\n        uint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\\n\\n        // If we accrued any fees, mint an equivalent amount of avTokens.\\n        // Authorized users can claim the newly minted avTokens via claimFees.\\n        _mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\\n\\n        // Update max unlocked profit based on any remaining locked profit plus new profit.\\n        maxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\\n\\n        // Set strategy holdings to our new total.\\n        totalStrategyHoldings = newTotalStrategyHoldings;\\n\\n        // Update the last harvest timestamp.\\n        // Cannot overflow on human timescales.\\n        lastHarvest = uint64(block.timestamp);\\n\\n        emit Harvest(msg.sender, strategies);\\n\\n        // Get the next harvest delay.\\n        uint64 newHarvestDelay = nextHarvestDelay;\\n\\n        // If the next harvest delay is not 0:\\n        if (newHarvestDelay != 0) {\\n            // Update the harvest delay.\\n            harvestDelay = newHarvestDelay;\\n\\n            // Reset the next harvest delay.\\n            nextHarvestDelay = 0;\\n\\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n        }\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    STRATEGY DEPOSIT/WITHDRAWAL LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after the Vault deposits into a strategy contract.\\n    /// @param user The authorized user who triggered the deposit.\\n    /// @param strategy The strategy that was deposited into.\\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\\n    event StrategyDeposit(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Emitted after the Vault withdraws funds from a strategy contract.\\n    /// @param user The authorized user who triggered the withdrawal.\\n    /// @param strategy The strategy that was withdrawn from.\\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n    event StrategyWithdrawal(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\\n\\n    /// @notice Deposit a specific amount of float into a trusted strategy.\\n    /// @param strategy The trusted strategy to deposit into.\\n    /// @param underlyingAmount The amount of underlying tokens in float to deposit.\\n    function depositIntoStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be deposited into.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Increase totalStrategyHoldings to account for the deposit.\\n        totalStrategyHoldings += underlyingAmount;\\n\\n        unchecked {\\n            // Without this the next harvest would count the deposit as profit.\\n            // Cannot overflow as the balance of one strategy can't exceed the sum of all.\\n            getStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\\n        }\\n\\n        emit StrategyDeposit(msg.sender, strategy, underlyingAmount);\\n\\n        // We need to deposit differently if the strategy takes ETH.\\n        if (strategy.isCEther()) {\\n            // Unwrap the right amount of WETH.\\n            WETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\\n\\n            // Deposit into the strategy and assume it will revert on error.\\n            ETHStrategy(address(strategy)).mint{value: underlyingAmount}();\\n        } else {\\n            // Approve underlyingAmount to the strategy so we can deposit.\\n            UNDERLYING.safeApprove(address(strategy), underlyingAmount);\\n\\n            // Deposit into the strategy and revert if it returns an error code.\\n            require(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \\\"MINT_FAILED\\\");\\n        }\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a strategy.\\n    /// @param strategy The strategy to withdraw from.\\n    /// @param underlyingAmount  The amount of underlying tokens to withdraw.\\n    /// @dev Withdrawing from a strategy will not remove it from the withdrawal stack.\\n    function withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\\n        // A strategy must be trusted before it can be withdrawn from.\\n        require(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n        // Without this the next harvest would count the withdrawal as a loss.\\n        getStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the withdrawal.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        emit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\\n\\n        // Withdraw from the strategy and revert if it returns an error code.\\n        require(strategy.redeemUnderlying(underlyingAmount) == 0, \\\"REDEEM_FAILED\\\");\\n\\n        // Wrap the withdrawn Ether into WETH if necessary.\\n        if (strategy.isCEther()) WETH(payable(address(UNDERLYING))).deposit{value: underlyingAmount}();\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                      STRATEGY TRUST/DISTRUST LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is set to trusted.\\n    /// @param user The authorized user who trusted the strategy.\\n    /// @param strategy The strategy that became trusted.\\n    event StrategyTrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Emitted when a strategy is set to untrusted.\\n    /// @param user The authorized user who untrusted the strategy.\\n    /// @param strategy The strategy that became untrusted.\\n    event StrategyDistrusted(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Stores a strategy as trusted, enabling it to be harvested.\\n    /// @param strategy The strategy to make trusted.\\n    function trustStrategy(Strategy strategy) external requiresAuth {\\n        // Ensure the strategy accepts the correct underlying token.\\n        // If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\\n        require(\\n            strategy.isCEther() ? underlyingIsWETH : ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\\n            \\\"WRONG_UNDERLYING\\\"\\n        );\\n\\n        // Store the strategy as trusted.\\n        getStrategyData[strategy].trusted = true;\\n\\n        emit StrategyTrusted(msg.sender, strategy);\\n    }\\n\\n    /// @notice Stores a strategy as untrusted, disabling it from being harvested.\\n    /// @param strategy The strategy to make untrusted.\\n    function distrustStrategy(Strategy strategy) external requiresAuth {\\n        // Store the strategy as untrusted.\\n        getStrategyData[strategy].trusted = false;\\n\\n        emit StrategyDistrusted(msg.sender, strategy);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         WITHDRAWAL STACK LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a strategy is pushed to the withdrawal stack.\\n    /// @param user The authorized user who triggered the push.\\n    /// @param pushedStrategy The strategy pushed to the withdrawal stack.\\n    event WithdrawalStackPushed(address indexed user, Strategy indexed pushedStrategy);\\n\\n    /// @notice Emitted when a strategy is popped from the withdrawal stack.\\n    /// @param user The authorized user who triggered the pop.\\n    /// @param poppedStrategy The strategy popped from the withdrawal stack.\\n    event WithdrawalStackPopped(address indexed user, Strategy indexed poppedStrategy);\\n\\n    /// @notice Emitted when the withdrawal stack is updated.\\n    /// @param user The authorized user who triggered the set.\\n    /// @param replacedWithdrawalStack The new withdrawal stack.\\n    event WithdrawalStackSet(address indexed user, Strategy[] replacedWithdrawalStack);\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack that was replaced.\\n    /// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\\n    event WithdrawalStackIndexReplaced(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed replacementStrategy\\n    );\\n\\n    /// @notice Emitted when an index in the withdrawal stack is replaced with the tip.\\n    /// @param user The authorized user who triggered the replacement.\\n    /// @param index The index of the replaced strategy in the withdrawal stack.\\n    /// @param replacedStrategy The strategy in the withdrawal stack replaced by the tip.\\n    /// @param previousTipStrategy The previous tip of the stack that replaced the strategy.\\n    event WithdrawalStackIndexReplacedWithTip(\\n        address indexed user,\\n        uint256 index,\\n        Strategy indexed replacedStrategy,\\n        Strategy indexed previousTipStrategy\\n    );\\n\\n    /// @notice Emitted when the strategies at two indexes are swapped.\\n    /// @param user The authorized user who triggered the swap.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    /// @param newStrategy1 The strategy (previously at index2) that replaced index1.\\n    /// @param newStrategy2 The strategy (previously at index1) that replaced index2.\\n    event WithdrawalStackIndexesSwapped(\\n        address indexed user,\\n        uint256 index1,\\n        uint256 index2,\\n        Strategy indexed newStrategy1,\\n        Strategy indexed newStrategy2\\n    );\\n\\n    /// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal stack.\\n    /// @param underlyingAmount The amount of underlying tokens to pull into float.\\n    /// @dev Automatically removes depleted strategies from the withdrawal stack.\\n    function pullFromWithdrawalStack(uint256 underlyingAmount) internal {\\n        // We will update this variable as we pull from strategies.\\n        uint256 amountLeftToPull = underlyingAmount;\\n\\n        // We'll start at the tip of the stack and traverse backwards.\\n        uint256 currentIndex = withdrawalStack.length - 1;\\n\\n        // Iterate in reverse so we pull from the stack in a \\\"last in, first out\\\" manner.\\n        // Will revert due to underflow if we empty the stack before pulling the desired amount.\\n        for (; ; currentIndex--) {\\n            // Get the strategy at the current stack index.\\n            Strategy strategy = withdrawalStack[currentIndex];\\n\\n            // Get the balance of the strategy before we withdraw from it.\\n            uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n            // If the strategy is currently untrusted or was already depleted:\\n            if (!getStrategyData[strategy].trusted || strategyBalance == 0) {\\n                // Remove it from the stack.\\n                withdrawalStack.pop();\\n\\n                emit WithdrawalStackPopped(msg.sender, strategy);\\n\\n                // Move onto the next strategy.\\n                continue;\\n            }\\n\\n            // We want to pull as much as we can from the strategy, but no more than we need.\\n            uint256 amountToPull = strategyBalance > amountLeftToPull ? amountLeftToPull : strategyBalance;\\n\\n            unchecked {\\n                // Compute the balance of the strategy that will remain after we withdraw.\\n                // Cannot underflow as we cap the amount to pull at the strategy's balance.\\n                uint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\\n\\n                // Without this the next harvest would count the withdrawal as a loss.\\n                getStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\\n\\n                // Adjust our goal based on how much we can pull from the strategy.\\n                // Cannot underflow as we cap the amount to pull at the amount left to pull.\\n                amountLeftToPull -= amountToPull;\\n\\n                emit StrategyWithdrawal(msg.sender, strategy, amountToPull);\\n\\n                // Withdraw from the strategy and revert if returns an error code.\\n                require(strategy.redeemUnderlying(amountToPull) == 0, \\\"REDEEM_FAILED\\\");\\n\\n                // If we fully depleted the strategy:\\n                if (strategyBalanceAfterWithdrawal == 0) {\\n                    // Remove it from the stack.\\n                    withdrawalStack.pop();\\n\\n                    emit WithdrawalStackPopped(msg.sender, strategy);\\n                }\\n            }\\n\\n            // If we've pulled all we need, exit the loop.\\n            if (amountLeftToPull == 0) break;\\n        }\\n\\n        unchecked {\\n            // Account for the withdrawals done in the loop above.\\n            // Cannot underflow as the balances of some strategies cannot exceed the sum of all.\\n            totalStrategyHoldings -= underlyingAmount;\\n        }\\n\\n        // Cache the Vault's balance of ETH.\\n        uint256 ethBalance = address(this).balance;\\n\\n        // If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\\n        if (ethBalance != 0 && underlyingIsWETH) WETH(payable(address(UNDERLYING))).deposit{value: ethBalance}();\\n    }\\n\\n    /// @notice Pushes a single strategy to front of the withdrawal stack.\\n    /// @param strategy The strategy to be inserted at the front of the withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function pushToWithdrawalStack(Strategy strategy) external requiresAuth {\\n        // Ensure pushing the strategy will not cause the stack exceed its limit.\\n        require(withdrawalStack.length < MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_FULL\\\");\\n\\n        // Push the strategy to the front of the stack.\\n        withdrawalStack.push(strategy);\\n\\n        emit WithdrawalStackPushed(msg.sender, strategy);\\n    }\\n\\n    /// @notice Removes the strategy at the tip of the withdrawal stack.\\n    /// @dev Be careful, another authorized user could push a different strategy\\n    /// than expected to the stack while a popFromWithdrawalStack transaction is pending.\\n    function popFromWithdrawalStack() external requiresAuth {\\n        // Get the (soon to be) popped strategy.\\n        Strategy poppedStrategy = withdrawalStack[withdrawalStack.length - 1];\\n\\n        // Pop the first strategy in the stack.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackPopped(msg.sender, poppedStrategy);\\n    }\\n\\n    /// @notice Sets a new withdrawal stack.\\n    /// @param newStack The new withdrawal stack.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function setWithdrawalStack(Strategy[] calldata newStack) external requiresAuth {\\n        // Ensure the new stack is not larger than the maximum stack size.\\n        require(newStack.length <= MAX_WITHDRAWAL_STACK_SIZE, \\\"STACK_TOO_BIG\\\");\\n\\n        // Replace the withdrawal stack.\\n        withdrawalStack = newStack;\\n\\n        emit WithdrawalStackSet(msg.sender, newStack);\\n    }\\n\\n    /// @notice Replaces an index in the withdrawal stack with another strategy.\\n    /// @param index The index in the stack to replace.\\n    /// @param replacementStrategy The strategy to override the index with.\\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\\n    /// filtered out when encountered at withdrawal time, not validated upfront.\\n    function replaceWithdrawalStackIndex(uint256 index, Strategy replacementStrategy) external requiresAuth {\\n        // Get the (soon to be) replaced strategy.\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Update the index with the replacement strategy.\\n        withdrawalStack[index] = replacementStrategy;\\n\\n        emit WithdrawalStackIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\\n    }\\n\\n    /// @notice Moves the strategy at the tip of the stack to the specified index and pop the tip off the stack.\\n    /// @param index The index of the strategy in the withdrawal stack to replace with the tip.\\n    function replaceWithdrawalStackIndexWithTip(uint256 index) external requiresAuth {\\n        // Get the (soon to be) previous tip and strategy we will replace at the index.\\n        Strategy previousTipStrategy = withdrawalStack[withdrawalStack.length - 1];\\n        Strategy replacedStrategy = withdrawalStack[index];\\n\\n        // Replace the index specified with the tip of the stack.\\n        withdrawalStack[index] = previousTipStrategy;\\n\\n        // Remove the now duplicated tip from the array.\\n        withdrawalStack.pop();\\n\\n        emit WithdrawalStackIndexReplacedWithTip(msg.sender, index, replacedStrategy, previousTipStrategy);\\n    }\\n\\n    /// @notice Swaps two indexes in the withdrawal stack.\\n    /// @param index1 One index involved in the swap\\n    /// @param index2 The other index involved in the swap.\\n    function swapWithdrawalStackIndexes(uint256 index1, uint256 index2) external requiresAuth {\\n        // Get the (soon to be) new strategies at each index.\\n        Strategy newStrategy2 = withdrawalStack[index1];\\n        Strategy newStrategy1 = withdrawalStack[index2];\\n\\n        // Swap the strategies at both indexes.\\n        withdrawalStack[index1] = newStrategy1;\\n        withdrawalStack[index2] = newStrategy2;\\n\\n        emit WithdrawalStackIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                         SEIZE STRATEGY LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after a strategy is seized.\\n    /// @param user The authorized user who triggered the seize.\\n    /// @param strategy The strategy that was seized.\\n    event StrategySeized(address indexed user, Strategy indexed strategy);\\n\\n    /// @notice Seizes a strategy.\\n    /// @param strategy The strategy to seize.\\n    /// @dev Intended for use in emergencies or other extraneous situations where the\\n    /// strategy requires interaction outside of the Vault's standard operating procedures.\\n    function seizeStrategy(Strategy strategy) external requiresAuth {\\n        // Get the strategy's last reported balance of underlying tokens.\\n        uint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n        // If the strategy's balance exceeds the Vault's current\\n        // holdings, instantly unlock any remaining locked profit.\\n        if (strategyBalance > totalHoldings()) maxLockedProfit = 0;\\n\\n        // Set the strategy's balance to 0.\\n        getStrategyData[strategy].balance = 0;\\n\\n        unchecked {\\n            // Decrease totalStrategyHoldings to account for the seize.\\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n            totalStrategyHoldings -= strategyBalance;\\n        }\\n\\n        emit StrategySeized(msg.sender, strategy);\\n\\n        // Transfer all of the strategy's tokens to the caller.\\n        ERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                             FEE CLAIM LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted after fees are claimed.\\n    /// @param user The authorized user who claimed the fees.\\n    /// @param avTokenAmount The amount of avTokens that were claimed.\\n    event FeesClaimed(address indexed user, uint256 avTokenAmount);\\n\\n    /// @notice Claims fees accrued from harvests.\\n    /// @param avTokenAmount The amount of avTokens to claim.\\n    /// @dev Accrued fees are measured as avTokens held by the Vault.\\n    function claimFees(uint256 avTokenAmount) external requiresAuth {\\n        emit FeesClaimed(msg.sender, avTokenAmount);\\n\\n        // Transfer the provided amount of avTokens to the caller.\\n        ERC20(this).safeTransfer(msg.sender, avTokenAmount);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                    INITIALIZATION AND DESTRUCTION LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the Vault is initialized.\\n    /// @param user The authorized user who triggered the initialization.\\n    event Initialized(address indexed user);\\n\\n    /// @notice Whether the Vault has been initialized yet.\\n    /// @dev Can go from false to true, never from true to false.\\n    bool public isInitialized;\\n\\n    /// @notice Initializes the Vault, enabling it to receive deposits.\\n    /// @dev All critical parameters must already be set before calling.\\n    function initialize() external requiresAuth {\\n        // Ensure the Vault has not already been initialized.\\n        require(!isInitialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n        // Mark the Vault as initialized.\\n        isInitialized = true;\\n\\n        // Open for deposits.\\n        totalSupply = 0;\\n\\n        emit Initialized(msg.sender);\\n    }\\n\\n    /// @notice Self destructs a Vault, enabling it to be redeployed.\\n    /// @dev Caller will receive any ETH held as float in the Vault.\\n    function destroy() external requiresAuth {\\n        selfdestruct(payable(msg.sender));\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          RECIEVE ETHER LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @dev Required for the Vault to receive unwrapped ETH.\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xbbd3589ad8bcb0b094113b4952cc967e68d6843ce35b380c51d6b4a208db9823\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/VaultFactory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {Bytes32AddressLib} from \\\"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\\\";\\n\\nimport {Vault} from \\\"./Vault.sol\\\";\\n\\n/// @title Rari Vault Factory\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Factory which enables deploying a Vault for any ERC20 token.\\ncontract VaultFactory is Auth {\\n    using Bytes32AddressLib for address;\\n    using Bytes32AddressLib for bytes32;\\n\\n    /* //////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Creates a Vault factory.\\n    /// @param _owner The owner of the factory.\\n    /// @param _authority The Authority of the factory.\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /* //////////////////////////////////////////////////////////////\\n                          VAULT DEPLOYMENT LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a new Vault is deployed.\\n    /// @param vault The newly deployed Vault contract.\\n    /// @param underlying The underlying token the new Vault accepts.\\n    event VaultDeployed(Vault vault, ERC20 underlying);\\n\\n    /// @notice Deploys a new Vault which supports a specific underlying token.\\n    /// @dev This will revert if a Vault that accepts the same underlying token has already been deployed.\\n    /// @param underlying The ERC20 token that the Vault should accept.\\n    /// @return vault The newly deployed Vault contract which accepts the provided underlying token.\\n    function deployVault(ERC20 underlying) external returns (Vault vault) {\\n        // Use the CREATE2 opcode to deploy a new Vault contract.\\n        // This will revert if a Vault which accepts this underlying token has already\\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\\n        vault = new Vault{salt: address(underlying).fillLast12Bytes()}(underlying);\\n\\n        emit VaultDeployed(vault, underlying);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                            VAULT LOOKUP LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Computes a Vault's address from its accepted underlying token.\\n    /// @param underlying The ERC20 token that the Vault should accept.\\n    /// @return The address of a Vault which accepts the provided underlying token.\\n    /// @dev The Vault returned may not be deployed yet. Use isVaultDeployed to check.\\n    function getVaultFromUnderlying(ERC20 underlying) external view returns (Vault) {\\n        return\\n            Vault(\\n                payable(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            // Prefix:\\n                            bytes1(0xFF),\\n                            // Creator:\\n                            address(this),\\n                            // Salt:\\n                            address(underlying).fillLast12Bytes(),\\n                            // Bytecode hash:\\n                            keccak256(\\n                                abi.encodePacked(\\n                                    // Deployment bytecode:\\n                                    type(Vault).creationCode,\\n                                    // Constructor arguments:\\n                                    abi.encode(underlying)\\n                                )\\n                            )\\n                        )\\n                    ).fromLast20Bytes() // Convert the CREATE2 hash into an address.\\n                )\\n            );\\n    }\\n\\n    /// @notice Returns if a Vault at an address has already been deployed.\\n    /// @param vault The address of a Vault which may not have been deployed yet.\\n    /// @return A boolean indicating whether the Vault has been deployed already.\\n    /// @dev This function is useful to check the return values of getVaultFromUnderlying,\\n    /// as it does not check that the Vault addresses it computes have been deployed yet.\\n    function isVaultDeployed(Vault vault) external view returns (bool) {\\n        return address(vault).code.length > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x42c48cb9d26a8dd759ce4d7f744813984d72586bdfbc0e97d24c82ad5cf480bf\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/interfaces/Strategy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\n/// @dev Designed for out of the box compatibility with Fuse cTokens.\\n/// @dev Like cTokens, strategies must be transferrable ERC20s.\\nabstract contract Strategy is ERC20 {\\n    /// @notice Returns whether the strategy accepts ETH or an ERC20.\\n    /// @return True if the strategy accepts ETH, false otherwise.\\n    /// @dev Only present in Fuse cTokens, not Compound cTokens.\\n    function isCEther() external view virtual returns (bool);\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the strategy.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external virtual returns (uint256);\\n\\n    /// @notice Returns a user's strategy balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's strategy balance in underlying tokens.\\n    /// @dev May mutate the state of the strategy by accruing interest.\\n    function balanceOfUnderlying(address user) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\\n/// @dev Designed for out of the box compatibility with Fuse cERC20s.\\nabstract contract ERC20Strategy is Strategy {\\n    /// @notice Returns the underlying ERC20 token the strategy accepts.\\n    /// @return The underlying ERC20 token the strategy accepts.\\n    function underlying() external view virtual returns (ERC20);\\n\\n    /// @notice Deposit a specific amount of underlying tokens into the strategy.\\n    /// @param amount The amount of underlying tokens to deposit.\\n    /// @return An error code, or 0 if the deposit was successful.\\n    function mint(uint256 amount) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ETH.\\n/// @dev Designed for out of the box compatibility with Fuse cEther.\\nabstract contract ETHStrategy is Strategy {\\n    /// @notice Deposit a specific amount of ETH into the strategy.\\n    /// @dev The amount of ETH is specified via msg.value. Reverts on error.\\n    function mint() external payable virtual;\\n}\\n\",\"keccak256\":\"0x74641e7bf81f3a8ebbe797d58fd5e7db325ba9999a4e905a2e61f68614dfb50d\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/modules/VaultConfigurationModule.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nimport {Vault} from \\\"../Vault.sol\\\";\\n\\n/// @title Rari Vault Configuration Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for configuring Vault parameters.\\ncontract VaultConfigurationModule is Auth {\\n    /* //////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Creates a Vault configuration module.\\n    /// @param _owner The owner of the module.\\n    /// @param _authority The Authority of the module.\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  DEFAULT VAULT PARAMETER CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when the default fee percentage is updated.\\n    /// @param newDefaultFeePercent The new default fee percentage.\\n    event DefaultFeePercentUpdated(uint256 newDefaultFeePercent);\\n\\n    /// @notice Emitted when the default harvest delay is updated.\\n    /// @param newDefaultHarvestDelay The new default harvest delay.\\n    event DefaultHarvestDelayUpdated(uint64 newDefaultHarvestDelay);\\n\\n    /// @notice Emitted when the default harvest window is updated.\\n    /// @param newDefaultHarvestWindow The new default harvest window.\\n    event DefaultHarvestWindowUpdated(uint128 newDefaultHarvestWindow);\\n\\n    /// @notice Emitted when the default target float percentage is updated.\\n    /// @param newDefaultTargetFloatPercent The new default target float percentage.\\n    event DefaultTargetFloatPercentUpdated(uint256 newDefaultTargetFloatPercent);\\n\\n    /// @notice The default fee percentage for Vaults.\\n    /// @dev See the documentation for the feePercentage\\n    /// variable in the Vault contract for more details.\\n    uint256 public defaultFeePercent;\\n\\n    /// @notice The default harvest delay for Vaults.\\n    /// @dev See the documentation for the harvestDelay\\n    /// variable in the Vault contract for more details.\\n    uint64 public defaultHarvestDelay;\\n\\n    /// @notice The default harvest window for Vaults.\\n    /// @dev See the documentation for the harvestWindow\\n    /// variable in the Vault contract for more details.\\n    uint128 public defaultHarvestWindow;\\n\\n    /// @notice The default target float percentage for Vaults.\\n    /// @dev See the documentation for the targetFloatPercent\\n    /// variable in the Vault contract for more details.\\n    uint256 public defaultTargetFloatPercent;\\n\\n    /// @notice Sets the default fee percentage for Vaults.\\n    /// @param newDefaultFeePercent The new default fee percentage to set.\\n    function setDefaultFeePercent(uint256 newDefaultFeePercent) external requiresAuth {\\n        // Update the default fee percentage.\\n        defaultFeePercent = newDefaultFeePercent;\\n\\n        emit DefaultFeePercentUpdated(newDefaultFeePercent);\\n    }\\n\\n    /// @notice Sets the default harvest delay for Vaults.\\n    /// @param newDefaultHarvestDelay The new default harvest delay to set.\\n    function setDefaultHarvestDelay(uint64 newDefaultHarvestDelay) external requiresAuth {\\n        // Update the default harvest delay.\\n        defaultHarvestDelay = newDefaultHarvestDelay;\\n\\n        emit DefaultHarvestDelayUpdated(newDefaultHarvestDelay);\\n    }\\n\\n    /// @notice Sets the default harvest window for Vaults.\\n    /// @param newDefaultHarvestWindow The new default harvest window to set.\\n    function setDefaultHarvestWindow(uint128 newDefaultHarvestWindow) external requiresAuth {\\n        // Update the default harvest window.\\n        defaultHarvestWindow = newDefaultHarvestWindow;\\n\\n        emit DefaultHarvestWindowUpdated(newDefaultHarvestWindow);\\n    }\\n\\n    /// @notice Sets the default target float percentage for Vaults.\\n    /// @param newDefaultTargetFloatPercent The new default target float percentage to set.\\n    function setDefaultTargetFloatPercent(uint256 newDefaultTargetFloatPercent) external requiresAuth {\\n        // Update the default target float percentage.\\n        defaultTargetFloatPercent = newDefaultTargetFloatPercent;\\n\\n        emit DefaultTargetFloatPercentUpdated(newDefaultTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                  CUSTOM VAULT PARAMETER CONFIGURATION\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Emitted when a Vault has its custom fee percentage set/updated.\\n    /// @param vault The Vault that had its custom fee percentage set/updated.\\n    /// @param newCustomFeePercent The new custom fee percentage for the Vault.\\n    event CustomFeePercentUpdated(Vault indexed vault, uint256 newCustomFeePercent);\\n\\n    /// @notice Emitted when a Vault has its custom harvest delay set/updated.\\n    /// @param vault The Vault that had its custom harvest delay set/updated.\\n    /// @param newCustomHarvestDelay The new custom harvest delay for the Vault.\\n    event CustomHarvestDelayUpdated(Vault indexed vault, uint256 newCustomHarvestDelay);\\n\\n    /// @notice Emitted when a Vault has its custom harvest window set/updated.\\n    /// @param vault The Vault that had its custom harvest window set/updated.\\n    /// @param newCustomHarvestWindow The new custom harvest window for the Vault.\\n    event CustomHarvestWindowUpdated(Vault indexed vault, uint256 newCustomHarvestWindow);\\n\\n    /// @notice Emitted when a Vault has its custom target float percentage set/updated.\\n    /// @param vault The Vault that had its custom target float percentage set/updated.\\n    /// @param newCustomTargetFloatPercent The new custom target float percentage for the Vault.\\n    event CustomTargetFloatPercentUpdated(Vault indexed vault, uint256 newCustomTargetFloatPercent);\\n\\n    /// @notice Maps Vaults to their custom fee percentage.\\n    /// @dev Will be 0 if there is no custom fee percentage for the Vault.\\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\\n    mapping(Vault => uint256) public getVaultCustomFeePercent;\\n\\n    /// @notice Maps Vaults to their custom harvest delay.\\n    /// @dev Will be 0 if there is no custom harvest delay for the Vault.\\n    /// @dev See the documentation for the harvestDelay variable in the Vault contract for more details.\\n    mapping(Vault => uint64) public getVaultCustomHarvestDelay;\\n\\n    /// @notice Maps Vaults to their custom harvest window.\\n    /// @dev Will be 0 if there is no custom harvest window for the Vault.\\n    /// @dev See the documentation for the harvestWindow variable in the Vault contract for more details.\\n    mapping(Vault => uint128) public getVaultCustomHarvestWindow;\\n\\n    /// @notice Maps Vaults to their custom target float percentage.\\n    /// @dev Will be 0 if there is no custom target float percentage for the Vault.\\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\\n    mapping(Vault => uint256) public getVaultCustomTargetFloatPercent;\\n\\n    /// @notice Sets the custom fee percentage for the Vault.\\n    /// @param vault The Vault to set the custom fee percentage for.\\n    /// @param customFeePercent The new custom fee percentage to set.\\n    function setVaultCustomFeePercent(Vault vault, uint256 customFeePercent) external requiresAuth {\\n        // Update the Vault's custom fee percentage.\\n        getVaultCustomFeePercent[vault] = customFeePercent;\\n\\n        emit CustomFeePercentUpdated(vault, customFeePercent);\\n    }\\n\\n    /// @notice Sets the custom harvest delay for the Vault.\\n    /// @param vault The Vault to set the custom harvest delay for.\\n    /// @param customHarvestDelay The new custom harvest delay to set.\\n    function setVaultCustomHarvestDelay(Vault vault, uint64 customHarvestDelay) external requiresAuth {\\n        // Update the Vault's custom harvest delay.\\n        getVaultCustomHarvestDelay[vault] = customHarvestDelay;\\n\\n        emit CustomHarvestDelayUpdated(vault, customHarvestDelay);\\n    }\\n\\n    /// @notice Sets the custom harvest window for the Vault.\\n    /// @param vault The Vault to set the custom harvest window for.\\n    /// @param customHarvestWindow The new custom harvest window to set.\\n    function setVaultCustomHarvestWindow(Vault vault, uint128 customHarvestWindow) external requiresAuth {\\n        // Update the Vault's custom harvest window.\\n        getVaultCustomHarvestWindow[vault] = customHarvestWindow;\\n\\n        emit CustomHarvestWindowUpdated(vault, customHarvestWindow);\\n    }\\n\\n    /// @notice Sets the custom target float percentage for the Vault.\\n    /// @param vault The Vault to set the custom target float percentage for.\\n    /// @param customTargetFloatPercent The new custom target float percentage to set.\\n    function setVaultCustomTargetFloatPercent(Vault vault, uint256 customTargetFloatPercent) external requiresAuth {\\n        // Update the Vault's custom target float percentage.\\n        getVaultCustomTargetFloatPercent[vault] = customTargetFloatPercent;\\n\\n        emit CustomTargetFloatPercentUpdated(vault, customTargetFloatPercent);\\n    }\\n\\n    /* //////////////////////////////////////////////////////////////\\n                       VAULT PARAMETER SYNC LOGIC\\n    ///////////////////////////////////////////////////////////// */\\n\\n    /// @notice Syncs a Vault's fee percentage with either the Vault's custom fee\\n    /// percentage or the default fee percentage if a custom percentage is not set.\\n    /// @param vault The Vault to sync the fee percentage for.\\n    function syncFeePercent(Vault vault) external {\\n        // Get the Vault's custom fee percentage.\\n        uint256 customFeePercent = getVaultCustomFeePercent[vault];\\n\\n        // Determine what the new fee percentage should be for the Vault after the sync.\\n        uint256 newFeePercent = customFeePercent == 0 ? defaultFeePercent : customFeePercent;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.feePercent() != newFeePercent, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's fee percentage to the custom fee percentage\\n        // or the default fee percentage if a custom percentage isn't set.\\n        vault.setFeePercent(newFeePercent);\\n    }\\n\\n    /// @notice Syncs a Vault's harvest delay with either the Vault's custom\\n    /// harvest delay or the default harvest delay if a custom delay is not set.\\n    /// @param vault The Vault to sync the harvest delay for.\\n    function syncHarvestDelay(Vault vault) external {\\n        // Get the Vault's custom harvest delay.\\n        uint64 customHarvestDelay = getVaultCustomHarvestDelay[vault];\\n\\n        // Determine what the new harvest delay should be for the Vault after the sync.\\n        uint64 newHarvestDelay = customHarvestDelay == 0 ? defaultHarvestDelay : customHarvestDelay;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.harvestDelay() != newHarvestDelay, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's harvest delay to the custom harvest delay\\n        // or the default harvest delay if a custom delay isn't set.\\n        vault.setHarvestDelay(newHarvestDelay);\\n    }\\n\\n    /// @notice Syncs a Vault's harvest window with either the Vault's custom\\n    /// harvest window or the default harvest window if a custom window is not set.\\n    /// @param vault The Vault to sync the harvest window for.\\n    function syncHarvestWindow(Vault vault) external {\\n        // Get the Vault's custom harvest window.\\n        uint128 customHarvestWindow = getVaultCustomHarvestWindow[vault];\\n\\n        // Determine what the new harvest window should be for the Vault after the sync.\\n        uint128 newHarvestWindow = customHarvestWindow == 0 ? defaultHarvestWindow : customHarvestWindow;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.harvestWindow() != newHarvestWindow, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's harvest window to the custom harvest window\\n        // or the default harvest window if a custom window isn't set.\\n        vault.setHarvestWindow(newHarvestWindow);\\n    }\\n\\n    /// @notice Syncs a Vault's target float percentage with either the Vault's custom target\\n    /// float percentage or the default target float percentage if a custom percentage is not set.\\n    /// @param vault The Vault to sync the target float percentage for.\\n    function syncTargetFloatPercent(Vault vault) external {\\n        // Get the Vault's custom target float percentage.\\n        uint256 customTargetFloatPercent = getVaultCustomTargetFloatPercent[vault];\\n\\n        // Determine what the new target float percentage should be for the Vault after the sync.\\n        uint256 newTargetFloatPercent = customTargetFloatPercent == 0\\n            ? defaultTargetFloatPercent\\n            : customTargetFloatPercent;\\n\\n        // Prevent spamming as this function requires no authorization.\\n        require(vault.targetFloatPercent() != newTargetFloatPercent, \\\"ALREADY_SYNCED\\\");\\n\\n        // Set the Vault's target float percentage to the custom target float percentage\\n        // or the default target float percentage if a custom percentage isn't set.\\n        vault.setTargetFloatPercent(newTargetFloatPercent);\\n    }\\n}\\n\",\"keccak256\":\"0xf4c566c5314432bd38f1932cfbfccd576e61ec6b26195b495368e33ea016cfc8\",\"license\":\"AGPL-3.0-only\"},\"srcBuild/modules/VaultInitializationModule.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nimport {Vault} from \\\"../Vault.sol\\\";\\nimport {VaultFactory} from \\\"../VaultFactory.sol\\\";\\n\\nimport {VaultConfigurationModule} from \\\"./VaultConfigurationModule.sol\\\";\\n\\n/// @title Rari Vault Initialization Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for initializing newly created Vaults.\\ncontract VaultInitializationModule is Auth {\\n    /// @notice Vault configuration module used to configure Vaults before initialization.\\n    VaultConfigurationModule public configModule;\\n\\n    /// @notice Creates a Vault initialization module.\\n    /// @param _configModule The Vault configuration module the\\n    /// module will use to configure Vaults before initialization.\\n    /// @param _owner The owner of the module.\\n    /// @param _authority The Authority of the module.\\n    constructor(\\n        VaultConfigurationModule _configModule,\\n        address _owner,\\n        Authority _authority\\n    ) Auth(_owner, _authority) {\\n        configModule = _configModule;\\n    }\\n\\n    /// @notice Emitted when the config module is updated.\\n    /// @param newConfigModule The new configuration module.\\n    event ConfigModuleUpdated(VaultConfigurationModule newConfigModule);\\n\\n    /// @notice Sets a new Vault configuration module.\\n    /// @param newConfigModule The Vault configuration module to set.\\n    function setConfigModule(VaultConfigurationModule newConfigModule) external requiresAuth {\\n        // Update the config module.\\n        configModule = newConfigModule;\\n\\n        emit ConfigModuleUpdated(newConfigModule);\\n    }\\n\\n    /// @notice Properly configures and initializes a newly deployed Vault.\\n    /// @dev This will revert if the Vault has already been initialized.\\n    /// @param vault The Vault to configure and initialize.\\n    function initializeVault(Vault vault) external {\\n        // Configure all key parameters.\\n        configModule.syncFeePercent(vault);\\n        configModule.syncHarvestDelay(vault);\\n        configModule.syncHarvestWindow(vault);\\n        configModule.syncTargetFloatPercent(vault);\\n\\n        // Open the Vault up for deposits.\\n        vault.initialize();\\n    }\\n}\\n\",\"keccak256\":\"0x49856b00bb264590ffb5085eb8ebf46db7c947b52f9313d0910813e4a0f1ad97\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506040516107f13803806107f183398101604081905261002f91610103565b600080546001600160a01b03199081166001600160a01b0385811691821784556001805490931690851617909155604051849284929133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d7691a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a35050600280546001600160a01b0319166001600160a01b039490941693909317909255506101509050565b6001600160a01b038116811461010057600080fd5b50565b60008060006060848603121561011857600080fd5b8351610123816100eb565b6020850151909350610134816100eb565b6040850151909250610145816100eb565b809150509250925092565b6106928061015f6000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c80638da5cb5b1161005b5780638da5cb5b146100d9578063ad9ab820146100ec578063bf7e214f146100ff578063ccb6a2701461011257600080fd5b806313af40351461008257806368f1e99a146100975780637a9e5e4b146100c6575b600080fd5b6100956100903660046105e9565b610125565b005b6002546100aa906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b6100956100d43660046105e9565b6101c6565b6000546100aa906001600160a01b031681565b6100956100fa3660046105e9565b6102b0565b6001546100aa906001600160a01b031681565b6100956101203660046105e9565b610355565b61013b336000356001600160e01b031916610527565b61017b5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b60448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6000546001600160a01b031633148061025b575060015460405163b700961360e01b81526001600160a01b039091169063b70096139061021a90339030906001600160e01b0319600035169060040161060d565b602060405180830381865afa158015610237573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025b919061063a565b61026457600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6102c6336000356001600160e01b031916610527565b6103015760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610172565b600280546001600160a01b0319166001600160a01b0383169081179091556040519081527fcc0bfba2fd41fad8e74708649f00db8723ef3361e1e43460f586cf04378035cd9060200160405180910390a150565b6002546040516316f8725960e31b81526001600160a01b0383811660048301529091169063b7c392c890602401600060405180830381600087803b15801561039c57600080fd5b505af11580156103b0573d6000803e3d6000fd5b5050600254604051635607702f60e01b81526001600160a01b0385811660048301529091169250635607702f9150602401600060405180830381600087803b1580156103fb57600080fd5b505af115801561040f573d6000803e3d6000fd5b505060025460405163e7d9934b60e01b81526001600160a01b038581166004830152909116925063e7d9934b9150602401600060405180830381600087803b15801561045a57600080fd5b505af115801561046e573d6000803e3d6000fd5b505060025460405163ac345d0360e01b81526001600160a01b038581166004830152909116925063ac345d039150602401600060405180830381600087803b1580156104b957600080fd5b505af11580156104cd573d6000803e3d6000fd5b50505050806001600160a01b0316638129fc1c6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561050c57600080fd5b505af1158015610520573d6000803e3d6000fd5b5050505050565b6001546000906001600160a01b031680158015906105b1575060405163b700961360e01b81526001600160a01b0382169063b7009613906105709087903090889060040161060d565b602060405180830381865afa15801561058d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b1919061063a565b806105c957506000546001600160a01b038581169116145b949350505050565b6001600160a01b03811681146105e657600080fd5b50565b6000602082840312156105fb57600080fd5b8135610606816105d1565b9392505050565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561064c57600080fd5b8151801515811461060657600080fdfea26469706673582212205e1bb975bd33c1ccdf29dfcb98b6f2d85a6807f590ac740f0c7d1e0c8ed8280864736f6c634300080b0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c80638da5cb5b1161005b5780638da5cb5b146100d9578063ad9ab820146100ec578063bf7e214f146100ff578063ccb6a2701461011257600080fd5b806313af40351461008257806368f1e99a146100975780637a9e5e4b146100c6575b600080fd5b6100956100903660046105e9565b610125565b005b6002546100aa906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b6100956100d43660046105e9565b6101c6565b6000546100aa906001600160a01b031681565b6100956100fa3660046105e9565b6102b0565b6001546100aa906001600160a01b031681565b6100956101203660046105e9565b610355565b61013b336000356001600160e01b031916610527565b61017b5760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b60448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8292fce18fa69edf4db7b94ea2e58241df0ae57f97e0a6c9b29067028bf92d769190a350565b6000546001600160a01b031633148061025b575060015460405163b700961360e01b81526001600160a01b039091169063b70096139061021a90339030906001600160e01b0319600035169060040161060d565b602060405180830381865afa158015610237573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025b919061063a565b61026457600080fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b7638998019890600090a350565b6102c6336000356001600160e01b031916610527565b6103015760405162461bcd60e51b815260206004820152600c60248201526b15539055551213d49256915160a21b6044820152606401610172565b600280546001600160a01b0319166001600160a01b0383169081179091556040519081527fcc0bfba2fd41fad8e74708649f00db8723ef3361e1e43460f586cf04378035cd9060200160405180910390a150565b6002546040516316f8725960e31b81526001600160a01b0383811660048301529091169063b7c392c890602401600060405180830381600087803b15801561039c57600080fd5b505af11580156103b0573d6000803e3d6000fd5b5050600254604051635607702f60e01b81526001600160a01b0385811660048301529091169250635607702f9150602401600060405180830381600087803b1580156103fb57600080fd5b505af115801561040f573d6000803e3d6000fd5b505060025460405163e7d9934b60e01b81526001600160a01b038581166004830152909116925063e7d9934b9150602401600060405180830381600087803b15801561045a57600080fd5b505af115801561046e573d6000803e3d6000fd5b505060025460405163ac345d0360e01b81526001600160a01b038581166004830152909116925063ac345d039150602401600060405180830381600087803b1580156104b957600080fd5b505af11580156104cd573d6000803e3d6000fd5b50505050806001600160a01b0316638129fc1c6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561050c57600080fd5b505af1158015610520573d6000803e3d6000fd5b5050505050565b6001546000906001600160a01b031680158015906105b1575060405163b700961360e01b81526001600160a01b0382169063b7009613906105709087903090889060040161060d565b602060405180830381865afa15801561058d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b1919061063a565b806105c957506000546001600160a01b038581169116145b949350505050565b6001600160a01b03811681146105e657600080fd5b50565b6000602082840312156105fb57600080fd5b8135610606816105d1565b9392505050565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b60006020828403121561064c57600080fd5b8151801515811461060657600080fdfea26469706673582212205e1bb975bd33c1ccdf29dfcb98b6f2d85a6807f590ac740f0c7d1e0c8ed8280864736f6c634300080b0033",
  "devdoc": {
    "author": "Transmissions11 and JetJadeja",
    "events": {
      "ConfigModuleUpdated(address)": {
        "params": {
          "newConfigModule": "The new configuration module."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_authority": "The Authority of the module.",
          "_configModule": "The Vault configuration module the module will use to configure Vaults before initialization.",
          "_owner": "The owner of the module."
        }
      },
      "initializeVault(address)": {
        "details": "This will revert if the Vault has already been initialized.",
        "params": {
          "vault": "The Vault to configure and initialize."
        }
      },
      "setConfigModule(address)": {
        "params": {
          "newConfigModule": "The Vault configuration module to set."
        }
      }
    },
    "title": "Rari Vault Initialization Module",
    "version": 1
  },
  "userdoc": {
    "events": {
      "ConfigModuleUpdated(address)": {
        "notice": "Emitted when the config module is updated."
      }
    },
    "kind": "user",
    "methods": {
      "configModule()": {
        "notice": "Vault configuration module used to configure Vaults before initialization."
      },
      "constructor": {
        "notice": "Creates a Vault initialization module."
      },
      "initializeVault(address)": {
        "notice": "Properly configures and initializes a newly deployed Vault."
      },
      "setConfigModule(address)": {
        "notice": "Sets a new Vault configuration module."
      }
    },
    "notice": "Module for initializing newly created Vaults.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 17,
        "contract": "srcBuild/modules/VaultInitializationModule.sol:VaultInitializationModule",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 20,
        "contract": "srcBuild/modules/VaultInitializationModule.sol:VaultInitializationModule",
        "label": "authority",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Authority)171"
      },
      {
        "astId": 8247,
        "contract": "srcBuild/modules/VaultInitializationModule.sol:VaultInitializationModule",
        "label": "configModule",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(VaultConfigurationModule)8227"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(Authority)171": {
        "encoding": "inplace",
        "label": "contract Authority",
        "numberOfBytes": "20"
      },
      "t_contract(VaultConfigurationModule)8227": {
        "encoding": "inplace",
        "label": "contract VaultConfigurationModule",
        "numberOfBytes": "20"
      }
    }
  }
}