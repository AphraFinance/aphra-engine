{
  "language": "Solidity",
  "sources": {
    "srcBuild/AirdropClaim.sol": {
      "content": "pragma solidity ^0.8.11;\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport { MerkleProof } from \"./MerkleProof.sol\"; // OZ: MerkleProof\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {veAPHRA} from \"./veAPHRA.sol\";\n\ncontract AirdropClaim is Auth {\n\n    /// ============ Immutable storage ============\n\n    bytes32 public immutable merkleRoot;\n\n    veAPHRA public _ve;\n    ERC20 public immutable aphra;\n\n    /// ============ Mutable storage ============\n\n    mapping(address => bool) public hasClaimed;\n\n    error AlreadyClaimed();\n    error NotInMerkle();\n\n    event Claim(address indexed to, uint256 amount);\n    uint internal constant AIRDROP_LOCK = 2 * 365 * 86400;\n\n    constructor(\n        address GOVERNANCE_,\n        bytes32 MERKLE_ROOT_,\n        address veAPHRA_ADDR_\n    ) Auth(GOVERNANCE_, Authority(address(0))) {\n        merkleRoot = MERKLE_ROOT_;\n        _ve = veAPHRA(veAPHRA_ADDR_);\n        aphra = ERC20(_ve.token());\n        aphra.approve(veAPHRA_ADDR_, type(uint).max);\n    }\n\n    //should the ve get updated before the system is crystalized ensure airdrop claimers can get their portion always\n    function setNewVe(address veAPHRA_ADDR_) requiresAuth external {\n        _ve = veAPHRA(veAPHRA_ADDR_);\n        aphra.approve(veAPHRA_ADDR_, type(uint).max);\n    }\n\n    function claim(address to, uint256 amount, bytes32[] calldata proof) external {\n        // Throw if address has already claimed tokens\n        if (hasClaimed[to]) revert AlreadyClaimed();\n\n        // Verify merkle proof, or revert if not in tree\n        bytes32 leaf = keccak256(abi.encodePacked(to, amount));\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\n        if (!isValidLeaf) revert NotInMerkle();\n\n        // Set address to claimed\n        hasClaimed[to] = true;\n\n        // push tokens into veAPHRA lock expiring after 2 years,\n        //congrats on the responsibility\n        _ve.create_lock_for(amount, AIRDROP_LOCK, to);\n\n        // Emit claim event\n        emit Claim(to, amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnerUpdated(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "srcBuild/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "srcBuild/veAPHRA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\n\n/**\n@title Voting Escrow\n@author Curve Finance\n@license MIT\n@notice Votes have a weight depending on time, so that users are\ncommitted to the future of (whatever they are voting for)\n@dev Vote weight decays linearly over time. Lock time cannot be\nmore than `MAXTIME` (4 years).\n\n# Voting escrow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n*/\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n\n/**\n* @dev Interface of the ERC165 standard, as defined in the\n* https://eips.ethereum.org/EIPS/eip-165[EIP].\n*\n* Implementers can declare support of contract interfaces, which can then be\n* queried by others ({ERC165Checker}).\n*\n* For an implementation, see {ERC165}.\n*/\ninterface IERC165 {\n    /**\n    * @dev Returns true if this contract implements the interface defined by\n    * `interfaceId`. See the corresponding\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n    * to learn more about how these ids are created.\n    *\n    * This function call must use less than 30 000 gas.\n    */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n* @dev Required interface of an ERC721 compliant contract.\n*/\ninterface IERC721 is IERC165 {\n    /**\n    * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n    */\n    event Transfer(address indexed from, address indexed to, uint indexed tokenId);\n\n    /**\n    * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n    */\n    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\n\n    /**\n    * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n    */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n    * @dev Returns the number of tokens in ``owner``'s account.\n    */\n    function balanceOf(address owner) external view returns (uint balance);\n\n    /**\n    * @dev Returns the owner of the `tokenId` token.\n    *\n    * Requirements:\n    *\n    * - `tokenId` must exist.\n    */\n    function ownerOf(uint tokenId) external view returns (address owner);\n\n    /**\n    * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n    * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n    *\n    * Requirements:\n    *\n    * - `from` cannot be the zero address.\n    * - `to` cannot be the zero address.\n    * - `tokenId` token must exist and be owned by `from`.\n    * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n    * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    *\n    * Emits a {Transfer} event.\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint tokenId\n    ) external;\n\n    /**\n    * @dev Transfers `tokenId` token from `from` to `to`.\n    *\n    * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n    *\n    * Requirements:\n    *\n    * - `from` cannot be the zero address.\n    * - `to` cannot be the zero address.\n    * - `tokenId` token must be owned by `from`.\n    * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint tokenId\n    ) external;\n\n    /**\n    * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n    * The approval is cleared when the token is transferred.\n    *\n    * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n    *\n    * Requirements:\n    *\n    * - The caller must own the token or be an approved operator.\n    * - `tokenId` must exist.\n    *\n    * Emits an {Approval} event.\n    */\n    function approve(address to, uint tokenId) external;\n\n    /**\n    * @dev Returns the account approved for `tokenId` token.\n    *\n    * Requirements:\n    *\n    * - `tokenId` must exist.\n    */\n    function getApproved(uint tokenId) external view returns (address operator);\n\n    /**\n    * @dev Approve or remove `operator` as an operator for the caller.\n    * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n    *\n    * Requirements:\n    *\n    * - The `operator` cannot be the caller.\n    *\n    * Emits an {ApprovalForAll} event.\n    */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n    * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n    *\n    * See {setApprovalForAll}\n    */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n    * @dev Safely transfers `tokenId` token from `from` to `to`.\n    *\n    * Requirements:\n    *\n    * - `from` cannot be the zero address.\n    * - `to` cannot be the zero address.\n    * - `tokenId` token must exist and be owned by `from`.\n    * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n    * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    *\n    * Emits a {Transfer} event.\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/**\n* @title ERC721 token receiver interface\n* @dev Interface for any contract that wants to support safeTransfers\n* from ERC721 asset contracts.\n*/\ninterface IERC721Receiver {\n    /**\n    * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n    * by `operator` from `from`, this function is called.\n    *\n    * It must return its Solidity selector to confirm the token transfer.\n    * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n    *\n    * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n    */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n* @dev See https://eips.ethereum.org/EIPS/eip-721\n*/\ninterface IERC721Metadata is IERC721 {\n    /**\n    * @dev Returns the token collection name.\n    */\n    function name() external view returns (string memory);\n\n    /**\n    * @dev Returns the token collection symbol.\n    */\n    function symbol() external view returns (string memory);\n\n    /**\n    * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n    */\n    function tokenURI(uint tokenId) external view returns (string memory);\n}\n\n/**\n* @dev Interface of the ERC20 standard as defined in the EIP.\n*/\ninterface IERC20 {\n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\n    * allowance mechanism. `amount` is then deducted from the caller's\n    * allowance.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n}\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint ts;\n        uint blk; // block\n    }\n/* We cannot really do block numbers per se b/c slope is per time, not per block\n* and per block could be fairly bad b/c Ethereum changes blocktimes.\n* What we can do is to extrapolate ***At functions */\n\n    struct LockedBalance {\n        int128 amount;\n        uint end;\n    }\n\ncontract veAPHRA is Auth, IERC721, IERC721Metadata {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    event Deposit(\n        address indexed provider,\n        uint tokenId,\n        uint value,\n        uint indexed locktime,\n        DepositType deposit_type,\n        uint ts\n    );\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\n    event Supply(uint prevSupply, uint supply);\n\n    uint internal constant WEEK = 1 weeks;\n    uint internal constant MAXTIME = 2 * 365 * 86400;\n    int128 internal constant iMAXTIME = 2 * 365 * 86400;\n    uint internal constant MULTIPLIER = 1 ether;\n\n    address immutable public token;\n    uint public supply;\n    mapping(uint => LockedBalance) public locked;\n\n    mapping(uint => uint) public ownership_change;\n\n    uint public epoch;\n    mapping(uint => Point) public point_history; // epoch -> unsigned point\n    mapping(uint => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n    mapping(uint => uint) public user_point_epoch;\n    mapping(uint => int128) public slope_changes; // time -> signed slope change\n\n    mapping(uint => uint) public attachments;\n    mapping(uint => bool) public voted;\n    address public voter;\n\n    string constant public name = \"veAPHRA\";\n    string constant public symbol = \"veAPHRA\";\n    string constant public version = \"1.0.0\";\n    uint8 constant public decimals = 18;\n\n    string public badgeDescription;\n    /// @dev Current count of token\n    uint internal tokenId;\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal idToOwner;\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal ownerToNFTokenCount;\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) internal tokenToOwnerIndex;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    bool internal _unlocked;\n    /// @dev reentrancy guard\n    uint8 internal constant _not_entered = 1;\n    uint8 internal constant _entered = 2;\n    uint8 internal _entered_state = 1;\n    modifier nonreentrant() {\n        require(_entered_state == _not_entered);\n        _entered_state = _entered;\n        _;\n        _entered_state = _not_entered;\n    }\n\n    /// @notice Contract constructor\n    /// @param TOKEN_ADDR_ `ERC20APHRA` token address\n    /// @param GOVERNANCE_ `GOVERNANCE`  address\n    /// @param AUTHORITY_ `Authority`  address\n    constructor(\n        address TOKEN_ADDR_,\n        address GOVERNANCE_,\n        address AUTHORITY_\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_)) {\n        token = TOKEN_ADDR_;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n        _unlocked = false;\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n        badgeDescription = string(\"APHRA Badges, can be used to boost gauge yields, vote on new token emissions, receive protocol bribes and participate in governance\");\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    function isUnlocked() public view returns (bool) {\n        return _unlocked;\n    }\n\n    function setBadgeDescription(string memory _newDescription) requiresAuth external {\n        badgeDescription = _newDescription;\n    }\n\n    //todo setup so that this is hard coded to be veGovernor\n    function unlock() public requiresAuth {\n        require(_unlocked == false, \"unlock already happened\");\n        _unlocked = true;\n    }\n\n    modifier unlocked() {\n        require(_unlocked, \"contract must be unlocked\");\n        _;\n    }\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function get_last_user_slope(uint _tokenId) external view returns (int128) {\n        uint uepoch = user_point_epoch[_tokenId];\n        return user_point_history[_tokenId][uepoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function user_point_history__ts(uint _tokenId, uint _idx) external view returns (uint) {\n        return user_point_history[_tokenId][_idx].ts;\n    }\n\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\n    /// @param _tokenId User NFT\n    /// @return Epoch time of the lock end\n    function locked__end(uint _tokenId) external view returns (uint) {\n        return locked[_tokenId].end;\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view returns (uint) {\n        return _balance(_owner);\n    }\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint _tokenId) public view returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint _tokenId) external view returns (address) {\n        return idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\n        address owner = idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n        uint current_count = _balance(_to);\n\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = current_count;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n        // Delete\n        uint current_count = _balance(_from) - 1;\n        uint current_index = tokenToOwnerIndex[_tokenId];\n\n        if (current_count == current_index) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(address _to, uint _tokenId) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(idToOwner[_tokenId] == address(0));\n        // Change the owner\n        idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _clearApproval(address _owner, uint _tokenId) internal {\n        // Throws if `_owner` is not the current owner\n        assert(idToOwner[_tokenId] == _owner);\n        if (idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            idToApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        address _sender\n    ) internal {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) unlocked external {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        bytes memory _data\n    ) unlocked public {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n\n        if (_isContract(_to)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (\n                bytes memory reason\n            ) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) unlocked external {\n        safeTransferFrom(_from, _to, _tokenId, '');\n    }\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function approve(address _approved, uint _tokenId) unlocked public {\n        address owner = idToOwner[_tokenId];\n        // Throws if `_tokenId` is not a valid NFT\n        require(owner != address(0));\n        // Throws if `_approved` is the current owner\n        require(_approved != owner);\n        // Check requirements\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n        require(senderIsOwner || senderIsApprovedForAll);\n        // Set the approval\n        idToApprovals[_tokenId] = _approved;\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function setApprovalForAll(address _operator, bool _approved) unlocked external {\n        // Throws if `_operator` is the `msg.sender`\n        assert(_operator != msg.sender);\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_to != address(0));\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _addTokenTo(_to, _tokenId);\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param old_locked Pevious locked amount / end lock time for the user\n    /// @param new_locked New locked amount / end lock time for the user\n    function _checkpoint(\n        uint _tokenId,\n        LockedBalance memory old_locked,\n        LockedBalance memory new_locked\n    ) internal {\n        Point memory u_old;\n        Point memory u_new;\n        int128 old_dslope = 0;\n        int128 new_dslope = 0;\n        uint _epoch = epoch;\n\n        if (_tokenId != 0) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\n                u_old.slope = old_locked.amount / iMAXTIME;\n                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\n            }\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\n                u_new.slope = new_locked.amount / iMAXTIME;\n                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // old_locked.end can be in the past and in the future\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            old_dslope = slope_changes[old_locked.end];\n            if (new_locked.end != 0) {\n                if (new_locked.end == old_locked.end) {\n                    new_dslope = old_dslope;\n                } else {\n                    new_dslope = slope_changes[new_locked.end];\n                }\n            }\n        }\n\n        Point memory last_point = Point({bias : 0, slope : 0, ts : block.timestamp, blk : block.number});\n        if (_epoch > 0) {\n            last_point = point_history[_epoch];\n        }\n        uint last_checkpoint = last_point.ts;\n        // initial_last_point is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initial_last_point = last_point;\n        uint block_slope = 0;\n        // dblock/dt\n        if (block.timestamp > last_point.ts) {\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint t_i = (last_checkpoint / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                t_i += WEEK;\n                int128 d_slope = 0;\n                if (t_i > block.timestamp) {\n                    t_i = block.timestamp;\n                } else {\n                    d_slope = slope_changes[t_i];\n                }\n                last_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\n                last_point.slope += d_slope;\n                if (last_point.bias < 0) {\n                    // This can happen\n                    last_point.bias = 0;\n                }\n                if (last_point.slope < 0) {\n                    // This cannot happen - just in case\n                    last_point.slope = 0;\n                }\n                last_checkpoint = t_i;\n                last_point.ts = t_i;\n                last_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\n                _epoch += 1;\n                if (t_i == block.timestamp) {\n                    last_point.blk = block.number;\n                    break;\n                } else {\n                    point_history[_epoch] = last_point;\n                }\n            }\n        }\n\n        epoch = _epoch;\n        // Now point_history is filled until t=now\n\n        if (_tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            last_point.slope += (u_new.slope - u_old.slope);\n            last_point.bias += (u_new.bias - u_old.bias);\n            if (last_point.slope < 0) {\n                last_point.slope = 0;\n            }\n            if (last_point.bias < 0) {\n                last_point.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        point_history[_epoch] = last_point;\n\n        if (_tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (old_locked.end > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                old_dslope += u_old.slope;\n                if (new_locked.end == old_locked.end) {\n                    old_dslope -= u_new.slope;\n                    // It was a new deposit, not extension\n                }\n                slope_changes[old_locked.end] = old_dslope;\n            }\n\n            if (new_locked.end > block.timestamp) {\n                if (new_locked.end > old_locked.end) {\n                    new_dslope -= u_new.slope;\n                    // old slope disappeared at this point\n                    slope_changes[new_locked.end] = new_dslope;\n                }\n                // else: we recorded it already in old_dslope\n            }\n            // Now handle user history\n            uint user_epoch = user_point_epoch[_tokenId] + 1;\n\n            user_point_epoch[_tokenId] = user_epoch;\n            u_new.ts = block.timestamp;\n            u_new.blk = block.number;\n            user_point_history[_tokenId][user_epoch] = u_new;\n        }\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    /// @param locked_balance Previous locked amount / timestamp\n    /// @param deposit_type The type of deposit\n    function _deposit_for(\n        uint _tokenId,\n        uint _value,\n        uint unlock_time,\n        LockedBalance memory locked_balance,\n        DepositType deposit_type\n    ) internal {\n        LockedBalance memory _locked = locked_balance;\n        uint supply_before = supply;\n\n        supply = supply_before + _value;\n        LockedBalance memory old_locked;\n        (old_locked.amount, old_locked.end) = (_locked.amount, _locked.end);\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        _locked.amount += int128(int256(_value));\n        if (unlock_time != 0) {\n            _locked.end = unlock_time;\n        }\n        locked[_tokenId] = _locked;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _checkpoint(_tokenId, old_locked, _locked);\n\n        address from = msg.sender;\n        if (_value != 0 && deposit_type != DepositType.MERGE_TYPE) {\n            assert(IERC20(token).transferFrom(from, address(this), _value));\n        }\n\n        emit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\n        emit Supply(supply_before, supply_before + _value);\n    }\n\n    function setVoter(address _voter) external {\n        require(msg.sender == voter);\n        voter = _voter;\n    }\n\n    function voting(uint _tokenId) external {\n        require(msg.sender == voter);\n        voted[_tokenId] = true;\n    }\n\n    function abstain(uint _tokenId) external {\n        require(msg.sender == voter);\n        voted[_tokenId] = false;\n    }\n\n    function attach(uint _tokenId) external {\n        require(msg.sender == voter);\n        attachments[_tokenId] = attachments[_tokenId] + 1;\n    }\n\n    function detach(uint _tokenId) external {\n        require(msg.sender == voter);\n        attachments[_tokenId] = attachments[_tokenId] - 1;\n    }\n\n    function merge(uint _from, uint _to) unlocked external {\n        require(attachments[_from] == 0 && !voted[_from], \"attached\");\n        require(_from != _to);\n        require(_isApprovedOrOwner(msg.sender, _from));\n        require(_isApprovedOrOwner(msg.sender, _to));\n\n        LockedBalance memory _locked0 = locked[_from];\n        LockedBalance memory _locked1 = locked[_to];\n        uint value0 = uint(int256(_locked0.amount));\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = LockedBalance(0, 0);\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\n        _burn(_from);\n        _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\n    }\n\n    function block_number() external view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external {\n        _checkpoint(0, LockedBalance(0, 0), LockedBalance(0, 0));\n    }\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function deposit_for(uint _tokenId, uint _value) external nonreentrant {\n        LockedBalance memory _locked = locked[_tokenId];\n\n        require(_value > 0);\n        // dev: need non-zero value\n        require(_locked.amount > 0 || !isUnlocked(), 'No existing lock found');\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\n        // Locktime is rounded down to weeks\n\n        require(_value > 0 || !isUnlocked());\n        // dev: need non-zero value\n        require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 2 years max');\n\n        ++tokenId;\n        uint _tokenId = tokenId;\n        _mint(_to, _tokenId);\n\n        _deposit_for(_tokenId, _value, unlock_time, locked[_tokenId], DepositType.CREATE_LOCK_TYPE);\n        return _tokenId;\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, _to);\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    function create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, msg.sender);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increase_amount(uint _tokenId, uint _value) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        LockedBalance memory _locked = locked[_tokenId];\n\n        assert(_value > 0 || !isUnlocked());\n        // dev: need non-zero value\n        require(_locked.amount > 0 || !isUnlocked(), 'No existing lock found');\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _lock_duration New number of seconds until tokens unlock\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        LockedBalance memory _locked = locked[_tokenId];\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\n        // Locktime is rounded down to weeks\n\n        require(_locked.end > block.timestamp, 'Lock expired');\n        require(_locked.amount > 0, 'Nothing is locked');\n        require(unlock_time > _locked.end, 'Can only increase lock duration');\n        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n        _deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\n    }\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint _tokenId) unlocked external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n\n        LockedBalance memory _locked = locked[_tokenId];\n        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n        uint value = uint(int256(_locked.amount));\n\n        locked[_tokenId] = LockedBalance(0, 0);\n        uint supply_before = supply;\n        supply = supply_before - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, _locked, LockedBalance(0, 0));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _burn(_tokenId);\n\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\n        emit Supply(supply_before, supply_before - value);\n    }\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    /// @notice Binary search to estimate timestamp for block number\n    /// @param _block Block to find\n    /// @param max_epoch Don't go beyond this epoch\n    /// @return Approximate timestamp for block\n    function _find_block_epoch(uint _block, uint max_epoch) internal view returns (uint) {\n        // Binary search\n        uint _min = 0;\n        uint _max = max_epoch;\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (point_history[_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    /// @notice Get the current voting power for `_tokenId`\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    /// @param _tokenId NFT for lock\n    /// @param _t Epoch time to return voting power at\n    /// @return User voting power\n    function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\n        uint _epoch = user_point_epoch[_tokenId];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory last_point = user_point_history[_tokenId][_epoch];\n            last_point.bias -= last_point.slope * int128(int256(_t) - int256(last_point.ts));\n            if (last_point.bias < 0) {\n                last_point.bias = 0;\n            }\n            return uint(int256(last_point.bias));\n        }\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function tokenURI(uint _tokenId) external view returns (string memory) {\n        require(idToOwner[_tokenId] != address(0), \"Query for nonexistent token\");\n        LockedBalance memory _locked = locked[_tokenId];\n        return\n        _tokenURI(\n            _tokenId,\n            _balanceOfNFT(_tokenId, block.timestamp),\n            _locked.end,\n            uint(int256(_locked.amount)),\n            badgeDescription\n        );\n    }\n\n    function balanceOfNFT(uint _tokenId) external view returns (uint) {\n        if (ownership_change[_tokenId] == block.number) return 0;\n        return _balanceOfNFT(_tokenId, block.timestamp);\n    }\n\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n        return _balanceOfNFT(_tokenId, _t);\n    }\n\n    /// @notice Measure voting power of `_tokenId` at block height `_block`\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    /// @param _tokenId User's wallet NFT\n    /// @param _block Block to calculate the voting power at\n    /// @return Voting power\n    function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\n        // Copying and pasting totalSupply code because Vyper cannot pass by\n        // reference yet\n        assert(_block <= block.number);\n\n        // Binary search\n        uint _min = 0;\n        uint _max = user_point_epoch[_tokenId];\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (user_point_history[_tokenId][_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n\n        Point memory upoint = user_point_history[_tokenId][_min];\n\n        uint max_epoch = epoch;\n        uint _epoch = _find_block_epoch(_block, max_epoch);\n        Point memory point_0 = point_history[_epoch];\n        uint d_block = 0;\n        uint d_t = 0;\n        if (_epoch < max_epoch) {\n            Point memory point_1 = point_history[_epoch + 1];\n            d_block = point_1.blk - point_0.blk;\n            d_t = point_1.ts - point_0.ts;\n        } else {\n            d_block = block.number - point_0.blk;\n            d_t = block.timestamp - point_0.ts;\n        }\n        uint block_time = point_0.ts;\n        if (d_block != 0) {\n            block_time += (d_t * (_block - point_0.blk)) / d_block;\n        }\n\n        upoint.bias -= upoint.slope * int128(int256(block_time - upoint.ts));\n        if (upoint.bias >= 0) {\n            return uint(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n        return _balanceOfAtNFT(_tokenId, _block);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param point The point (bias/slope) to start search from\n    /// @param t Time to calculate the total voting power at\n    /// @return Total voting power at that time\n    function _supply_at(Point memory point, uint t) internal view returns (uint) {\n        Point memory last_point = point;\n        uint t_i = (last_point.ts / WEEK) * WEEK;\n        for (uint i = 0; i < 255; ++i) {\n            t_i += WEEK;\n            int128 d_slope = 0;\n            if (t_i > t) {\n                t_i = t;\n            } else {\n                d_slope = slope_changes[t_i];\n            }\n            last_point.bias -= last_point.slope * int128(int256(t_i - last_point.ts));\n            if (t_i == t) {\n                break;\n            }\n            last_point.slope += d_slope;\n            last_point.ts = t_i;\n        }\n\n        if (last_point.bias < 0) {\n            last_point.bias = 0;\n        }\n        return uint(uint128(last_point.bias));\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function totalSupplyAtT(uint t) public view returns (uint) {\n        uint _epoch = epoch;\n        Point memory last_point = point_history[_epoch];\n        return _supply_at(last_point, t);\n    }\n\n    function totalSupply() external view returns (uint) {\n        return totalSupplyAtT(block.timestamp);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function totalSupplyAt(uint _block) external view returns (uint) {\n        assert(_block <= block.number);\n        uint _epoch = epoch;\n        uint target_epoch = _find_block_epoch(_block, _epoch);\n\n        Point memory point = point_history[target_epoch];\n        uint dt = 0;\n        if (target_epoch < _epoch) {\n            Point memory point_next = point_history[target_epoch + 1];\n            if (point.blk != point_next.blk) {\n                dt = ((_block - point.blk) * (point_next.ts - point.ts)) / (point_next.blk - point.blk);\n            }\n        } else {\n            if (point.blk != block.number) {\n                dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n            }\n        }\n        // Now dt contains info on how far are we beyond point\n        return _supply_at(point, point.ts + dt);\n    }\n\n    function _tokenURI(uint _tokenId, uint _balanceOf, uint _locked_end, uint _value, string memory description) internal pure returns (string memory output) {\n        output = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\"100%\" height=\"100%\" fill=\"black\" /><text x=\"10\" y=\"20\" class=\"base\">';\n        output = string(abi.encodePacked(output, \"token \", toString(_tokenId), '</text><text x=\"10\" y=\"40\" class=\"base\">'));\n        output = string(abi.encodePacked(output, \"balanceOf \", toString(_balanceOf), '</text><text x=\"10\" y=\"60\" class=\"base\">'));\n        output = string(abi.encodePacked(output, \"locked_end \", toString(_locked_end), '</text><text x=\"10\" y=\"80\" class=\"base\">'));\n        output = string(abi.encodePacked(output, \"value \", toString(_value), '</text></svg>'));\n\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\"name\": \"Badge #', toString(_tokenId), '\", \"description\": \"', description, '\", \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\"}'))));\n        output = string(abi.encodePacked('data:application/json;base64,', json));\n    }\n\n    function toString(uint value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function _burn(uint _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n}\n"
    },
    "srcBuild/vesting/TokenVestingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\nimport {Auth, Authority, ERC20, TokenVesting} from \"./TokenVesting.sol\";\nimport {veAPHRA} from \"../veAPHRA.sol\";\n/**\n * @title TokenVestingFactory\n * @dev A factory to deploy instances of TokenVesting for RSR, nothing more.\n */\ncontract TokenVestingFactory is Auth  {\n\n    event TokenVestingDeployed(address indexed location, address indexed recipient);\n    veAPHRA public _ve;\n    mapping (address => address) public vestingContracts;\n    constructor(\n        address GOVERNANCE_,\n        address VE_APHRA_ADDR_\n    ) Auth (GOVERNANCE_, Authority(address(0))) {\n        _ve = veAPHRA(VE_APHRA_ADDR_);\n    }\n\n    function deployVestingContract(address recipient, uint256 vestForThisManySeconds) requiresAuth external returns (address) {\n\n        TokenVesting vesting = new TokenVesting(\n            recipient,\n            block.timestamp,\n            block.timestamp + vestForThisManySeconds\n        );\n\n        vestingContracts[recipient] = address(vesting);\n\n        emit TokenVestingDeployed(address(vesting), recipient);\n        return address(vesting);\n    }\n\n    function clawbackVesting(ERC20 token, TokenVesting vesting) requiresAuth external {\n        vesting.reclaimUnderlying(token, owner);\n    }\n\n    //should we update ve before unlock switch happens\n    function setVe(address newVEAPHRA_) requiresAuth external {\n        require(!_ve.isUnlocked(), \"veAPHRA has already been unlocked, nothing can be done\");\n        _ve = veAPHRA(newVEAPHRA_);\n    }\n\n    function getVe() external view returns (address) {\n        return address(_ve);\n    }\n\n    function getVestingContract(address benefactor) external view returns (address) {\n        return vestingContracts[benefactor];\n    }\n}\n"
    },
    "srcBuild/vesting/TokenVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\n\ninterface ve {\n    function isUnlocked() external view returns (bool);\n}\n\ninterface IVestingFactory {\n    function getVe() external view returns (address);\n}\n\n/**\n * @title TokenVesting\n * @dev This contract handles the vesting of ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract TokenVesting is Auth {\n    using SafeTransferLib for ERC20;\n\n    event ERC20Released(address indexed token, uint amount);\n\n    mapping(address => uint) private _erc20Released;\n    address private immutable _beneficiary;\n    uint private immutable _start;\n    uint private immutable _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint startTimestamp,\n        uint durationSeconds\n    ) Auth(msg.sender, Authority(address(0))) {\n        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _duration = durationSeconds;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    function reclaimUnderlying(ERC20 token, address destination) external requiresAuth {\n        uint reclaim = token.balanceOf(address(this)) - (vestedAmount(address(token), block.timestamp) - released(address(token)));\n        token.safeTransfer(destination, reclaim);\n    }\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the vesting duration.\n     */\n    function duration() public view virtual returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {TokensReleased} event.\n     */\n    function release(address token) public virtual {\n        uint256 releasable = vestedAmount(token, block.timestamp) - released(token);\n        _erc20Released[token] += releasable;\n        emit ERC20Released(token, releasable);\n        ERC20(token).safeTransfer(beneficiary(), releasable);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(ERC20(token).balanceOf(address(this)) + released(token), timestamp);\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amout vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint timestamp) internal view virtual returns (uint256) {\n\n        if (!ve(IVestingFactory(owner).getVe()).isUnlocked()) {\n            return 0;\n        } else if (timestamp >= start() + duration()) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start())) / duration();\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private reentrancyStatus = 1;\n\n    modifier nonReentrant() {\n        require(reentrancyStatus == 1, \"REENTRANCY\");\n\n        reentrancyStatus = 2;\n\n        _;\n\n        reentrancyStatus = 1;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
    },
    "srcBuild/Voter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nlibrary Math {\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n}\n\ninterface IListingFee {\n    function listing_fee() external view returns (uint);\n}\n\ninterface erc20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}\n\ninterface ve {\n    function token() external view returns (address);\n    function balanceOfNFT(uint) external view returns (uint);\n    function isApprovedOrOwner(address, uint) external view returns (bool);\n    function ownerOf(uint) external view returns (address);\n    function transferFrom(address, address, uint) external;\n    function attach(uint tokenId) external;\n    function detach(uint tokenId) external;\n    function voting(uint tokenId) external;\n    function abstain(uint tokenId) external;\n}\n\ninterface GaugeFactory {\n    function createGauge(address, address, address) external returns (address);\n}\n\ninterface BribeFactory {\n    function createBribe() external returns (address);\n}\n\ninterface IGauge {\n    function notifyRewardAmount(address token, uint amount) external;\n    function stopDeposits() external;\n    function openDeposits() external;\n    function isDepositsOpen() external view returns (bool);\n    function getReward(address account, address[] memory tokens) external;\n    function left(address token) external view returns (uint);\n}\n\ninterface IBribe {\n    function _deposit(uint amount, uint tokenId) external;\n    function _withdraw(uint amount, uint tokenId) external;\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\n}\n\ninterface IMinter {\n    function update_period() external returns (uint);\n}\n\ncontract Voter is Auth {\n\n    address public immutable _ve; // the ve token that governs these contracts\n    address internal immutable base;\n    address internal listingLP; //deprecated before it even began\n    address internal listingFeeAddr; //deprecated before it even began\n    address public immutable gaugefactory;\n    address public immutable bribefactory;\n    uint internal constant DURATION = 7 days; // rewards are released over 7 days\n    address public minter;\n    bool public openListing;\n    uint public totalWeight; // total voting weight\n\n    address[] public assets; // all assets viable for incentives\n    mapping(address => address) public gauges; // asset => gauge\n    mapping(address => address) public assetForGauge; // gauge => asset\n    mapping(address => address) public bribes; // gauge => bribe\n    mapping(address => int256) public weights; // pool => weight\n    mapping(uint => mapping(address => int256)) public votes; // nft => asset => votes\n    mapping(uint => address[]) public assetVote; // nft => assets\n    mapping(uint => uint) public usedWeights;  // nft => total voting weight of user\n    mapping(address => bool) public isGauge;\n    mapping(address => bool) public isWhitelisted;\n\n    event GaugeCreated(address indexed gauge, address creator, address indexed bribe, address indexed pool);\n    event Voted(address indexed voter, uint tokenId, int256 weight);\n    event Abstained(uint tokenId, int256 weight);\n    event Deposit(address indexed lp, address indexed gauge, uint tokenId, uint amount);\n    event Withdraw(address indexed lp, address indexed gauge, uint tokenId, uint amount);\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\n    event Whitelisted(address indexed whitelister, address indexed token);\n    event DeListed(address indexed delister, address indexed token);\n\n    constructor(\n        address _guardian,\n        address _authority,\n        address __ve,\n        address _gauges,\n        address _bribes\n    ) Auth(_guardian, Authority(_authority)) {\n        _ve = __ve;\n        base = ve(__ve).token();\n        gaugefactory = _gauges;\n        bribefactory = _bribes;\n        minter = msg.sender;\n        openListing = false;\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function initialize(address[] memory _tokens, address _minter) external {\n        require(msg.sender == minter);\n        for (uint i = 0; i < _tokens.length; i++) {\n            _whitelist(_tokens[i]);\n        }\n        minter = _minter;\n    }\n\n    function setListingFeeAddress(address listingFeeAddress_) external requiresAuth {\n        listingFeeAddr = listingFeeAddress_;\n    }\n\n    function listing_fee() public view returns (uint) {\n        return IListingFee(listingFeeAddr).listing_fee();\n    }\n\n    function reset(uint _tokenId) external {\n        require(ve(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        _reset(_tokenId);\n        ve(_ve).abstain(_tokenId);\n    }\n\n    function _reset(uint _tokenId) internal {\n        address[] storage _assetVote = assetVote[_tokenId];\n        uint _assetVoteCnt = _assetVote.length;\n        int256 _totalWeight = 0;\n\n        for (uint i = 0; i < _assetVoteCnt; i ++) {\n            address _asset = _assetVote[i];\n            int256 _votes = votes[_tokenId][_asset];\n\n            if (_votes != 0) {\n                _updateFor(gauges[_asset]);\n                weights[_asset] -= _votes;\n                votes[_tokenId][_asset] -= _votes;\n                if (_votes > 0) {\n                    IBribe(bribes[gauges[_asset]])._withdraw(uint256(_votes), _tokenId);\n                    _totalWeight += _votes;\n                } else {\n                    _totalWeight -= _votes;\n                }\n                emit Abstained(_tokenId, _votes);\n            }\n        }\n        totalWeight -= uint256(_totalWeight);\n        usedWeights[_tokenId] = 0;\n        delete assetVote[_tokenId];\n    }\n\n    function poke(uint _tokenId) external {\n        address[] memory _assetVote = assetVote[_tokenId];\n        uint _assetCnt = _assetVote.length;\n        int256[] memory _weights = new int256[](_assetCnt);\n\n        for (uint i = 0; i < _assetCnt; i ++) {\n            _weights[i] = votes[_tokenId][_assetVote[i]];\n        }\n\n        _vote(_tokenId, _assetVote, _weights);\n    }\n\n    function _vote(uint _tokenId, address[] memory _assetVote, int256[] memory _weights) internal {\n        _reset(_tokenId);\n        uint _assetCnt = _assetVote.length;\n        int256 _weight = int256(ve(_ve).balanceOfNFT(_tokenId));\n        int256 _totalVoteWeight = 0;\n        int256 _totalWeight = 0;\n        int256 _usedWeight = 0;\n\n        for (uint i = 0; i < _assetCnt; i++) {\n            _totalVoteWeight += _weights[i] > 0 ? _weights[i] : -_weights[i];\n        }\n\n        for (uint i = 0; i < _assetCnt; i++) {\n            address _asset = _assetVote[i];\n            address _gauge = gauges[_asset];\n\n            if (isGauge[_gauge] && IGauge(_gauge).isDepositsOpen()) {\n                int256 _assetWeight = _weights[i] * _weight / _totalVoteWeight;\n                require(votes[_tokenId][_asset] == 0);\n                require(_assetWeight != 0);\n                _updateFor(_gauge);\n\n                assetVote[_tokenId].push(_asset);\n\n                weights[_asset] += _assetWeight;\n                votes[_tokenId][_asset] += _assetWeight;\n                if (_assetWeight > 0) {\n                    IBribe(bribes[_gauge])._deposit(uint256(_assetWeight), _tokenId);\n                } else {\n                    _assetWeight = -_assetWeight;\n                }\n                _usedWeight += _assetWeight;\n                _totalWeight += _assetWeight;\n                emit Voted(msg.sender, _tokenId, _assetWeight);\n            }\n        }\n        if (_usedWeight > 0) ve(_ve).voting(_tokenId);\n        totalWeight += uint256(_totalWeight);\n        usedWeights[_tokenId] = uint256(_usedWeight);\n    }\n\n    function vote(uint tokenId, address[] calldata _assetVote, int256[] calldata _weights) external {\n        require(ve(_ve).isApprovedOrOwner(msg.sender, tokenId));\n        require(_assetVote.length == _weights.length);\n        _vote(tokenId, _assetVote, _weights);\n    }\n\n    function gaugeStopDeposits(address _gauge) external requiresAuth {\n        IGauge(_gauge).stopDeposits();\n    }\n\n    function gaugeOpenDeposits(address _gauge) external requiresAuth {\n        IGauge(_gauge).openDeposits();\n    }\n\n    function whitelist(address _token) external {\n        require(openListing, \"not open for general listing\");\n\n        _safeTransferFrom(listingLP, owner, minter, listing_fee());\n\n        _whitelist(_token);\n    }\n\n    function enableOpenListing() external requiresAuth {\n        openListing = true;\n    }\n\n    function disableOpenListing() external requiresAuth {\n        openListing = false;\n    }\n\n    function removeListing(address _token) external requiresAuth {\n        _removeListing(_token);\n    }\n\n    function whitelistAsAuth(address _token) external requiresAuth {\n        _whitelist(_token);\n    }\n\n    function _removeListing(address _token) internal {\n        require(isWhitelisted[_token]);\n        isWhitelisted[_token] = false;\n        emit DeListed(msg.sender, _token);\n    }\n\n    function _whitelist(address _token) internal {\n        require(!isWhitelisted[_token]);\n        isWhitelisted[_token] = true;\n        emit Whitelisted(msg.sender, _token);\n    }\n\n    function createGauge(address _asset) external returns (address) {\n        require(gauges[_asset] == address(0x0), \"exists\");\n        require(isWhitelisted[_asset], \"!whitelisted\");\n        address _bribe = BribeFactory(bribefactory).createBribe();\n        address _gauge = GaugeFactory(gaugefactory).createGauge(_asset, _bribe, _ve);\n        erc20(base).approve(_gauge, type(uint).max);\n        bribes[_gauge] = _bribe;\n        gauges[_asset] = _gauge;\n        assetForGauge[_gauge] = _asset;\n        isGauge[_gauge] = true;\n        IGauge(_gauge).openDeposits();\n        _updateFor(_gauge);\n        assets.push(_asset);\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _asset);\n        return _gauge;\n    }\n\n    function attachTokenToGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        if (tokenId > 0) ve(_ve).attach(tokenId);\n        emit Attach(account, msg.sender, tokenId);\n    }\n\n    function emitDeposit(uint tokenId, address account, uint amount) external {\n        require(isGauge[msg.sender]);\n        emit Deposit(account, msg.sender, tokenId, amount);\n    }\n\n    function detachTokenFromGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        if (tokenId > 0) ve(_ve).detach(tokenId);\n        emit Detach(account, msg.sender, tokenId);\n    }\n\n    function emitWithdraw(uint tokenId, address account, uint amount) external {\n        require(isGauge[msg.sender]);\n        emit Withdraw(account, msg.sender, tokenId, amount);\n    }\n\n    function length() external view returns (uint) {\n        return assets.length;\n    }\n\n    uint internal index;\n    mapping(address => uint) internal supplyIndex;\n    mapping(address => uint) public claimable;\n\n    function notifyRewardAmount(uint amount) external {\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\n        uint256 _ratio = amount * 1e18 / totalWeight; // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n        emit NotifyReward(msg.sender, base, amount);\n    }\n\n    function updateFor(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            _updateFor(_gauges[i]);\n        }\n    }\n\n    function updateForRange(uint start, uint end) public {\n        for (uint i = start; i < end; i++) {\n            _updateFor(gauges[assets[i]]);\n        }\n    }\n\n    function updateAll() external {\n        updateForRange(0, assets.length);\n    }\n\n    function updateGauge(address _gauge) external {\n        _updateFor(_gauge);\n    }\n\n    function _updateFor(address _gauge) internal {\n        address _asset = assetForGauge[_gauge];\n        int256 _supplied = weights[_asset];\n        if (_supplied > 0) {\n            uint _supplyIndex = supplyIndex[_gauge];\n            uint _index = index; // get global index0 for accumulated distro\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\n            uint _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\n            if (_delta > 0) {\n                uint _share = uint(_supplied) * _delta / 1e18; // add accrued difference for each supplied token\n                claimable[_gauge] += _share;\n            }\n        } else {\n            supplyIndex[_gauge] = index; // new users are set to the default global state\n        }\n    }\n\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\n        }\n    }\n\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\n        require(ve(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    function distribute(address _gauge) public lock {\n        IMinter(minter).update_period();\n        _updateFor(_gauge);\n        uint _claimable = claimable[_gauge];\n        if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\n            claimable[_gauge] = 0;\n            IGauge(_gauge).notifyRewardAmount(base, _claimable);\n            emit DistributeReward(msg.sender, _gauge, _claimable);\n        }\n    }\n\n    function distro() external {\n        distribute(0, assets.length);\n    }\n\n    function distribute() external {\n        distribute(0, assets.length);\n    }\n\n    function distribute(uint start, uint finish) public {\n        for (uint x = start; x < finish; x++) {\n            distribute(gauges[assets[x]]);\n        }\n    }\n\n    function distribute(address[] memory _gauges) external {\n        for (uint x = 0; x < _gauges.length; x++) {\n            distribute(_gauges[x]);\n        }\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n"
    },
    "srcBuild/strategies/USDVUnderPegStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"../FixedPointMathLib.sol\"; //added fdiv and fmul TODO: looking at new rari/next code perhaps we're moving to a new library\nimport {ERC20Strategy} from \"../interfaces/Strategy.sol\";\nimport {VaderGateway, IVaderMinter} from \"../VaderGateway.sol\";\nimport {IERC20, IUniswap, IXVader, ICurve} from \"../interfaces/StrategyInterfaces.sol\";\n\ncontract USDVUnderPegStrategy is Auth, ERC20(\"USDVUnderPegStrategy\", \"aUSDVUnderPegStrategy\", 18), ERC20Strategy {\n\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    ERC20 public constant DAI = ERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F));  //our flip\n    ERC20 public constant USDC = ERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)); //our flap\n    ERC20 public constant USDT = ERC20(address(0xdAC17F958D2ee523a2206206994597C13D831ec7)); //our flop\n    ERC20 public constant USDV = ERC20(address(0xea3Fb6f331735252E7Bfb0b24b3B761301293DBe));\n\n    ERC20 public immutable WETH;\n    ICurve public immutable POOL;\n    IUniswap public immutable UNISWAP;\n    IXVader public immutable XVADER;\n    IVaderMinter public immutable VADERGATEWAY;\n\n    constructor(\n        ERC20 UNDERLYING_,\n        address GOVERNANCE_,\n        Authority AUTHORITY_,\n        address POOL_,\n        address XVADER_,\n        address VADERGATEWAY_,\n        address UNIROUTER_,\n        address WETH_\n    ) Auth(GOVERNANCE_, AUTHORITY_) { //set authority to something that enables operators for aphra\n        UNDERLYING = UNDERLYING_; //vader\n        BASE_UNIT = 10**UNDERLYING_.decimals();\n\n        POOL = ICurve(POOL_);\n        XVADER = IXVader(XVADER_);\n\n        VADERGATEWAY = IVaderMinter(VADERGATEWAY_); // our partner minter\n        UNISWAP = IUniswap(UNIROUTER_);\n        WETH = ERC20(WETH_);\n\n        USDV.safeApprove(POOL_, type(uint256).max); //set unlimited approval to the pool for usdv\n        DAI.safeApprove(UNIROUTER_, type(uint256).max);\n        USDC.safeApprove(UNIROUTER_, type(uint256).max);\n        USDT.safeApprove(UNIROUTER_, type(uint256).max);\n        WETH.safeApprove(UNIROUTER_, type(uint256).max); //prob not needed\n        UNDERLYING.safeApprove(XVADER_, type(uint256).max);\n        UNDERLYING.safeApprove(VADERGATEWAY_, type(uint256).max);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                             STRATEGY LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n\n    function hit(uint256 uAmount_, int128 enterCoin_, address[] memory path_) external requiresAuth () {\n        uint vAmount = VADERGATEWAY.partnerBurn(uAmount_, uint(1));\n        uint uAmount = _swapToUnderlying(vAmount, enterCoin_, path_);\n        require(uAmount > uAmount_, \"Failed to arb for profit\");\n    unchecked {\n        require( POOL.balances(1) * 1e3 / (POOL.balances(0)) <= 1e3, \"peg must be at or below 1\");\n    }\n    }\n\n    function isCEther() external pure override returns (bool) {\n        return false;\n    }\n\n    function ethToUnderlying(uint256 ethAmount_) external view returns (uint256) {\n        if (ethAmount_ == 0) {\n            return 0;\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(WETH);\n        path[1] = address(UNDERLYING);\n        uint256[] memory amounts = UNISWAP.getAmountsOut(ethAmount_, path);\n\n        return amounts[amounts.length - 1];\n    }\n\n    function underlying() external view override returns (ERC20) {\n        return UNDERLYING;\n    }\n\n    function mint(uint256 amount) external requiresAuth override returns (uint256) {\n        _mint(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), amount);\n        return 0;\n    }\n\n    function redeemUnderlying(uint256 amount) external override returns (uint256) {\n        _burn(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\n\n        UNDERLYING.safeTransfer(msg.sender, amount);\n\n        return 0;\n    }\n\n    function balanceOfUnderlying(address user) external view override returns (uint256) {\n        return balanceOf[user].fmul(_exchangeRate(), BASE_UNIT);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            INTERNAL LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    ERC20 internal immutable UNDERLYING;\n\n    uint256 internal immutable BASE_UNIT;\n\n\n    function _swapToUnderlying(uint vAmountIn_, int128 enterCoin_, address[] memory path_) internal returns (uint oAmount) {\n\n\n        //we have vader, we want to get usdv, so we need dai/usdc/usdt first\n\n        //get best exit address\n        //get mins for swap\n\n        address enterCoinAddress = address(DAI);\n        if (enterCoin_ == int128(2)) {\n            enterCoinAddress = address(USDC);\n        } else if (enterCoin_ == int128(3)) {\n            enterCoinAddress = address(USDT);\n        }\n\n\n        address[] memory path;\n        if(path_.length == 0) {\n            path = new address[](3);\n            path[0] = address(UNDERLYING);\n            path[1] = address(WETH);\n            path[2] = enterCoinAddress; //vader eth pool has the best depth for vader\n        } else {\n            path = path_;\n        }\n\n        uint256[] memory amounts = UNISWAP.getAmountsOut(vAmountIn_, path);\n        uint256 swapOut = amounts[amounts.length - 1];\n\n        UNISWAP.swapExactTokensForTokens(\n            vAmountIn_,\n            swapOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n        uint256 usdvBalanceBefore;\n        unchecked {\n            usdvBalanceBefore = USDV.balanceOf(address(this));\n        }\n\n        POOL.exchange_underlying(enterCoin_, int128(0), swapOut, uint(1));\n\n        unchecked {\n            oAmount = USDV.balanceOf(address(this)) - usdvBalanceBefore;\n        }\n\n    }\n\n    function _exchangeRate() internal view returns (uint256) {\n        uint256 cTokenSupply = totalSupply;\n\n        if (cTokenSupply == 0) return BASE_UNIT;\n        uint underlyingBalance;\n        unchecked {\n            underlyingBalance = UNDERLYING.balanceOf(address(this));\n        }\n        return underlyingBalance.fdiv(cTokenSupply, BASE_UNIT);\n    }\n}\n\n"
    },
    "@rari-capital/solmate/src/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x <= type(uint248).max);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x <= type(uint128).max);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x <= type(uint96).max);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x <= type(uint64).max);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x <= type(uint32).max);\n\n        y = uint32(x);\n    }\n}\n"
    },
    "srcBuild/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /* ///////////////////////////////////////////////////////////////\n    SIMPLIFIED FIXED POINT OPERATIONS\n    ////////////////////////////////////////////////////////////// */\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD);\n        // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD);\n        // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y);\n        // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y);\n        // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n    function fmul(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256 z) {\n        assembly {\n        // Store x * y in z for now.\n            z := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\n                revert(0, 0)\n            }\n\n        // If baseUnit is zero this will return zero instead of reverting.\n            z := div(z, baseUnit)\n        }\n    }\n\n    function fdiv(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256 z) {\n        assembly {\n        // Store x * baseUnit in z for now.\n            z := mul(x, baseUnit)\n\n        // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\n                revert(0, 0)\n            }\n\n        // We ensure y is not zero above, so there is never division by zero here.\n            z := div(z, y)\n        }\n    }\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n        // Store x * y in z for now.\n            z := mul(x, y)\n\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n        // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n        // Store x * y in z for now.\n            z := mul(x, y)\n\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n        // First, divide z - 1 by the denominator and add 1.\n        // Then multiply it by 0 if z is zero, or 1 otherwise.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                // 0 ** 0 = 1\n                    z := denominator\n                }\n                default {\n                // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                // If n is even, store denominator in z for now.\n                    z := denominator\n                }\n                default {\n                // If n is odd, store x in z for now.\n                    z := x\n                }\n\n            // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, denominator)\n\n                for {\n                // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                // Revert immediately if x ** 2 would overflow.\n                // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                // Store x squared.\n                    let xx := mul(x, x)\n\n                // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                // Set x to scaled xxRound.\n                    x := div(xxRound, denominator)\n\n                // If n is even:\n                    if mod(n, 2) {\n                    // Compute z * x.\n                        let zx := mul(z, x)\n\n                    // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                        // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                    // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                    // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                    // Return properly scaled zxRound.\n                        z := div(zxRound, denominator)\n                    }\n                }\n            }\n        }\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n    GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n        // Start off with z at 1.\n            z := 1\n\n        // Used below to help find a nearby power of 2.\n            let y := x\n\n        // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z)\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z)\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z)\n            }\n            if iszero(lt(y, 0x8)) {\n            // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n        // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n        // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n        // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "srcBuild/interfaces/Strategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\n/// @notice Minimal interface for Vault compatible strategies.\n/// @dev Designed for out of the box compatibility with Fuse cTokens.\n/// @dev Like cTokens, strategies must be transferrable ERC20s.\nabstract contract Strategy is ERC20 {\n    /// @notice Returns whether the strategy accepts ETH or an ERC20.\n    /// @return True if the strategy accepts ETH, false otherwise.\n    /// @dev Only present in Fuse cTokens, not Compound cTokens.\n    function isCEther() external view virtual returns (bool);\n\n    /// @notice Withdraws a specific amount of underlying tokens from the strategy.\n    /// @param amount The amount of underlying tokens to withdraw.\n    /// @return An error code, or 0 if the withdrawal was successful.\n    function redeemUnderlying(uint256 amount) external virtual returns (uint256);\n\n    /// @notice Returns a user's strategy balance in underlying tokens.\n    /// @param user The user to get the underlying balance of.\n    /// @return The user's strategy balance in underlying tokens.\n    /// @dev May mutate the state of the strategy by accruing interest.\n    function balanceOfUnderlying(address user) external virtual returns (uint256);\n}\n\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\n/// @dev Designed for out of the box compatibility with Fuse cERC20s.\nabstract contract ERC20Strategy is Strategy {\n    /// @notice Returns the underlying ERC20 token the strategy accepts.\n    /// @return The underlying ERC20 token the strategy accepts.\n    function underlying() external view virtual returns (ERC20);\n\n    /// @notice Deposit a specific amount of underlying tokens into the strategy.\n    /// @param amount The amount of underlying tokens to deposit.\n    /// @return An error code, or 0 if the deposit was successful.\n    function mint(uint256 amount) external virtual returns (uint256);\n}\n\n/// @notice Minimal interface for Vault strategies that accept ETH.\n/// @dev Designed for out of the box compatibility with Fuse cEther.\nabstract contract ETHStrategy is Strategy {\n    /// @notice Deposit a specific amount of ETH into the strategy.\n    /// @dev The amount of ETH is specified via msg.value. Reverts on error.\n    function mint() external payable virtual;\n}\n"
    },
    "srcBuild/VaderGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {IVaderMinter} from \"./interfaces/vader/IVaderMinter.sol\";\n\ncontract VaderGateway is Auth, IVaderMinter {\n\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n\n    IVaderMinter public immutable VADERMINTER;\n\n    ERC20 public immutable VADER;\n    ERC20 public immutable USDV;\n\n    constructor(\n        address VADERMINTER_,\n        address GOVERNANCE_,\n        Authority AUTHORITY_,\n        address VADER_,\n        address USDV_\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_))\n    {\n        VADERMINTER = IVaderMinter(VADERMINTER_);\n        VADER = ERC20(VADER_);\n        USDV = ERC20(USDV_);\n\n        //set approvals\n        VADER.safeApprove(VADERMINTER_, type(uint256).max);\n        VADER.safeApprove(address(USDV), type(uint256).max);\n        USDV.safeApprove(VADERMINTER_, type(uint256).max);\n    }\n\n\n    function lbt() external view returns (address) {\n        return VADERMINTER.lbt();\n    }\n\n    // The 24 hour limits on USDV mints that are available for public minting and burning as well as the fee.\n    function dailyLimits() external view returns (Limits memory) {\n        return VADERMINTER.dailyLimits();\n    }\n\n    // The current cycle end timestamp\n    function cycleTimestamp() external view returns (uint) {\n        return VADERMINTER.cycleTimestamp();\n    }\n\n    // The current cycle cumulative mints\n    function cycleMints() external view returns (uint) {\n        return VADERMINTER.cycleMints();\n    }\n\n    // The current cycle cumulative burns\n    function cycleBurns() external view returns (uint){\n        return VADERMINTER.cycleBurns();\n    }\n\n    function partnerLimits(address partner) external view returns (Limits memory){\n        return VADERMINTER.partnerLimits(partner);\n    }\n\n    // USDV Contract for Mint / Burn Operations\n    function usdv() external view returns (address) {\n        return VADERMINTER.usdv();\n    }\n\n    /*\n     * @dev Partner mint function that receives Vader and mints USDV.\n     * @param vAmount Vader amount to burn.\n     * @returns uAmount in USDV, represents the USDV amount received from the mint.\n     *\n     * Requirements:\n     * - Can only be called by whitelisted partners.\n     **/\n    function partnerMint(uint256 vAmount, uint256 uMinOut) external requiresAuth returns (uint256 uAmount) {\n        VADER.transferFrom(msg.sender, address(this), vAmount);\n\n        uAmount = VADERMINTER.partnerMint(vAmount, uMinOut);\n\n        USDV.safeTransfer(msg.sender, uAmount);\n    }\n    /*\n     * @dev Partner burn function that receives USDV and mints Vader.\n     * @param uAmount USDV amount to burn.\n     * @returns vAmount in Vader, represents the Vader amount received from the mint.\n     *\n     * Requirements:\n     * - Can only be called by whitelisted partners.\n     **/\n    function partnerBurn(uint256 uAmount, uint256 vMinOut) external requiresAuth returns (uint256 vAmount) {\n        USDV.transferFrom(msg.sender, address(this), uAmount);\n        vAmount = VADERMINTER.partnerBurn(uAmount, vMinOut);\n        VADER.safeTransfer(msg.sender, vAmount);\n    }\n\n}\n"
    },
    "srcBuild/interfaces/StrategyInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ninterface IUniswap {\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function getAmountsIn(\n        uint amountOut,\n        address[] memory path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsOut(\n        uint amountIn,\n        address[] memory path\n    ) external view returns (uint[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n}\n\ninterface ICurve {\n    function get_virtual_price() external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function balances(uint256) external view returns (uint256);\n}\n\ninterface IXVader is IERC20 {\n    function enter(uint256 amount) external;\n    function leave(uint256 share) external;\n}\n"
    },
    "@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*///////////////////////////////////////////////////////////////\n                            COMMON BASE UNITS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant YAD = 1e8;\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant RAD = 1e45;\n\n    /*///////////////////////////////////////////////////////////////\n                         FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function fmul(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(x == 0 || (x * y) / x == y)\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\n                revert(0, 0)\n            }\n\n            // If baseUnit is zero this will return zero instead of reverting.\n            z := div(z, baseUnit)\n        }\n    }\n\n    function fdiv(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * baseUnit in z for now.\n            z := mul(x, baseUnit)\n\n            // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\n                revert(0, 0)\n            }\n\n            // We ensure y is not zero above, so there is never division by zero here.\n            z := div(z, y)\n        }\n    }\n\n    function fpow(\n        uint256 x,\n        uint256 n,\n        uint256 baseUnit\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := baseUnit\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store baseUnit in z for now.\n                    z := baseUnit\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, baseUnit)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, baseUnit)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, baseUnit)\n                    }\n                }\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z)\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z)\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z)\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "srcBuild/interfaces/vader/IVaderMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ninterface IVaderMinter {\n    struct Limits {\n        uint256 fee;\n        uint256 mintLimit;\n        uint256 burnLimit;\n    }\n\n    event PublicMintCapChanged(\n        uint256 previousPublicMintCap,\n        uint256 publicMintCap\n    );\n\n    event PublicMintFeeChanged(\n        uint256 previousPublicMintFee,\n        uint256 publicMintFee\n    );\n\n    event PartnerMintCapChanged(\n        uint256 previousPartnerMintCap,\n        uint256 partnerMintCap\n    );\n\n    event PartnerMintFeeChanged(\n        uint256 previousPartnercMintFee,\n        uint256 partnerMintFee\n    );\n\n    event DailyLimitsChanged(Limits previousLimits, Limits nextLimits);\n    event WhitelistPartner(\n        address partner,\n        uint256 mintLimit,\n        uint256 burnLimit,\n        uint256 fee\n    );\n\n    function lbt() external view returns (address);\n\n    // The 24 hour limits on USDV mints that are available for public minting and burning as well as the fee.\n    function dailyLimits() external view returns (Limits memory);\n\n    // The current cycle end timestamp\n    function cycleTimestamp() external view returns (uint);\n\n    // The current cycle cumulative mints\n    function cycleMints() external view returns (uint);\n\n    // The current cycle cumulative burns\n    function cycleBurns() external view returns (uint);\n\n    function partnerLimits(address) external view returns (Limits memory);\n\n    // USDV Contract for Mint / Burn Operations\n    function usdv() external view returns (address);\n\n    function partnerMint(uint256 vAmount, uint256 uAmountMinOut) external returns (uint256 uAmount);\n\n    function partnerBurn(uint256 uAmount, uint256 vAmountMinOut) external returns (uint256 vAmount);\n}\n"
    },
    "srcBuild/strategies/USDVOverPegStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"../FixedPointMathLib.sol\";\nimport {ERC20Strategy} from \"../interfaces/Strategy.sol\";\nimport {VaderGateway, IVaderMinter} from \"../VaderGateway.sol\";\nimport {IERC20, IUniswap, IXVader, ICurve} from \"../interfaces/StrategyInterfaces.sol\";\n\ncontract USDVOverPegStrategy is Auth, ERC20(\"USDVOverPegStrategy\", \"aUSDVOverPegStrategy\", 18), ERC20Strategy {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    ERC20 public constant DAI = ERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F));  //our flip\n    ERC20 public constant USDC = ERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)); //our flap\n    ERC20 public constant USDT = ERC20(address(0xdAC17F958D2ee523a2206206994597C13D831ec7)); //our flop\n    ERC20 public constant USDV = ERC20(address(0xea3Fb6f331735252E7Bfb0b24b3B761301293DBe));\n\n    ERC20 public immutable WETH;\n    ICurve public immutable POOL;\n    IUniswap public immutable UNISWAP;\n    IXVader public immutable XVADER;\n    IVaderMinter public immutable VADERGATEWAY;\n\n    constructor(\n        ERC20 UNDERLYING_,\n        address GOVERNANCE_,\n        Authority AUTHORITY_,\n        address POOL_,\n        address XVADER_,\n        address VADERGATEWAY_,\n        address UNIROUTER_,\n        address WETH_\n    ) Auth(GOVERNANCE_, AUTHORITY_) { //set authority to something that enables operators for aphra\n        UNDERLYING = UNDERLYING_; //vader\n        BASE_UNIT = 10e18;\n\n        POOL = ICurve(POOL_);\n        XVADER = IXVader(XVADER_);\n\n        VADERGATEWAY = IVaderMinter(VADERGATEWAY_); // our partner minter\n        UNISWAP = IUniswap(UNIROUTER_);\n        WETH = ERC20(WETH_);\n\n        USDV.safeApprove(POOL_, type(uint256).max); //set unlimited approval to the pool for usdv\n        DAI.safeApprove(UNIROUTER_, type(uint256).max);\n        USDC.safeApprove(UNIROUTER_, type(uint256).max);\n        USDT.safeApprove(UNIROUTER_, type(uint256).max);\n        WETH.safeApprove(UNIROUTER_, type(uint256).max); //prob not needed\n        UNDERLYING.safeApprove(XVADER_, type(uint256).max);\n        UNDERLYING.safeApprove(VADERGATEWAY_, type(uint256).max);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                             STRATEGY LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n\n    function hit(uint256 vAmount_, int128 exitCoin_, address[] memory pathToVader_) external requiresAuth () {\n        _unstakeUnderlying(vAmount_);\n        uint uAmount = VADERGATEWAY.partnerMint(UNDERLYING.balanceOf(address(this)), uint(1));\n        uint vAmount = _swapUSDVToVader(uAmount, exitCoin_, pathToVader_);\n        _stakeUnderlying(vAmount);\n        require(vAmount > vAmount_, \"Failed to arb for profit\");\n    unchecked {\n        require( POOL.balances(1) * 1e3 / (POOL.balances(0)) >= 1e3, \"peg must be at or above 1\");\n    }\n\n    }\n\n    function isCEther() external pure override returns (bool) {\n        return false;\n    }\n\n    function ethToUnderlying(uint256 ethAmount_) external view returns (uint256) {\n        if (ethAmount_ == 0) {\n            return 0;\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(WETH);\n        path[1] = address(UNDERLYING);\n        uint256[] memory amounts = UNISWAP.getAmountsOut(ethAmount_, path);\n\n        return amounts[amounts.length - 1];\n    }\n\n    function underlying() external view override returns (ERC20) {\n        return UNDERLYING;\n    }\n\n    function mint(uint256 amount) external requiresAuth override returns (uint256) {\n        _mint(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), amount);\n        _stakeUnderlying(UNDERLYING.balanceOf(address(this)));\n        return 0;\n    }\n\n    function redeemUnderlying(uint256 amount) external override returns (uint256) {\n        _burn(msg.sender, amount.fdiv(_exchangeRate(), BASE_UNIT));\n\n        if (UNDERLYING.balanceOf(address(this)) < amount) {\n            uint leaveAmount = amount - UNDERLYING.balanceOf(address(this));\n            _unstakeUnderlying(leaveAmount);\n        }\n        UNDERLYING.safeTransfer(msg.sender, amount);\n\n        return 0;\n    }\n\n    function balanceOfUnderlying(address user) external view override returns (uint256) {\n        return balanceOf[user].fmul(_exchangeRate(), BASE_UNIT);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            INTERNAL LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    ERC20 internal immutable UNDERLYING;\n\n    uint256 internal immutable BASE_UNIT;\n\n    function _stakeUnderlying(uint vAmount) internal {\n        XVADER.enter(vAmount);\n    }\n\n    function _computeStakedSharesForUnderlying(uint vAmount) internal view returns(uint256) {\n        return (vAmount * XVADER.totalSupply()) / UNDERLYING.balanceOf(address(XVADER));\n    }\n\n    function _unstakeUnderlying(uint vAmount) internal {\n        uint shares = _computeStakedSharesForUnderlying(vAmount);\n        XVADER.leave(shares);\n    }\n\n    function _swapUSDVToVader(uint uAmount_, int128 exitCoin_, address[] memory path_) internal returns (uint vAmount) {\n        //get best exit address\n        //get mins for swap\n        address exitCoinAddr = address(DAI);\n        if (exitCoin_ == int128(2)) {\n            exitCoinAddr = address(USDC);\n        } else if (exitCoin_ == int128(3)) {\n            exitCoinAddr = address(USDT);\n        }\n        POOL.exchange_underlying(0, exitCoin_, uAmount_, uint(1));\n\n        address[] memory path;\n        if(path_.length == 0) {\n            path = new address[](3);\n            path[0] = exitCoinAddr;\n            path[1] = address(WETH);\n            path[2] = address(UNDERLYING); //vader eth pool has the best depth for vader\n        } else {\n            path = path_;\n        }\n\n        uint256 amountIn = ERC20(exitCoinAddr).balanceOf(address(this));\n        uint256[] memory amounts = UNISWAP.getAmountsOut(amountIn, path);\n        vAmount = amounts[amounts.length - 1];\n        UNISWAP.swapExactTokensForTokens(\n            amountIn,\n            vAmount,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n    }\n\n    function _computeStakedUnderlying() internal view returns (uint256) {\n        return (XVADER.balanceOf(address(this)) * UNDERLYING.balanceOf(address(XVADER))) / XVADER.totalSupply();\n    }\n\n    function _exchangeRate() internal view returns (uint256) {\n        uint256 cTokenSupply = totalSupply;\n\n        if (cTokenSupply == 0) return BASE_UNIT;\n        uint underlyingBalance;\n        uint stakedBalance = _computeStakedUnderlying();\n        unchecked {\n            underlyingBalance = UNDERLYING.balanceOf(address(this)) + stakedBalance;\n        }\n        return underlyingBalance.fdiv(cTokenSupply, BASE_UNIT);\n    }\n}\n\n"
    },
    "srcBuild/Vault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {Auth} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport {WETH} from \"@rari-capital/solmate/src/tokens/WETH.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"./FixedPointMathLib.sol\";\n\nimport {Strategy, ERC20Strategy, ETHStrategy} from \"./interfaces/Strategy.sol\";\n\n/// @title Aphra Vault (avToken)\n/// @author Transmissions11 and JetJadeja\n/// @notice Flexible, minimalist, and gas-optimized yield\n/// aggregator for earning interest on any ERC20 token.\n/// @notice changes from original are to rename Rari -> Aphra tokens and any usage of rvToken => avToken\ncontract Vault is ERC20, Auth {\n    using SafeCastLib for uint256;\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /* //////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice The maximum number of elements allowed on the withdrawal stack.\n    /// @dev Needed to prevent denial of service attacks by queue operators.\n    uint256 internal constant MAX_WITHDRAWAL_STACK_SIZE = 32;\n\n    /* //////////////////////////////////////////////////////////////\n                                IMMUTABLES\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice The underlying token the Vault accepts.\n    ERC20 public immutable UNDERLYING;\n\n    /// @notice The base unit of the underlying token and hence avToken.\n    /// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\n    uint256 internal immutable BASE_UNIT;\n\n    /// @notice Creates a new Vault that accepts a specific underlying token.\n    /// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\n    constructor(ERC20 _UNDERLYING)\n        ERC20(\n            // ex:Aphra Vader Vault\n            string(abi.encodePacked(\"Aphra \", _UNDERLYING.name(), \" Vault\")),\n            // ex: avVader\n            string(abi.encodePacked(\"av\", _UNDERLYING.symbol())),\n            // ex: 18\n            _UNDERLYING.decimals()\n        )\n        Auth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\n    {\n        UNDERLYING = _UNDERLYING;\n\n        BASE_UNIT = 10**decimals;\n\n        // Prevent minting of avTokens until\n        // the initialize function is called.\n        totalSupply = type(uint256).max;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                           FEE CONFIGURATION\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice The percentage of profit recognized each harvest to reserve as fees.\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n    uint256 public feePercent;\n\n    /// @notice Emitted when the fee percentage is updated.\n    /// @param user The authorized user who triggered the update.\n    /// @param newFeePercent The new fee percentage.\n    event FeePercentUpdated(address indexed user, uint256 newFeePercent);\n\n    /// @notice Sets a new fee percentage.\n    /// @param newFeePercent The new fee percentage.\n    function setFeePercent(uint256 newFeePercent) external requiresAuth {\n        // A fee percentage over 100% doesn't make sense.\n        require(newFeePercent <= 1e18, \"FEE_TOO_HIGH\");\n\n        // Update the fee percentage.\n        feePercent = newFeePercent;\n\n        emit FeePercentUpdated(msg.sender, newFeePercent);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        HARVEST CONFIGURATION\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when the harvest window is updated.\n    /// @param user The authorized user who triggered the update.\n    /// @param newHarvestWindow The new harvest window.\n    event HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\n\n    /// @notice Emitted when the harvest delay is updated.\n    /// @param user The authorized user who triggered the update.\n    /// @param newHarvestDelay The new harvest delay.\n    event HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\n\n    /// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\n    /// @param user The authorized user who triggered the update.\n    /// @param newHarvestDelay The scheduled updated harvest delay.\n    event HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\n\n    /// @notice The period in seconds during which multiple harvests can occur\n    /// regardless if they are taking place before the harvest delay has elapsed.\n    /// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\n    uint128 public harvestWindow;\n\n    /// @notice The period in seconds over which locked profit is unlocked.\n    /// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\n    uint64 public harvestDelay;\n\n    /// @notice The value that will replace harvestDelay next harvest.\n    /// @dev In the case that the next delay is 0, no update will be applied.\n    uint64 public nextHarvestDelay;\n\n    /// @notice Sets a new harvest window.\n    /// @param newHarvestWindow The new harvest window.\n    /// @dev The Vault's harvestDelay must already be set before calling.\n    function setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\n        // A harvest window longer than the harvest delay doesn't make sense.\n        require(newHarvestWindow <= harvestDelay, \"WINDOW_TOO_LONG\");\n\n        // Update the harvest window.\n        harvestWindow = newHarvestWindow;\n\n        emit HarvestWindowUpdated(msg.sender, newHarvestWindow);\n    }\n\n    /// @notice Sets a new harvest delay.\n    /// @param newHarvestDelay The new harvest delay to set.\n    /// @dev If the current harvest delay is 0, meaning it has not\n    /// been set before, it will be updated immediately, otherwise\n    /// it will be scheduled to take effect after the next harvest.\n    function setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\n        // A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\n        require(newHarvestDelay != 0, \"DELAY_CANNOT_BE_ZERO\");\n\n        // A harvest delay longer than 1 year doesn't make sense.\n        require(newHarvestDelay <= 365 days, \"DELAY_TOO_LONG\");\n\n        // If the harvest delay is 0, meaning it has not been set before:\n        if (harvestDelay == 0) {\n            // We'll apply the update immediately.\n            harvestDelay = newHarvestDelay;\n\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\n        } else {\n            // We'll apply the update next harvest.\n            nextHarvestDelay = newHarvestDelay;\n\n            emit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                       TARGET FLOAT CONFIGURATION\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice The desired percentage of the Vault's holdings to keep as float.\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n    uint256 public targetFloatPercent;\n\n    /// @notice Emitted when the target float percentage is updated.\n    /// @param user The authorized user who triggered the update.\n    /// @param newTargetFloatPercent The new target float percentage.\n    event TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\n\n    /// @notice Set a new target float percentage.\n    /// @param newTargetFloatPercent The new target float percentage.\n    function setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\n        // A target float percentage over 100% doesn't make sense.\n        require(newTargetFloatPercent <= 1e18, \"TARGET_TOO_HIGH\");\n\n        // Update the target float percentage.\n        targetFloatPercent = newTargetFloatPercent;\n\n        emit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                   UNDERLYING IS WETH CONFIGURATION\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Whether the Vault should treat the underlying token as WETH compatible.\n    /// @dev If enabled the Vault will allow trusting strategies that accept Ether.\n    bool public underlyingIsWETH;\n\n    /// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\n    /// @param user The authorized user who triggered the update.\n    /// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\n    event UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\n\n    /// @notice Sets whether the Vault treats the underlying as WETH.\n    /// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\n    /// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\n    function setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\n        // Ensure the underlying token's decimals match ETH if is WETH being set to true.\n        require(!newUnderlyingIsWETH || UNDERLYING.decimals() == 18, \"WRONG_DECIMALS\");\n\n        // Update whether the Vault treats the underlying as WETH.\n        underlyingIsWETH = newUnderlyingIsWETH;\n\n        emit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          STRATEGY STORAGE\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\n    /// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\n    uint256 public totalStrategyHoldings;\n\n    /// @dev Packed struct of strategy data.\n    /// @param trusted Whether the strategy is trusted.\n    /// @param balance The amount of underlying tokens held in the strategy.\n    struct StrategyData {\n        // Used to determine if the Vault will operate on a strategy.\n        bool trusted;\n        // Used to determine profit and loss during harvests of the strategy.\n        uint248 balance;\n    }\n\n    /// @notice Maps strategies to data the Vault holds on them.\n    mapping(Strategy => StrategyData) public getStrategyData;\n\n    /* //////////////////////////////////////////////////////////////\n                             HARVEST STORAGE\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\n    /// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\n    uint64 public lastHarvestWindowStart;\n\n    /// @notice A timestamp representing when the most recent harvest occurred.\n    uint64 public lastHarvest;\n\n    /// @notice The amount of locked profit at the end of the last harvest.\n    uint128 public maxLockedProfit;\n\n    /* //////////////////////////////////////////////////////////////\n                        WITHDRAWAL STACK STORAGE\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice An ordered array of strategies representing the withdrawal stack.\n    /// @dev The stack is processed in descending order, meaning the last index will be withdrawn from first.\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\n    /// withdrawal time, not validated upfront, meaning the stack may not reflect the \"true\" set used for withdrawals.\n    Strategy[] public withdrawalStack;\n\n    /// @notice Gets the full withdrawal stack.\n    /// @return An ordered array of strategies representing the withdrawal stack.\n    /// @dev This is provided because Solidity converts public arrays into index getters,\n    /// but we need a way to allow external contracts and users to access the whole array.\n    function getWithdrawalStack() external view returns (Strategy[] memory) {\n        return withdrawalStack;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted after a successful deposit.\n    /// @param user The address that deposited into the Vault.\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\n    event Deposit(address indexed user, uint256 underlyingAmount);\n\n    /// @notice Emitted after a successful withdrawal.\n    /// @param user The address that withdrew from the Vault.\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\n    event Withdraw(address indexed user, uint256 underlyingAmount);\n\n    /// @notice Deposit a specific amount of underlying tokens.\n    /// @param underlyingAmount The amount of the underlying token to deposit.\n    function deposit(uint256 underlyingAmount) external {\n        // Determine the equivalent amount of avTokens and mint them.\n        _mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\n\n        emit Deposit(msg.sender, underlyingAmount);\n\n        // Transfer in underlying tokens from the user.\n        // This will revert if the user does not have the amount specified.\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n    }\n\n    /// @notice Withdraw a specific amount of underlying tokens.\n    /// @param underlyingAmount The amount of underlying tokens to withdraw.\n    function withdraw(uint256 underlyingAmount) external {\n        // Determine the equivalent amount of avTokens and burn them.\n        // This will revert if the user does not have enough avTokens.\n        _burn(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\n\n        emit Withdraw(msg.sender, underlyingAmount);\n\n        // Withdraw from strategies if needed and transfer.\n        transferUnderlyingTo(msg.sender, underlyingAmount);\n    }\n\n    /// @notice Redeem a specific amount of avTokens for underlying tokens.\n    /// @param avTokenAmount The amount of avTokens to redeem for underlying tokens.\n    function redeem(uint256 avTokenAmount) external {\n        // Determine the equivalent amount of underlying tokens.\n        uint256 underlyingAmount = avTokenAmount.fmul(exchangeRate(), BASE_UNIT);\n\n        // Burn the provided amount of avTokens.\n        // This will revert if the user does not have enough avTokens.\n        _burn(msg.sender, avTokenAmount);\n\n        emit Withdraw(msg.sender, underlyingAmount);\n\n        // Withdraw from strategies if needed and transfer.\n        transferUnderlyingTo(msg.sender, underlyingAmount);\n    }\n\n    /// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\n    /// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\n    /// @param recipient The user to transfer the underlying tokens to.\n    /// @param underlyingAmount The amount of underlying tokens to transfer.\n    function transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\n        // Get the Vault's floating balance.\n        uint256 float = totalFloat();\n\n        // If the amount is greater than the float, withdraw from strategies.\n        if (underlyingAmount > float) {\n            // Compute the amount needed to reach our target float percentage.\n            uint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(targetFloatPercent, 1e18);\n\n            // Compute the bare minimum amount we need for this withdrawal.\n            uint256 floatMissingForWithdrawal = underlyingAmount - float;\n\n            // Pull enough to cover the withdrawal and reach our target float percentage.\n            pullFromWithdrawalStack(floatMissingForWithdrawal + floatMissingForTarget);\n        }\n\n        // Transfer the provided amount of underlying tokens.\n        UNDERLYING.safeTransfer(recipient, underlyingAmount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        VAULT ACCOUNTING LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Returns a user's Vault balance in underlying tokens.\n    /// @param user The user to get the underlying balance of.\n    /// @return The user's Vault balance in underlying tokens.\n    function balanceOfUnderlying(address user) external view returns (uint256) {\n        return balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\n    }\n\n    /// @notice Returns the amount of underlying tokens an avToken can be redeemed for.\n    /// @return The amount of underlying tokens an avToken can be redeemed for.\n    function exchangeRate() public view returns (uint256) {\n        // Get the total supply of avTokens.\n        uint256 avTokenSupply = totalSupply;\n\n        // If there are no avTokens in circulation, return an exchange rate of 1:1.\n        if (avTokenSupply == 0) return BASE_UNIT;\n\n        // Calculate the exchange rate by dividing the total holdings by the avToken supply.\n        return totalHoldings().fdiv(avTokenSupply, BASE_UNIT);\n    }\n\n    /// @notice Calculates the total amount of underlying tokens the Vault holds.\n    /// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\n    function totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\n        unchecked {\n            // Cannot underflow as locked profit can't exceed total strategy holdings.\n            totalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\n        }\n\n        // Include our floating balance in the total.\n        totalUnderlyingHeld += totalFloat();\n    }\n\n    /// @notice Calculates the current amount of locked profit.\n    /// @return The current amount of locked profit.\n    function lockedProfit() public view returns (uint256) {\n        // Get the last harvest and harvest delay.\n        uint256 previousHarvest = lastHarvest;\n        uint256 harvestInterval = harvestDelay;\n\n        unchecked {\n            // If the harvest delay has passed, there is no locked profit.\n            // Cannot overflow on human timescales since harvestInterval is capped.\n            if (block.timestamp >= previousHarvest + harvestInterval) return 0;\n\n            // Get the maximum amount we could return.\n            uint256 maximumLockedProfit = maxLockedProfit;\n\n            // Compute how much profit remains locked based on the last harvest and harvest delay.\n            // It's impossible for the previous harvest to be in the future, so this will never underflow.\n            return maximumLockedProfit - (maximumLockedProfit * (block.timestamp - previousHarvest)) / harvestInterval;\n        }\n    }\n\n    /// @notice Returns the amount of underlying tokens that idly sit in the Vault.\n    /// @return The amount of underlying tokens that sit idly in the Vault.\n    function totalFloat() public view returns (uint256) {\n        return UNDERLYING.balanceOf(address(this));\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                             HARVEST LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted after a successful harvest.\n    /// @param user The authorized user who triggered the harvest.\n    /// @param strategies The trusted strategies that were harvested.\n    event Harvest(address indexed user, Strategy[] strategies);\n\n    /// @notice Harvest a set of trusted strategies.\n    /// @param strategies The trusted strategies to harvest.\n    /// @dev Will always revert if called outside of an active\n    /// harvest window or before the harvest delay has passed.\n    function harvest(Strategy[] calldata strategies) external requiresAuth {\n        // If this is the first harvest after the last window:\n        if (block.timestamp >= lastHarvest + harvestDelay) {\n            // Set the harvest window's start timestamp.\n            // Cannot overflow 64 bits on human timescales.\n            lastHarvestWindowStart = uint64(block.timestamp);\n        } else {\n            // We know this harvest is not the first in the window so we need to ensure it's within it.\n            require(block.timestamp <= lastHarvestWindowStart + harvestWindow, \"BAD_HARVEST_TIME\");\n        }\n\n        // Get the Vault's current total strategy holdings.\n        uint256 oldTotalStrategyHoldings = totalStrategyHoldings;\n\n        // Used to store the total profit accrued by the strategies.\n        uint256 totalProfitAccrued;\n\n        // Used to store the new total strategy holdings after harvesting.\n        uint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\n\n        // Will revert if any of the specified strategies are untrusted.\n        for (uint256 i = 0; i < strategies.length; i++) {\n            // Get the strategy at the current index.\n            Strategy strategy = strategies[i];\n\n            // If an untrusted strategy could be harvested a malicious user could use\n            // a fake strategy that over-reports holdings to manipulate the exchange rate.\n            require(getStrategyData[strategy].trusted, \"UNTRUSTED_STRATEGY\");\n\n            // Get the strategy's previous and current balance.\n            uint256 balanceLastHarvest = getStrategyData[strategy].balance;\n            uint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\n\n            // Update the strategy's stored balance. Cast overflow is unrealistic.\n            getStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\n\n            // Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\n            // We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\n            newTotalStrategyHoldings = newTotalStrategyHoldings + balanceThisHarvest - balanceLastHarvest;\n\n            unchecked {\n                // Update the total profit accrued while counting losses as zero profit.\n                // Cannot overflow as we already increased total holdings without reverting.\n                totalProfitAccrued += balanceThisHarvest > balanceLastHarvest\n                    ? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\n                    : 0; // If the strategy registered a net loss we don't have any new profit.\n            }\n        }\n\n        // Compute fees as the fee percent multiplied by the profit.\n        uint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\n\n        // If we accrued any fees, mint an equivalent amount of avTokens.\n        // Authorized users can claim the newly minted avTokens via claimFees.\n        _mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\n\n        // Update max unlocked profit based on any remaining locked profit plus new profit.\n        maxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\n\n        // Set strategy holdings to our new total.\n        totalStrategyHoldings = newTotalStrategyHoldings;\n\n        // Update the last harvest timestamp.\n        // Cannot overflow on human timescales.\n        lastHarvest = uint64(block.timestamp);\n\n        emit Harvest(msg.sender, strategies);\n\n        // Get the next harvest delay.\n        uint64 newHarvestDelay = nextHarvestDelay;\n\n        // If the next harvest delay is not 0:\n        if (newHarvestDelay != 0) {\n            // Update the harvest delay.\n            harvestDelay = newHarvestDelay;\n\n            // Reset the next harvest delay.\n            nextHarvestDelay = 0;\n\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                    STRATEGY DEPOSIT/WITHDRAWAL LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted after the Vault deposits into a strategy contract.\n    /// @param user The authorized user who triggered the deposit.\n    /// @param strategy The strategy that was deposited into.\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\n    event StrategyDeposit(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\n\n    /// @notice Emitted after the Vault withdraws funds from a strategy contract.\n    /// @param user The authorized user who triggered the withdrawal.\n    /// @param strategy The strategy that was withdrawn from.\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\n    event StrategyWithdrawal(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\n\n    /// @notice Deposit a specific amount of float into a trusted strategy.\n    /// @param strategy The trusted strategy to deposit into.\n    /// @param underlyingAmount The amount of underlying tokens in float to deposit.\n    function depositIntoStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\n        // A strategy must be trusted before it can be deposited into.\n        require(getStrategyData[strategy].trusted, \"UNTRUSTED_STRATEGY\");\n\n        // Increase totalStrategyHoldings to account for the deposit.\n        totalStrategyHoldings += underlyingAmount;\n\n        unchecked {\n            // Without this the next harvest would count the deposit as profit.\n            // Cannot overflow as the balance of one strategy can't exceed the sum of all.\n            getStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\n        }\n\n        emit StrategyDeposit(msg.sender, strategy, underlyingAmount);\n\n        // We need to deposit differently if the strategy takes ETH.\n        if (strategy.isCEther()) {\n            // Unwrap the right amount of WETH.\n            WETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\n\n            // Deposit into the strategy and assume it will revert on error.\n            ETHStrategy(address(strategy)).mint{value: underlyingAmount}();\n        } else {\n            // Approve underlyingAmount to the strategy so we can deposit.\n            UNDERLYING.safeApprove(address(strategy), underlyingAmount);\n\n            // Deposit into the strategy and revert if it returns an error code.\n            require(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \"MINT_FAILED\");\n        }\n    }\n\n    /// @notice Withdraw a specific amount of underlying tokens from a strategy.\n    /// @param strategy The strategy to withdraw from.\n    /// @param underlyingAmount  The amount of underlying tokens to withdraw.\n    /// @dev Withdrawing from a strategy will not remove it from the withdrawal stack.\n    function withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\n        // A strategy must be trusted before it can be withdrawn from.\n        require(getStrategyData[strategy].trusted, \"UNTRUSTED_STRATEGY\");\n\n        // Without this the next harvest would count the withdrawal as a loss.\n        getStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\n\n        unchecked {\n            // Decrease totalStrategyHoldings to account for the withdrawal.\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\n            totalStrategyHoldings -= underlyingAmount;\n        }\n\n        emit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\n\n        // Withdraw from the strategy and revert if it returns an error code.\n        require(strategy.redeemUnderlying(underlyingAmount) == 0, \"REDEEM_FAILED\");\n\n        // Wrap the withdrawn Ether into WETH if necessary.\n        if (strategy.isCEther()) WETH(payable(address(UNDERLYING))).deposit{value: underlyingAmount}();\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                      STRATEGY TRUST/DISTRUST LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when a strategy is set to trusted.\n    /// @param user The authorized user who trusted the strategy.\n    /// @param strategy The strategy that became trusted.\n    event StrategyTrusted(address indexed user, Strategy indexed strategy);\n\n    /// @notice Emitted when a strategy is set to untrusted.\n    /// @param user The authorized user who untrusted the strategy.\n    /// @param strategy The strategy that became untrusted.\n    event StrategyDistrusted(address indexed user, Strategy indexed strategy);\n\n    /// @notice Stores a strategy as trusted, enabling it to be harvested.\n    /// @param strategy The strategy to make trusted.\n    function trustStrategy(Strategy strategy) external requiresAuth {\n        // Ensure the strategy accepts the correct underlying token.\n        // If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\n        require(\n            strategy.isCEther() ? underlyingIsWETH : ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\n            \"WRONG_UNDERLYING\"\n        );\n\n        // Store the strategy as trusted.\n        getStrategyData[strategy].trusted = true;\n\n        emit StrategyTrusted(msg.sender, strategy);\n    }\n\n    /// @notice Stores a strategy as untrusted, disabling it from being harvested.\n    /// @param strategy The strategy to make untrusted.\n    function distrustStrategy(Strategy strategy) external requiresAuth {\n        // Store the strategy as untrusted.\n        getStrategyData[strategy].trusted = false;\n\n        emit StrategyDistrusted(msg.sender, strategy);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                         WITHDRAWAL STACK LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when a strategy is pushed to the withdrawal stack.\n    /// @param user The authorized user who triggered the push.\n    /// @param pushedStrategy The strategy pushed to the withdrawal stack.\n    event WithdrawalStackPushed(address indexed user, Strategy indexed pushedStrategy);\n\n    /// @notice Emitted when a strategy is popped from the withdrawal stack.\n    /// @param user The authorized user who triggered the pop.\n    /// @param poppedStrategy The strategy popped from the withdrawal stack.\n    event WithdrawalStackPopped(address indexed user, Strategy indexed poppedStrategy);\n\n    /// @notice Emitted when the withdrawal stack is updated.\n    /// @param user The authorized user who triggered the set.\n    /// @param replacedWithdrawalStack The new withdrawal stack.\n    event WithdrawalStackSet(address indexed user, Strategy[] replacedWithdrawalStack);\n\n    /// @notice Emitted when an index in the withdrawal stack is replaced.\n    /// @param user The authorized user who triggered the replacement.\n    /// @param index The index of the replaced strategy in the withdrawal stack.\n    /// @param replacedStrategy The strategy in the withdrawal stack that was replaced.\n    /// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\n    event WithdrawalStackIndexReplaced(\n        address indexed user,\n        uint256 index,\n        Strategy indexed replacedStrategy,\n        Strategy indexed replacementStrategy\n    );\n\n    /// @notice Emitted when an index in the withdrawal stack is replaced with the tip.\n    /// @param user The authorized user who triggered the replacement.\n    /// @param index The index of the replaced strategy in the withdrawal stack.\n    /// @param replacedStrategy The strategy in the withdrawal stack replaced by the tip.\n    /// @param previousTipStrategy The previous tip of the stack that replaced the strategy.\n    event WithdrawalStackIndexReplacedWithTip(\n        address indexed user,\n        uint256 index,\n        Strategy indexed replacedStrategy,\n        Strategy indexed previousTipStrategy\n    );\n\n    /// @notice Emitted when the strategies at two indexes are swapped.\n    /// @param user The authorized user who triggered the swap.\n    /// @param index1 One index involved in the swap\n    /// @param index2 The other index involved in the swap.\n    /// @param newStrategy1 The strategy (previously at index2) that replaced index1.\n    /// @param newStrategy2 The strategy (previously at index1) that replaced index2.\n    event WithdrawalStackIndexesSwapped(\n        address indexed user,\n        uint256 index1,\n        uint256 index2,\n        Strategy indexed newStrategy1,\n        Strategy indexed newStrategy2\n    );\n\n    /// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal stack.\n    /// @param underlyingAmount The amount of underlying tokens to pull into float.\n    /// @dev Automatically removes depleted strategies from the withdrawal stack.\n    function pullFromWithdrawalStack(uint256 underlyingAmount) internal {\n        // We will update this variable as we pull from strategies.\n        uint256 amountLeftToPull = underlyingAmount;\n\n        // We'll start at the tip of the stack and traverse backwards.\n        uint256 currentIndex = withdrawalStack.length - 1;\n\n        // Iterate in reverse so we pull from the stack in a \"last in, first out\" manner.\n        // Will revert due to underflow if we empty the stack before pulling the desired amount.\n        for (; ; currentIndex--) {\n            // Get the strategy at the current stack index.\n            Strategy strategy = withdrawalStack[currentIndex];\n\n            // Get the balance of the strategy before we withdraw from it.\n            uint256 strategyBalance = getStrategyData[strategy].balance;\n\n            // If the strategy is currently untrusted or was already depleted:\n            if (!getStrategyData[strategy].trusted || strategyBalance == 0) {\n                // Remove it from the stack.\n                withdrawalStack.pop();\n\n                emit WithdrawalStackPopped(msg.sender, strategy);\n\n                // Move onto the next strategy.\n                continue;\n            }\n\n            // We want to pull as much as we can from the strategy, but no more than we need.\n            uint256 amountToPull = strategyBalance > amountLeftToPull ? amountLeftToPull : strategyBalance;\n\n            unchecked {\n                // Compute the balance of the strategy that will remain after we withdraw.\n                // Cannot underflow as we cap the amount to pull at the strategy's balance.\n                uint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\n\n                // Without this the next harvest would count the withdrawal as a loss.\n                getStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\n\n                // Adjust our goal based on how much we can pull from the strategy.\n                // Cannot underflow as we cap the amount to pull at the amount left to pull.\n                amountLeftToPull -= amountToPull;\n\n                emit StrategyWithdrawal(msg.sender, strategy, amountToPull);\n\n                // Withdraw from the strategy and revert if returns an error code.\n                require(strategy.redeemUnderlying(amountToPull) == 0, \"REDEEM_FAILED\");\n\n                // If we fully depleted the strategy:\n                if (strategyBalanceAfterWithdrawal == 0) {\n                    // Remove it from the stack.\n                    withdrawalStack.pop();\n\n                    emit WithdrawalStackPopped(msg.sender, strategy);\n                }\n            }\n\n            // If we've pulled all we need, exit the loop.\n            if (amountLeftToPull == 0) break;\n        }\n\n        unchecked {\n            // Account for the withdrawals done in the loop above.\n            // Cannot underflow as the balances of some strategies cannot exceed the sum of all.\n            totalStrategyHoldings -= underlyingAmount;\n        }\n\n        // Cache the Vault's balance of ETH.\n        uint256 ethBalance = address(this).balance;\n\n        // If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\n        if (ethBalance != 0 && underlyingIsWETH) WETH(payable(address(UNDERLYING))).deposit{value: ethBalance}();\n    }\n\n    /// @notice Pushes a single strategy to front of the withdrawal stack.\n    /// @param strategy The strategy to be inserted at the front of the withdrawal stack.\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\n    /// filtered out when encountered at withdrawal time, not validated upfront.\n    function pushToWithdrawalStack(Strategy strategy) external requiresAuth {\n        // Ensure pushing the strategy will not cause the stack exceed its limit.\n        require(withdrawalStack.length < MAX_WITHDRAWAL_STACK_SIZE, \"STACK_FULL\");\n\n        // Push the strategy to the front of the stack.\n        withdrawalStack.push(strategy);\n\n        emit WithdrawalStackPushed(msg.sender, strategy);\n    }\n\n    /// @notice Removes the strategy at the tip of the withdrawal stack.\n    /// @dev Be careful, another authorized user could push a different strategy\n    /// than expected to the stack while a popFromWithdrawalStack transaction is pending.\n    function popFromWithdrawalStack() external requiresAuth {\n        // Get the (soon to be) popped strategy.\n        Strategy poppedStrategy = withdrawalStack[withdrawalStack.length - 1];\n\n        // Pop the first strategy in the stack.\n        withdrawalStack.pop();\n\n        emit WithdrawalStackPopped(msg.sender, poppedStrategy);\n    }\n\n    /// @notice Sets a new withdrawal stack.\n    /// @param newStack The new withdrawal stack.\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\n    /// filtered out when encountered at withdrawal time, not validated upfront.\n    function setWithdrawalStack(Strategy[] calldata newStack) external requiresAuth {\n        // Ensure the new stack is not larger than the maximum stack size.\n        require(newStack.length <= MAX_WITHDRAWAL_STACK_SIZE, \"STACK_TOO_BIG\");\n\n        // Replace the withdrawal stack.\n        withdrawalStack = newStack;\n\n        emit WithdrawalStackSet(msg.sender, newStack);\n    }\n\n    /// @notice Replaces an index in the withdrawal stack with another strategy.\n    /// @param index The index in the stack to replace.\n    /// @param replacementStrategy The strategy to override the index with.\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\n    /// filtered out when encountered at withdrawal time, not validated upfront.\n    function replaceWithdrawalStackIndex(uint256 index, Strategy replacementStrategy) external requiresAuth {\n        // Get the (soon to be) replaced strategy.\n        Strategy replacedStrategy = withdrawalStack[index];\n\n        // Update the index with the replacement strategy.\n        withdrawalStack[index] = replacementStrategy;\n\n        emit WithdrawalStackIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\n    }\n\n    /// @notice Moves the strategy at the tip of the stack to the specified index and pop the tip off the stack.\n    /// @param index The index of the strategy in the withdrawal stack to replace with the tip.\n    function replaceWithdrawalStackIndexWithTip(uint256 index) external requiresAuth {\n        // Get the (soon to be) previous tip and strategy we will replace at the index.\n        Strategy previousTipStrategy = withdrawalStack[withdrawalStack.length - 1];\n        Strategy replacedStrategy = withdrawalStack[index];\n\n        // Replace the index specified with the tip of the stack.\n        withdrawalStack[index] = previousTipStrategy;\n\n        // Remove the now duplicated tip from the array.\n        withdrawalStack.pop();\n\n        emit WithdrawalStackIndexReplacedWithTip(msg.sender, index, replacedStrategy, previousTipStrategy);\n    }\n\n    /// @notice Swaps two indexes in the withdrawal stack.\n    /// @param index1 One index involved in the swap\n    /// @param index2 The other index involved in the swap.\n    function swapWithdrawalStackIndexes(uint256 index1, uint256 index2) external requiresAuth {\n        // Get the (soon to be) new strategies at each index.\n        Strategy newStrategy2 = withdrawalStack[index1];\n        Strategy newStrategy1 = withdrawalStack[index2];\n\n        // Swap the strategies at both indexes.\n        withdrawalStack[index1] = newStrategy1;\n        withdrawalStack[index2] = newStrategy2;\n\n        emit WithdrawalStackIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                         SEIZE STRATEGY LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted after a strategy is seized.\n    /// @param user The authorized user who triggered the seize.\n    /// @param strategy The strategy that was seized.\n    event StrategySeized(address indexed user, Strategy indexed strategy);\n\n    /// @notice Seizes a strategy.\n    /// @param strategy The strategy to seize.\n    /// @dev Intended for use in emergencies or other extraneous situations where the\n    /// strategy requires interaction outside of the Vault's standard operating procedures.\n    function seizeStrategy(Strategy strategy) external requiresAuth {\n        // Get the strategy's last reported balance of underlying tokens.\n        uint256 strategyBalance = getStrategyData[strategy].balance;\n\n        // If the strategy's balance exceeds the Vault's current\n        // holdings, instantly unlock any remaining locked profit.\n        if (strategyBalance > totalHoldings()) maxLockedProfit = 0;\n\n        // Set the strategy's balance to 0.\n        getStrategyData[strategy].balance = 0;\n\n        unchecked {\n            // Decrease totalStrategyHoldings to account for the seize.\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\n            totalStrategyHoldings -= strategyBalance;\n        }\n\n        emit StrategySeized(msg.sender, strategy);\n\n        // Transfer all of the strategy's tokens to the caller.\n        ERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                             FEE CLAIM LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted after fees are claimed.\n    /// @param user The authorized user who claimed the fees.\n    /// @param avTokenAmount The amount of avTokens that were claimed.\n    event FeesClaimed(address indexed user, uint256 avTokenAmount);\n\n    /// @notice Claims fees accrued from harvests.\n    /// @param avTokenAmount The amount of avTokens to claim.\n    /// @dev Accrued fees are measured as avTokens held by the Vault.\n    function claimFees(uint256 avTokenAmount) external requiresAuth {\n        emit FeesClaimed(msg.sender, avTokenAmount);\n\n        // Transfer the provided amount of avTokens to the caller.\n        ERC20(this).safeTransfer(msg.sender, avTokenAmount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                    INITIALIZATION AND DESTRUCTION LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when the Vault is initialized.\n    /// @param user The authorized user who triggered the initialization.\n    event Initialized(address indexed user);\n\n    /// @notice Whether the Vault has been initialized yet.\n    /// @dev Can go from false to true, never from true to false.\n    bool public isInitialized;\n\n    /// @notice Initializes the Vault, enabling it to receive deposits.\n    /// @dev All critical parameters must already be set before calling.\n    function initialize() external requiresAuth {\n        // Ensure the Vault has not already been initialized.\n        require(!isInitialized, \"ALREADY_INITIALIZED\");\n\n        // Mark the Vault as initialized.\n        isInitialized = true;\n\n        // Open for deposits.\n        totalSupply = 0;\n\n        emit Initialized(msg.sender);\n    }\n\n    /// @notice Self destructs a Vault, enabling it to be redeployed.\n    /// @dev Caller will receive any ETH held as float in the Vault.\n    function destroy() external requiresAuth {\n        selfdestruct(payable(msg.sender));\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          RECIEVE ETHER LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @dev Required for the Vault to receive unwrapped ETH.\n    receive() external payable {}\n}\n"
    },
    "@rari-capital/solmate/src/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "srcBuild/modules/VaultRouterModule.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {WETH} from \"@rari-capital/solmate/src/tokens/WETH.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../FixedPointMathLib.sol\";\n\nimport {AllowedPermit} from \"../interfaces/AllowedPermit.sol\";\n\nimport {Vault} from \"../Vault.sol\";\n\n/// @title Rari Vault Router Module\n/// @author Transmissions11 and JetJadeja\n/// @notice Module that enables depositing ETH into WETH compatible Vaults\n/// and approval-free deposits into Vaults with permit compatible underlying.\ncontract VaultRouterModule {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /* //////////////////////////////////////////////////////////////\n                              DEPOSIT LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Deposit ETH into a WETH compatible Vault.\n    /// @param vault The WETH compatible Vault to deposit into.\n    function depositETHIntoVault(Vault vault) external payable {\n        // Ensure the Vault's underlying is stored as WETH compatible.\n        require(vault.underlyingIsWETH(), \"UNDERLYING_NOT_WETH\");\n\n        // Get the Vault's underlying as WETH.\n        WETH weth = WETH(payable(address(vault.UNDERLYING())));\n\n        // Wrap the ETH into WETH.\n        weth.deposit{value: msg.value}();\n\n        // Deposit and transfer the minted rvTokens back to the caller.\n        depositIntoVaultForCaller(vault, weth, msg.value);\n    }\n\n    /// @notice Deposits into a Vault, transferring in its underlying token from the caller via permit.\n    /// @param vault The Vault to deposit into.\n    /// @param underlyingAmount The amount of underlying tokens to deposit into the Vault.\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\n    /// @dev Use depositIntoVaultWithAllowedPermit for tokens using DAI's non-standard permit interface.\n    function depositIntoVaultWithPermit(\n        Vault vault,\n        uint256 underlyingAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        // Get the Vault's underlying token.\n        ERC20 underlying = vault.UNDERLYING();\n\n        // Transfer in the provided amount of underlying tokens from the caller via permit.\n        permitAndTransferFromCaller(underlying, underlyingAmount, deadline, v, r, s);\n\n        // Deposit and transfer the minted rvTokens back to the caller.\n        depositIntoVaultForCaller(vault, underlying, underlyingAmount);\n    }\n\n    /// @notice Deposits into a Vault, transferring in its underlying token from the caller via allowed permit.\n    /// @param vault The Vault to deposit into.\n    /// @param underlyingAmount The amount of underlying tokens to deposit into the Vault.\n    /// @param nonce The callers's nonce, increases at each call to permit.\n    /// @param expiry The timestamp at which the permit is no longer valid.\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\n    /// @dev Alternative to depositIntoVaultWithPermit for tokens using DAI's non-standard permit interface.\n    function depositIntoVaultWithAllowedPermit(\n        Vault vault,\n        uint256 underlyingAmount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        // Get the Vault's underlying token.\n        ERC20 underlying = vault.UNDERLYING();\n\n        // Transfer in the provided amount of underlying tokens from the caller via allowed permit.\n        allowedPermitAndTransferFromCaller(underlying, underlyingAmount, nonce, expiry, v, r, s);\n\n        // Deposit and transfer the minted rvTokens back to the caller.\n        depositIntoVaultForCaller(vault, underlying, underlyingAmount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            WITHDRAWAL LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Withdraw ETH from a WETH compatible Vault.\n    /// @param vault The WETH compatible Vault to withdraw from.\n    /// @param underlyingAmount The amount of ETH to withdraw from the Vault.\n    function withdrawETHFromVault(Vault vault, uint256 underlyingAmount) external {\n        // Ensure the Vault's underlying is stored as WETH compatible.\n        require(vault.underlyingIsWETH(), \"UNDERLYING_NOT_WETH\");\n\n        // Compute the amount of rvTokens equivalent to the underlying amount.\n        // We know the Vault's base unit is 1e18 as it's required for underlyingIsWETH to be true.\n        uint256 rvTokenAmount = underlyingAmount.fdiv(vault.exchangeRate(), 1e18);\n\n        // Transfer in the equivalent amount of rvTokens from the caller.\n        ERC20(vault).safeTransferFrom(msg.sender, address(this), rvTokenAmount);\n\n        // Withdraw from the Vault.\n        vault.withdraw(underlyingAmount);\n\n        // Unwrap the withdrawn amount of WETH and transfer it to the caller.\n        unwrapAndTransfer(WETH(payable(address(vault.UNDERLYING()))), underlyingAmount);\n    }\n\n    /// @notice Withdraw ETH from a WETH compatible Vault.\n    /// @param vault The WETH compatible Vault to withdraw from.\n    /// @param underlyingAmount The amount of ETH to withdraw from the Vault.\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\n    function withdrawETHFromVaultWithPermit(\n        Vault vault,\n        uint256 underlyingAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        // Ensure the Vault's underlying is stored as WETH compatible.\n        require(vault.underlyingIsWETH(), \"UNDERLYING_NOT_WETH\");\n\n        // Compute the amount of rvTokens equivalent to the underlying amount.\n        // We know the Vault's base unit is 1e18 as it's required for underlyingIsWETH to be true.\n        uint256 rvTokenAmount = underlyingAmount.fdiv(vault.exchangeRate(), 1e18);\n\n        // Transfer in the equivalent amount of rvTokens from the caller via permit.\n        permitAndTransferFromCaller(vault, rvTokenAmount, deadline, v, r, s);\n\n        // Withdraw from the Vault.\n        vault.withdraw(underlyingAmount);\n\n        // Unwrap the withdrawn amount of WETH and transfer it to the caller.\n        unwrapAndTransfer(WETH(payable(address(vault.UNDERLYING()))), underlyingAmount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                              REDEEM LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Redeem ETH from a WETH compatible Vault.\n    /// @param vault The WETH compatible Vault to redeem from.\n    /// @param rvTokenAmount The amount of rvTokens to withdraw from the Vault.\n    function redeemETHFromVault(Vault vault, uint256 rvTokenAmount) external {\n        // Ensure the Vault's underlying is stored as WETH compatible.\n        require(vault.underlyingIsWETH(), \"UNDERLYING_NOT_WETH\");\n\n        // Transfer in the provided amount of rvTokens from the caller.\n        ERC20(vault).safeTransferFrom(msg.sender, address(this), rvTokenAmount);\n\n        // Redeem the rvTokens.\n        vault.redeem(rvTokenAmount);\n\n        // Get the Vault's underlying as WETH.\n        WETH weth = WETH(payable(address(vault.UNDERLYING())));\n\n        // Unwrap all our WETH and transfer it to the caller.\n        unwrapAndTransfer(weth, weth.balanceOf(address(this)));\n    }\n\n    /// @notice Redeem ETH from a WETH compatible Vault.\n    /// @param vault The WETH compatible Vault to redeem from.\n    /// @param rvTokenAmount The amount of rvTokens to withdraw from the Vault.\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\n    function redeemETHFromVaultWithPermit(\n        Vault vault,\n        uint256 rvTokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        // Ensure the Vault's underlying is stored as WETH compatible.\n        require(vault.underlyingIsWETH(), \"UNDERLYING_NOT_WETH\");\n\n        // Transfer in the provided amount of rvTokens from the caller via permit.\n        permitAndTransferFromCaller(vault, rvTokenAmount, deadline, v, r, s);\n\n        // Redeem the rvTokens.\n        vault.redeem(rvTokenAmount);\n\n        // Get the Vault's underlying as WETH.\n        WETH weth = WETH(payable(address(vault.UNDERLYING())));\n\n        // Unwrap all our WETH and transfer it to the caller.\n        unwrapAndTransfer(weth, weth.balanceOf(address(this)));\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          WETH UNWRAPPING LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @dev Unwraps the provided amount of WETH and transfers it to the caller.\n    /// @param weth The WETH contract to withdraw the amount from.\n    /// @param amount The amount of WETH to unwrap into ETH and transfer.\n    function unwrapAndTransfer(WETH weth, uint256 amount) internal {\n        // Convert the WETH into ETH.\n        weth.withdraw(amount);\n\n        // Transfer the unwrapped ETH to the caller.\n        msg.sender.safeTransferETH(amount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          VAULT DEPOSIT LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @dev Approves tokens, deposits them into a Vault\n    /// and transfers the minted rvTokens back to the caller.\n    /// @param vault The Vault to deposit into.\n    /// @param underlying The underlying token the Vault accepts.\n    /// @param amount The minimum amount that must be approved.\n    function depositIntoVaultForCaller(\n        Vault vault,\n        ERC20 underlying,\n        uint256 amount\n    ) internal {\n        // Approve the underlying tokens to the Vault.\n        underlying.safeApprove(address(vault), amount);\n\n        // Deposit the underlying tokens into the Vault.\n        vault.deposit(amount);\n\n        // Transfer the newly minted rvTokens back to the caller.\n        ERC20(vault).safeTransfer(msg.sender, vault.balanceOf(address(this)));\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                              PERMIT LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @dev Permits tokens from the caller and transfers them into the module.\n    /// @param token The token to permit and transfer in.\n    /// @param amount The amount of tokens to permit and transfer in.\n    /// @param deadline A timestamp, the block's timestamp must be less than or equal to this timestamp.\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\n    function permitAndTransferFromCaller(\n        ERC20 token,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        // Approve the tokens from the caller to the module via permit.\n        token.permit(msg.sender, address(this), amount, deadline, v, r, s);\n\n        // Transfer the tokens from the caller to the module.\n        token.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @dev Max permits tokens from the caller and transfers them into the module.\n    /// @param token The token to permit and transfer in.\n    /// @param amount The amount of tokens to permit and transfer in.\n    /// @param nonce The callers's nonce, increases at each call to permit.\n    /// @param expiry The timestamp at which the permit is no longer valid.\n    /// @param v Must produce valid secp256k1 signature from the caller along with r and s.\n    /// @param r Must produce valid secp256k1 signature from the caller along with v and s.\n    /// @param s Must produce valid secp256k1 signature from the caller along with r and v.\n    /// @dev Alternative to permitAndTransferFromCaller for tokens using DAI's non-standard permit interface.\n    function allowedPermitAndTransferFromCaller(\n        ERC20 token,\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        // Approve the tokens from the caller to the module via DAI's non-standard permit.\n        AllowedPermit(address(token)).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        // Transfer the tokens from the caller to the module.\n        token.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          RECIEVE ETHER LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @dev Required for the module to receive unwrapped ETH.\n    receive() external payable {}\n}\n"
    },
    "srcBuild/interfaces/AllowedPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\n/// @notice Minimal interface for tokens using DAI's non-standard permit interface.\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/external/IERC20PermitAllowed.sol)\nabstract contract AllowedPermit is ERC20 {\n    /// @param holder The address of the token owner.\n    /// @param spender The address of the token spender.\n    /// @param nonce The owner's nonce, increases at each call to permit.\n    /// @param expiry The timestamp at which the permit is no longer valid.\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0.\n    /// @param v Must produce valid secp256k1 signature from the owner along with r and s.\n    /// @param r Must produce valid secp256k1 signature from the owner along with v and s.\n    /// @param s Must produce valid secp256k1 signature from the owner along with r and v.\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual;\n}\n"
    },
    "srcBuild/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport {Bytes32AddressLib} from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport {Vault} from \"./Vault.sol\";\n\n/// @title Rari Vault Factory\n/// @author Transmissions11 and JetJadeja\n/// @notice Factory which enables deploying a Vault for any ERC20 token.\ncontract VaultFactory is Auth {\n    using Bytes32AddressLib for address;\n    using Bytes32AddressLib for bytes32;\n\n    /* //////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Creates a Vault factory.\n    /// @param _owner The owner of the factory.\n    /// @param _authority The Authority of the factory.\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /* //////////////////////////////////////////////////////////////\n                          VAULT DEPLOYMENT LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when a new Vault is deployed.\n    /// @param vault The newly deployed Vault contract.\n    /// @param underlying The underlying token the new Vault accepts.\n    event VaultDeployed(Vault vault, ERC20 underlying);\n\n    /// @notice Deploys a new Vault which supports a specific underlying token.\n    /// @dev This will revert if a Vault that accepts the same underlying token has already been deployed.\n    /// @param underlying The ERC20 token that the Vault should accept.\n    /// @return vault The newly deployed Vault contract which accepts the provided underlying token.\n    function deployVault(ERC20 underlying) external returns (Vault vault) {\n        // Use the CREATE2 opcode to deploy a new Vault contract.\n        // This will revert if a Vault which accepts this underlying token has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        vault = new Vault{salt: address(underlying).fillLast12Bytes()}(underlying);\n\n        emit VaultDeployed(vault, underlying);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            VAULT LOOKUP LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Computes a Vault's address from its accepted underlying token.\n    /// @param underlying The ERC20 token that the Vault should accept.\n    /// @return The address of a Vault which accepts the provided underlying token.\n    /// @dev The Vault returned may not be deployed yet. Use isVaultDeployed to check.\n    function getVaultFromUnderlying(ERC20 underlying) external view returns (Vault) {\n        return\n            Vault(\n                payable(\n                    keccak256(\n                        abi.encodePacked(\n                            // Prefix:\n                            bytes1(0xFF),\n                            // Creator:\n                            address(this),\n                            // Salt:\n                            address(underlying).fillLast12Bytes(),\n                            // Bytecode hash:\n                            keccak256(\n                                abi.encodePacked(\n                                    // Deployment bytecode:\n                                    type(Vault).creationCode,\n                                    // Constructor arguments:\n                                    abi.encode(underlying)\n                                )\n                            )\n                        )\n                    ).fromLast20Bytes() // Convert the CREATE2 hash into an address.\n                )\n            );\n    }\n\n    /// @notice Returns if a Vault at an address has already been deployed.\n    /// @param vault The address of a Vault which may not have been deployed yet.\n    /// @return A boolean indicating whether the Vault has been deployed already.\n    /// @dev This function is useful to check the return values of getVaultFromUnderlying,\n    /// as it does not check that the Vault addresses it computes have been deployed yet.\n    function isVaultDeployed(Vault vault) external view returns (bool) {\n        return address(vault).code.length > 0;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "srcBuild/modules/VaultInitializationModule.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\n\nimport {Vault} from \"../Vault.sol\";\nimport {VaultFactory} from \"../VaultFactory.sol\";\n\nimport {VaultConfigurationModule} from \"./VaultConfigurationModule.sol\";\n\n/// @title Rari Vault Initialization Module\n/// @author Transmissions11 and JetJadeja\n/// @notice Module for initializing newly created Vaults.\ncontract VaultInitializationModule is Auth {\n    /// @notice Vault configuration module used to configure Vaults before initialization.\n    VaultConfigurationModule public configModule;\n\n    /// @notice Creates a Vault initialization module.\n    /// @param _configModule The Vault configuration module the\n    /// module will use to configure Vaults before initialization.\n    /// @param _owner The owner of the module.\n    /// @param _authority The Authority of the module.\n    constructor(\n        VaultConfigurationModule _configModule,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) {\n        configModule = _configModule;\n    }\n\n    /// @notice Emitted when the config module is updated.\n    /// @param newConfigModule The new configuration module.\n    event ConfigModuleUpdated(VaultConfigurationModule newConfigModule);\n\n    /// @notice Sets a new Vault configuration module.\n    /// @param newConfigModule The Vault configuration module to set.\n    function setConfigModule(VaultConfigurationModule newConfigModule) external requiresAuth {\n        // Update the config module.\n        configModule = newConfigModule;\n\n        emit ConfigModuleUpdated(newConfigModule);\n    }\n\n    /// @notice Properly configures and initializes a newly deployed Vault.\n    /// @dev This will revert if the Vault has already been initialized.\n    /// @param vault The Vault to configure and initialize.\n    function initializeVault(Vault vault) external {\n        // Configure all key parameters.\n        configModule.syncFeePercent(vault);\n        configModule.syncHarvestDelay(vault);\n        configModule.syncHarvestWindow(vault);\n        configModule.syncTargetFloatPercent(vault);\n\n        // Open the Vault up for deposits.\n        vault.initialize();\n    }\n}\n"
    },
    "srcBuild/modules/VaultConfigurationModule.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\n\nimport {Vault} from \"../Vault.sol\";\n\n/// @title Rari Vault Configuration Module\n/// @author Transmissions11 and JetJadeja\n/// @notice Module for configuring Vault parameters.\ncontract VaultConfigurationModule is Auth {\n    /* //////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Creates a Vault configuration module.\n    /// @param _owner The owner of the module.\n    /// @param _authority The Authority of the module.\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /* //////////////////////////////////////////////////////////////\n                  DEFAULT VAULT PARAMETER CONFIGURATION\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when the default fee percentage is updated.\n    /// @param newDefaultFeePercent The new default fee percentage.\n    event DefaultFeePercentUpdated(uint256 newDefaultFeePercent);\n\n    /// @notice Emitted when the default harvest delay is updated.\n    /// @param newDefaultHarvestDelay The new default harvest delay.\n    event DefaultHarvestDelayUpdated(uint64 newDefaultHarvestDelay);\n\n    /// @notice Emitted when the default harvest window is updated.\n    /// @param newDefaultHarvestWindow The new default harvest window.\n    event DefaultHarvestWindowUpdated(uint128 newDefaultHarvestWindow);\n\n    /// @notice Emitted when the default target float percentage is updated.\n    /// @param newDefaultTargetFloatPercent The new default target float percentage.\n    event DefaultTargetFloatPercentUpdated(uint256 newDefaultTargetFloatPercent);\n\n    /// @notice The default fee percentage for Vaults.\n    /// @dev See the documentation for the feePercentage\n    /// variable in the Vault contract for more details.\n    uint256 public defaultFeePercent;\n\n    /// @notice The default harvest delay for Vaults.\n    /// @dev See the documentation for the harvestDelay\n    /// variable in the Vault contract for more details.\n    uint64 public defaultHarvestDelay;\n\n    /// @notice The default harvest window for Vaults.\n    /// @dev See the documentation for the harvestWindow\n    /// variable in the Vault contract for more details.\n    uint128 public defaultHarvestWindow;\n\n    /// @notice The default target float percentage for Vaults.\n    /// @dev See the documentation for the targetFloatPercent\n    /// variable in the Vault contract for more details.\n    uint256 public defaultTargetFloatPercent;\n\n    /// @notice Sets the default fee percentage for Vaults.\n    /// @param newDefaultFeePercent The new default fee percentage to set.\n    function setDefaultFeePercent(uint256 newDefaultFeePercent) external requiresAuth {\n        // Update the default fee percentage.\n        defaultFeePercent = newDefaultFeePercent;\n\n        emit DefaultFeePercentUpdated(newDefaultFeePercent);\n    }\n\n    /// @notice Sets the default harvest delay for Vaults.\n    /// @param newDefaultHarvestDelay The new default harvest delay to set.\n    function setDefaultHarvestDelay(uint64 newDefaultHarvestDelay) external requiresAuth {\n        // Update the default harvest delay.\n        defaultHarvestDelay = newDefaultHarvestDelay;\n\n        emit DefaultHarvestDelayUpdated(newDefaultHarvestDelay);\n    }\n\n    /// @notice Sets the default harvest window for Vaults.\n    /// @param newDefaultHarvestWindow The new default harvest window to set.\n    function setDefaultHarvestWindow(uint128 newDefaultHarvestWindow) external requiresAuth {\n        // Update the default harvest window.\n        defaultHarvestWindow = newDefaultHarvestWindow;\n\n        emit DefaultHarvestWindowUpdated(newDefaultHarvestWindow);\n    }\n\n    /// @notice Sets the default target float percentage for Vaults.\n    /// @param newDefaultTargetFloatPercent The new default target float percentage to set.\n    function setDefaultTargetFloatPercent(uint256 newDefaultTargetFloatPercent) external requiresAuth {\n        // Update the default target float percentage.\n        defaultTargetFloatPercent = newDefaultTargetFloatPercent;\n\n        emit DefaultTargetFloatPercentUpdated(newDefaultTargetFloatPercent);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                  CUSTOM VAULT PARAMETER CONFIGURATION\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when a Vault has its custom fee percentage set/updated.\n    /// @param vault The Vault that had its custom fee percentage set/updated.\n    /// @param newCustomFeePercent The new custom fee percentage for the Vault.\n    event CustomFeePercentUpdated(Vault indexed vault, uint256 newCustomFeePercent);\n\n    /// @notice Emitted when a Vault has its custom harvest delay set/updated.\n    /// @param vault The Vault that had its custom harvest delay set/updated.\n    /// @param newCustomHarvestDelay The new custom harvest delay for the Vault.\n    event CustomHarvestDelayUpdated(Vault indexed vault, uint256 newCustomHarvestDelay);\n\n    /// @notice Emitted when a Vault has its custom harvest window set/updated.\n    /// @param vault The Vault that had its custom harvest window set/updated.\n    /// @param newCustomHarvestWindow The new custom harvest window for the Vault.\n    event CustomHarvestWindowUpdated(Vault indexed vault, uint256 newCustomHarvestWindow);\n\n    /// @notice Emitted when a Vault has its custom target float percentage set/updated.\n    /// @param vault The Vault that had its custom target float percentage set/updated.\n    /// @param newCustomTargetFloatPercent The new custom target float percentage for the Vault.\n    event CustomTargetFloatPercentUpdated(Vault indexed vault, uint256 newCustomTargetFloatPercent);\n\n    /// @notice Maps Vaults to their custom fee percentage.\n    /// @dev Will be 0 if there is no custom fee percentage for the Vault.\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\n    mapping(Vault => uint256) public getVaultCustomFeePercent;\n\n    /// @notice Maps Vaults to their custom harvest delay.\n    /// @dev Will be 0 if there is no custom harvest delay for the Vault.\n    /// @dev See the documentation for the harvestDelay variable in the Vault contract for more details.\n    mapping(Vault => uint64) public getVaultCustomHarvestDelay;\n\n    /// @notice Maps Vaults to their custom harvest window.\n    /// @dev Will be 0 if there is no custom harvest window for the Vault.\n    /// @dev See the documentation for the harvestWindow variable in the Vault contract for more details.\n    mapping(Vault => uint128) public getVaultCustomHarvestWindow;\n\n    /// @notice Maps Vaults to their custom target float percentage.\n    /// @dev Will be 0 if there is no custom target float percentage for the Vault.\n    /// @dev See the documentation for the targetFloatPercent variable in the Vault contract for more details.\n    mapping(Vault => uint256) public getVaultCustomTargetFloatPercent;\n\n    /// @notice Sets the custom fee percentage for the Vault.\n    /// @param vault The Vault to set the custom fee percentage for.\n    /// @param customFeePercent The new custom fee percentage to set.\n    function setVaultCustomFeePercent(Vault vault, uint256 customFeePercent) external requiresAuth {\n        // Update the Vault's custom fee percentage.\n        getVaultCustomFeePercent[vault] = customFeePercent;\n\n        emit CustomFeePercentUpdated(vault, customFeePercent);\n    }\n\n    /// @notice Sets the custom harvest delay for the Vault.\n    /// @param vault The Vault to set the custom harvest delay for.\n    /// @param customHarvestDelay The new custom harvest delay to set.\n    function setVaultCustomHarvestDelay(Vault vault, uint64 customHarvestDelay) external requiresAuth {\n        // Update the Vault's custom harvest delay.\n        getVaultCustomHarvestDelay[vault] = customHarvestDelay;\n\n        emit CustomHarvestDelayUpdated(vault, customHarvestDelay);\n    }\n\n    /// @notice Sets the custom harvest window for the Vault.\n    /// @param vault The Vault to set the custom harvest window for.\n    /// @param customHarvestWindow The new custom harvest window to set.\n    function setVaultCustomHarvestWindow(Vault vault, uint128 customHarvestWindow) external requiresAuth {\n        // Update the Vault's custom harvest window.\n        getVaultCustomHarvestWindow[vault] = customHarvestWindow;\n\n        emit CustomHarvestWindowUpdated(vault, customHarvestWindow);\n    }\n\n    /// @notice Sets the custom target float percentage for the Vault.\n    /// @param vault The Vault to set the custom target float percentage for.\n    /// @param customTargetFloatPercent The new custom target float percentage to set.\n    function setVaultCustomTargetFloatPercent(Vault vault, uint256 customTargetFloatPercent) external requiresAuth {\n        // Update the Vault's custom target float percentage.\n        getVaultCustomTargetFloatPercent[vault] = customTargetFloatPercent;\n\n        emit CustomTargetFloatPercentUpdated(vault, customTargetFloatPercent);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                       VAULT PARAMETER SYNC LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Syncs a Vault's fee percentage with either the Vault's custom fee\n    /// percentage or the default fee percentage if a custom percentage is not set.\n    /// @param vault The Vault to sync the fee percentage for.\n    function syncFeePercent(Vault vault) external {\n        // Get the Vault's custom fee percentage.\n        uint256 customFeePercent = getVaultCustomFeePercent[vault];\n\n        // Determine what the new fee percentage should be for the Vault after the sync.\n        uint256 newFeePercent = customFeePercent == 0 ? defaultFeePercent : customFeePercent;\n\n        // Prevent spamming as this function requires no authorization.\n        require(vault.feePercent() != newFeePercent, \"ALREADY_SYNCED\");\n\n        // Set the Vault's fee percentage to the custom fee percentage\n        // or the default fee percentage if a custom percentage isn't set.\n        vault.setFeePercent(newFeePercent);\n    }\n\n    /// @notice Syncs a Vault's harvest delay with either the Vault's custom\n    /// harvest delay or the default harvest delay if a custom delay is not set.\n    /// @param vault The Vault to sync the harvest delay for.\n    function syncHarvestDelay(Vault vault) external {\n        // Get the Vault's custom harvest delay.\n        uint64 customHarvestDelay = getVaultCustomHarvestDelay[vault];\n\n        // Determine what the new harvest delay should be for the Vault after the sync.\n        uint64 newHarvestDelay = customHarvestDelay == 0 ? defaultHarvestDelay : customHarvestDelay;\n\n        // Prevent spamming as this function requires no authorization.\n        require(vault.harvestDelay() != newHarvestDelay, \"ALREADY_SYNCED\");\n\n        // Set the Vault's harvest delay to the custom harvest delay\n        // or the default harvest delay if a custom delay isn't set.\n        vault.setHarvestDelay(newHarvestDelay);\n    }\n\n    /// @notice Syncs a Vault's harvest window with either the Vault's custom\n    /// harvest window or the default harvest window if a custom window is not set.\n    /// @param vault The Vault to sync the harvest window for.\n    function syncHarvestWindow(Vault vault) external {\n        // Get the Vault's custom harvest window.\n        uint128 customHarvestWindow = getVaultCustomHarvestWindow[vault];\n\n        // Determine what the new harvest window should be for the Vault after the sync.\n        uint128 newHarvestWindow = customHarvestWindow == 0 ? defaultHarvestWindow : customHarvestWindow;\n\n        // Prevent spamming as this function requires no authorization.\n        require(vault.harvestWindow() != newHarvestWindow, \"ALREADY_SYNCED\");\n\n        // Set the Vault's harvest window to the custom harvest window\n        // or the default harvest window if a custom window isn't set.\n        vault.setHarvestWindow(newHarvestWindow);\n    }\n\n    /// @notice Syncs a Vault's target float percentage with either the Vault's custom target\n    /// float percentage or the default target float percentage if a custom percentage is not set.\n    /// @param vault The Vault to sync the target float percentage for.\n    function syncTargetFloatPercent(Vault vault) external {\n        // Get the Vault's custom target float percentage.\n        uint256 customTargetFloatPercent = getVaultCustomTargetFloatPercent[vault];\n\n        // Determine what the new target float percentage should be for the Vault after the sync.\n        uint256 newTargetFloatPercent = customTargetFloatPercent == 0\n            ? defaultTargetFloatPercent\n            : customTargetFloatPercent;\n\n        // Prevent spamming as this function requires no authorization.\n        require(vault.targetFloatPercent() != newTargetFloatPercent, \"ALREADY_SYNCED\");\n\n        // Set the Vault's target float percentage to the custom target float percentage\n        // or the default target float percentage if a custom percentage isn't set.\n        vault.setTargetFloatPercent(newTargetFloatPercent);\n    }\n}\n"
    },
    "srcBuild/AphraToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract AphraToken is ERC20(\"Aphra Finance DAO\", \"APHRA\", 18) {\n\n\n    error NotMinter();\n    event MinterChanged(address newMinter, address minter);\n\n    address public minter;\n    constructor(\n    ) {\n        minter = msg.sender;\n        _mint(msg.sender, 0);\n    }\n\n    function setMinter(address newMinter_) external {\n        if (msg.sender != minter) revert NotMinter();\n        minter = newMinter_;\n        emit MinterChanged(newMinter_, minter);\n    }\n\n    function mint(address account, uint amount) external returns (bool) {\n        if (msg.sender != minter) revert NotMinter();\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "srcBuild/MultiRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n\n    /* ///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /* ///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /* ///////////////////////////////////////////////////////////////\n                       CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /* ///////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                          AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                      USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                  ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"
    },
    "srcBuild/modules/VaultAuthorityModule.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.11;\n\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\n\n/// @title Rari Vault Authority Module\n/// @notice Module for managing access to secured Vault operations.\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\ncontract VaultAuthorityModule is Auth, Authority {\n    /* //////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Creates a Vault configuration module.\n    /// @param _owner The owner of the module.\n    /// @param _authority The Authority of the module.\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /* //////////////////////////////////////////////////////////////\n                       CUSTOM TARGET AUTHORITY STORAGE\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Maps targets to a custom Authority to use for authorization.\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /* //////////////////////////////////////////////////////////////\n                             USER ROLE STORAGE\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Maps users to a bytes32 set of all the roles assigned to them.\n    mapping(address => bytes32) public getUserRoles;\n\n    /// @notice Gets whether a user has a specific role.\n    /// @param user The user to check for.\n    /// @param role The role to check if the user has.\n    /// @return A boolean indicating whether the user has the role.\n    function doesUserHaveRole(address user, uint8 role) external view returns (bool) {\n        unchecked {\n            // Generate a mask for the role.\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\n\n            // Check if the user has the role using the generated mask.\n            return bytes32(0) != getUserRoles[user] & shifted;\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        ROLE CAPABILITY STORAGE\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Maps function signatures to a set of all roles that can call the given function.\n    mapping(bytes4 => bytes32) public getRoleCapabilities;\n\n    /// @notice Maps function signatures to a boolean indicating whether anyone can call the given function.\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    /// @notice Gets whether a role has a specific capability.\n    /// @param role The role to check for.\n    /// @param functionSig function to check the role is capable of calling.\n    /// @return A boolean indicating whether the role has the capability.\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) external view virtual returns (bool) {\n        unchecked {\n            // Generate a mask for the role.\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\n\n            // Check if the role has the capability using the generated mask.\n            return bytes32(0) != getRoleCapabilities[functionSig] & shifted;\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                          AUTHORIZATION LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Returns if a user can call a given target's function.\n    /// @param user The user to check for.\n    /// @param target The target the user is trying to call.\n    /// @param functionSig The function signature the user is trying to call.\n    /// @return A boolean indicating if the user can call the function on the target.\n    /// @dev First checks whether the target has a custom Authority assigned to it, if so returns\n    /// whether the custom Authority would allow the user to call the desired function on the target,\n    /// otherwise returns whether the user is able to call the desired function on any target contract.\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view override returns (bool) {\n        // Get the target's custom Authority. Will be address(0) if none.\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        // If a custom Authority is set, return whether the Authority allows the user to call the function.\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        // Return whether the user has an authorized role or the capability is publicly accessible.\n        return bytes32(0) != getUserRoles[user] & getRoleCapabilities[functionSig] || isCapabilityPublic[functionSig];\n    }\n\n    /* //////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when a custom Authority is set for a target.\n    /// @param target The target who had a custom Authority set.\n    /// @param authority The custom Authority set for the target.\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /// @notice Sets a custom Authority for a target.\n    /// @param target The target to set a custom Authority for.\n    /// @param customAuthority The custom Authority to set.\n    function setTargetCustomAuthority(address target, Authority customAuthority) external requiresAuth {\n        // Update the target's custom Authority.\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                  ROLE CAPABILITY CONFIGURATION LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when a role's capabilities are updated.\n    /// @param role The role whose capabilities were updated.\n    /// @param functionSig The function the role was enabled to call or not.\n    /// @param enabled Whether the role is now able to call the function or not.\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    /// @notice Sets a capability for a role.\n    /// @param role The role to set a capability for.\n    /// @param functionSig The function to enable the role to call or not.\n    /// @param enabled Whether the role should be able to call the function or not.\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) external requiresAuth {\n        // Get the previous set of role capabilities.\n        bytes32 lastCapabilities = getRoleCapabilities[functionSig];\n\n        unchecked {\n            // Generate a mask for the role.\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\n\n            // Update the role's capability set with the role mask.\n            getRoleCapabilities[functionSig] = enabled ? lastCapabilities | shifted : lastCapabilities & ~shifted;\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when whether a capability is public is updated.\n    /// @param functionSig The function that was made public or not.\n    /// @param enabled Whether the function is not publicly callable or not.\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    /// @notice Sets whether a capability is public or not.\n    /// @param functionSig The function make public or not.\n    /// @param enabled Whether the function should be public or not.\n    function setPublicCapability(bytes4 functionSig, bool enabled) external requiresAuth {\n        // Update whether the capability is public.\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                      USER ROLE ASSIGNMENT LOGIC\n    ///////////////////////////////////////////////////////////// */\n\n    /// @notice Emitted when a user's role is updated.\n    /// @param user The user who had their role updated.\n    /// @param role The role the user had assigned/removed.\n    /// @param enabled Whether the user had the role assigned/removed.\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    /// @notice Assigns a role to a user.\n    /// @param user The user to assign a role to.\n    /// @param role The role to assign to the user.\n    /// @param enabled Whether the user should have the role or not.\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) external requiresAuth {\n        // Get the previous set of roles.\n        bytes32 lastRoles = getUserRoles[user];\n\n        unchecked {\n            // Generate a mask for the role.\n            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));\n\n            // Update the user's role set with the role mask.\n            getUserRoles[user] = enabled ? lastRoles | shifted : lastRoles & ~shifted;\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "srcBuild/Minter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\nimport {Auth, Authority} from \"@rari-capital/solmate/src/auth/Auth.sol\";\nlibrary Math {\n    function max(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\ninterface ve {\n    function token() external view returns (address);\n    function isUnlocked() external view returns (bool);\n    function totalSupply() external view returns (uint);\n    function create_lock_for(uint, uint, address) external returns (uint);\n    function transferFrom(address, address, uint) external;\n}\n\ninterface underlying {\n    function approve(address spender, uint value) external returns (bool);\n    function mint(address, uint) external;\n    function setMinter(address) external;\n    function totalSupply() external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n    function transfer(address, uint) external returns (bool);\n}\n\ninterface voter {\n    function notifyRewardAmount(uint amount) external;\n}\n\ninterface ve_dist {\n    function checkpoint_token() external;\n    function checkpoint_total_supply() external;\n}\n\n// codifies the minting rules as per ve(3,3), abstracted from the token to support any token that allows minting\n\n//add safetransferlib\ncontract Minter is Auth {\n\n    uint internal constant week = 86400 * 7; // allows minting once per week (reset every Thursday 00:00 UTC)\n    uint internal emission = 98;\n    uint internal tail_emission = 2;\n    uint internal constant target_base = 100; // 2% per week target emission\n    uint internal constant tail_base = 1000; // 0.2% per week target emission\n    underlying public immutable _token;\n    voter public immutable _voter;\n    ve public immutable _ve;\n    ve_dist public immutable _ve_dist;\n    uint public weekly = 625_000e18;\n    uint public active_period;\n    uint internal constant lock = 86400 * 7 * 52 * 2; //2 year lock\n\n    address internal initializer;\n    address internal airdrop;\n\n    event Mint(address indexed sender, uint weekly, uint circulating_supply, uint circulating_emission);\n\n    constructor(\n        address GOVERNANCE_,\n        address AUTHORITY_,\n        address __voter, // the voting & distribution system\n        address  __ve, // the veAPHRA system that will be locked into\n        address __ve_dist // the distribution system that ensures users aren't diluted after unlock\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_)) {\n        initializer = msg.sender;\n        _token = underlying(ve(__ve).token());\n        _voter = voter(__voter);\n        _ve = ve(__ve);\n        _ve_dist = ve_dist(__ve_dist);\n        active_period = (block.timestamp + (1 * week)) / week * week;\n    }\n\n    //for guarded launch\n    function migrateMinter(address newMinter_) external requiresAuth {\n        _token.setMinter(newMinter_);\n    }\n\n    function initialize(\n        address[] memory initVeLocks,\n        uint[] memory initVeAmounts,\n        address[] memory initToken,\n        uint[] memory initTokenAmounts,\n        uint max // sum amounts / max = % ownership of top protocols, so if initial 20m is distributed, and target is 25% protocol ownership, then max - 4 x 20m = 80m\n    ) external {\n        //setup initial mint params here, lock team as ve nft's\n        //setup fund team vesting locks\n        require(initializer == msg.sender);\n        _token.mint(address(this), max);\n        _token.approve(address(_ve), type(uint).max);\n\n        for (uint i = 0; i < initVeLocks.length; i++) {\n            _ve.create_lock_for(initVeAmounts[i], lock, initVeLocks[i]);\n        }\n\n        for (uint i = 0; i < initToken.length; i++) {\n            _token.transfer(initToken[i], initTokenAmounts[i]);\n        }\n\n        //set to the last item in the initToken array as it is the airdrop and we want to exclude the airdrops balance\n        // for supply emission calculations as it can only enter into ve when claimed\n        airdrop = address(initToken[initToken.length - 1]);\n        initializer = address(0);\n        active_period = (block.timestamp + week) / week * week;\n    }\n\n    function setEmission(uint newEmission_) external requiresAuth {\n        emission = newEmission_;\n    }\n\n    function setTailEmission(uint newTailEmission_) external requiresAuth {\n        tail_emission = newTailEmission_;\n    }\n\n    function setWeeklyRate(uint newWeeklyRate_) external requiresAuth {\n        weekly = newWeeklyRate_;\n    }\n\n    // calculate circulating supply as total token supply - locked supply\n    function circulating_supply() public view returns (uint) {\n        return _token.totalSupply() - _ve.totalSupply() - _token.balanceOf(airdrop) - _token.balanceOf(owner);\n    }\n\n    // emission calculation is 2% of available supply to mint adjusted by circulating / total supply\n    function calculate_emission() public view returns (uint) {\n        return weekly * emission * circulating_supply() / target_base / _token.totalSupply();\n    }\n\n    // weekly emission takes the max of calculated (aka target) emission versus circulating tail end emission\n    function weekly_emission() public view returns (uint) {\n        if(!ve(_ve).isUnlocked()) {\n            return weekly;\n        }\n        return Math.max(calculate_emission(), circulating_emission());\n    }\n\n    // calculates tail end (infinity) emissions as 0.2% of total supply\n    function circulating_emission() public view returns (uint) {\n        return circulating_supply() * tail_emission / tail_base;\n    }\n\n    // calculate inflation and adjust ve balances accordingly\n    function calculate_growth(uint _minted) public view returns (uint) {\n        if(!ve(_ve).isUnlocked()) {\n            return 0;\n        }\n        return _ve.totalSupply() * _minted / _token.totalSupply();\n    }\n\n    // update period can only be called once per cycle (1 week)\n    function update_period() external returns (uint) {\n        uint _period = active_period;\n        if (block.timestamp >= _period + week && initializer == address(0)) { // only trigger if new week\n            _period = block.timestamp / week * week;\n            active_period = _period;\n            weekly = weekly_emission();\n\n            uint _growth = calculate_growth(weekly);\n            uint _required = _growth + weekly;\n            uint _balanceOf = _token.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                _token.mint(address(this), _required-_balanceOf);\n            }\n\n            require(_token.transfer(address(_ve_dist), _growth));\n            _ve_dist.checkpoint_token(); // checkpoint token balance that was just minted in ve_dist\n            _ve_dist.checkpoint_total_supply(); // checkpoint supply\n\n            _token.approve(address(_voter), weekly);\n            _voter.notifyRewardAmount(weekly);\n\n            emit Mint(msg.sender, weekly, circulating_supply(), circulating_emission());\n        }\n        return _period;\n    }\n\n}\n"
    },
    "srcBuild/governance/veGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\npragma experimental ABIEncoderV2;\n\nimport {veAPHRA} from \"../veAPHRA.sol\";\nimport {Timelock} from \"./Timelock.sol\";\n\ncontract veGovernor {\n    /// @notice The name of this contract\n    string public constant name = \"Aphra veGovernor\";\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint) {return 12_500_000e18;} // 12.5M = 12.5% of Aphra\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint) {return 2500e18;} // 2500 = 0.000025% of Aphra\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint) {return 10;} // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint) {return 1;} // 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure returns (uint) {return 40320;} // ~1 days in blocks (assuming 15s blocks)\n\n    /// @notice The address of the APHRA Protocol Timelock\n    Timelock public timelock;\n\n    /// @notice The address of the veAPHRA token\n    veAPHRA public ve;\n\n    /// @notice The address of the veGovernor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint public proposalCount;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n\n        /// @notice Creator of the proposal\n        uint badgeId;\n\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n\n        /// @notice Current number of votes in favor of this proposal\n        uint forVotes;\n\n        /// @notice Current number of votes in opposition to this proposal\n        uint againstVotes;\n\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(uint => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n\n        /// @notice The number of votes the voter had, which were cast\n        uint256 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(uint => uint) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint id, uint badgeId, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(uint badgeId, uint proposalId, bool support, uint votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint id, uint eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint id);\n\n    constructor(Timelock timelock_, veAPHRA ve_, address guardian_) {\n        timelock = timelock_;\n        ve = ve_;\n        guardian = guardian_;\n    }\n    function propose(uint badgeId_, address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n        require(ve.balanceOfNFTAt(badgeId_, (block.number - 1)) > proposalThreshold(), \"veGovernor::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"veGovernor::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"veGovernor::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"veGovernor::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[badgeId_];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"veGovernor::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"veGovernor::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = (block.number + votingDelay());\n        uint endBlock = (startBlock + votingPeriod());\n\n        Proposal storage newProposal = proposals[proposalCount++];\n\n\n        newProposal.id = proposalCount;\n        newProposal.badgeId = badgeId_;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.badgeId] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, badgeId_, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }\n\n    function queue(uint proposalId_) public {\n        require(state(proposalId_) == ProposalState.Succeeded, \"veGovernor::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId_];\n        uint eta = (block.timestamp + timelock.delay());\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId_, eta);\n    }\n\n    function _queueOrRevert(address target_, uint value_, string memory signature_, bytes memory data_, uint eta_) internal {\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target_, value_, signature_, data_, eta_))), \"veGovernor::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target_, value_, signature_, data_, eta_);\n    }\n\n    function execute(uint proposalId_) public payable {\n        require(state(proposalId_) == ProposalState.Queued, \"veGovernor::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId_];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value:proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId_);\n    }\n\n    function cancel(uint proposalId_) public {\n        ProposalState currentState = state(proposalId_);\n        require(currentState != ProposalState.Executed, \"veGovernor::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId_];\n        require(msg.sender == guardian || ve.balanceOfNFTAt(proposal.badgeId, (block.number - 1)) < proposalThreshold(), \"veGovernor::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n\n        emit ProposalCanceled(proposalId_);\n    }\n\n    function getActions(uint proposalId_) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n        Proposal storage p = proposals[proposalId_];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    function getReceipt(uint proposalId_, uint badgeId_) public view returns (Receipt memory) {\n        return proposals[proposalId_].receipts[badgeId_];\n    }\n\n    function state(uint proposalId_) public view returns (ProposalState) {\n        require(proposalCount >= proposalId_ && proposalId_ > 0, \"veGovernor::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId_];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= (proposal.eta + timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function castVote(uint badgeId_, uint proposalId_, bool support_) public {\n        require(msg.sender == ve.ownerOf(badgeId_));\n        return _castVote(badgeId_, proposalId_, support_);\n    }\n\n    function castVoteBySig(uint badgeId_, uint proposalId_, bool support_, uint8 v_, bytes32 r_, bytes32 s_) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, badgeId_, proposalId_, support_));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v_, r_, s_);\n\n        require(signatory == ve.ownerOf(badgeId_), \"veGovernor::castVoteBySig: invalid signature\");\n\n        return _castVote(badgeId_, proposalId_, support_);\n    }\n\n    function _castVote(uint badgeId_, uint proposalId_, bool support_) internal {\n        require(state(proposalId_) == ProposalState.Active, \"veGovernor::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId_];\n        Receipt storage receipt = proposal.receipts[badgeId_];\n        require(receipt.hasVoted == false, \"veGovernor::_castVote: badgeId already voted\");\n        uint votes = ve.balanceOfNFTAt(badgeId_, proposal.startBlock);\n\n        if (support_) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support_;\n        receipt.votes = votes;\n\n        emit VoteCast(badgeId_, proposalId_, support_, votes);\n    }\n\n    function __acceptAdmin() public {\n        require(msg.sender == guardian, \"veGovernor::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }\n\n    function __abdicate() public {\n        require(msg.sender == guardian, \"veGovernor::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin_, uint eta_) public {\n        require(msg.sender == guardian, \"veGovernor::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin_), eta_);\n    }\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin_, uint eta_) public {\n        require(msg.sender == guardian, \"veGovernor::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin_), eta_);\n    }\n\n    function getChainId() internal view returns (uint) {\n        uint chainId;\n        assembly {chainId := chainid()}\n        return chainId;\n    }\n}\n"
    },
    "srcBuild/governance/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ncontract Timelock {\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 2 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp() + delay, \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target_, uint value_, string memory signature_, bytes memory data_, uint eta_) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target_, value_, signature_, data_, eta_));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target_, value_, signature_, data_, eta_);\n    }\n\n    function executeTransaction(address target_, uint value_, string memory signature_, bytes memory data_, uint eta_) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target_, value_, signature_, data_, eta_));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta_, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta_ + GRACE_PERIOD, \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature_).length == 0) {\n            callData = data_;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature_))), data_);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target_.call{value: value_}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target_, value_, signature_, data_, eta_);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}